
Configuring Vectored Execution 

A Virtuoso 7 executable executes all SQL statements in vectored mode, except for positioned updates and deletes in stored procedures.
Procedures are executed without vectoring unless they are declared vectored using the vectored keyword.
A scalar (non-vectored) procedure can have a vectored block introduced with the for vectored construct.  These are discussed in the SQL reference section on vectoring.

Vectored execution is controlled by the following virtuoso.ini settings:


VectorSize = 10000 

This is the default number of concurrent variable bindings that are generated for a column in a batch of bindings.  


AdjustVectorSize = 0

If non-zero, this enables automatic increasing of vector size whenever the system notices a random access pattern that is not benefiting from vectoring due to too few consecutive hits falling on the same page.  The vector size can be increased up to MaxVectorSize if the situation warrants.  This is the case if there is enough unprocessed state in the query.

MaxVectorSize = 1000000 

This is the maximum vector size.  This can reach up to 4000000 but values inb excess of 1000000 have not been found useful in practice.
If the server is running out of memory with multiuser workloads involving long queries, dropping the MaxVectorSize to a lower value is a means of curtailing per query memory consumption.

ThreadsPerQuery = 8

This controls the maximum number of parallelizable work units a query
will have outstanding at any one time.  A value of 8 means that a scan
or vector of lookups is maximally divided into 8 units, of which 7
will be allocated to a pool of worker threads and one will be
processed by the thread coordinating the query.  Each query will
always have one thread running, which is the thread allocated for
serving the client-server or HTTP request initiating the query.  Extra
work units are serviced by threads from a parallel execution thread
pool.  If there are unstarted parallel work units that have not
started at the time the coordinated thread finishes its own work unit,
it will execute any of its own pending work units locally.

AsyncQueueMaxThreads = 16


This is the maximum number of worker threads that can be started for running parallelized work units generated by queries or functions requested with the aq_request () PL function.
Thus the number of threads running on a server at any time is the number of client server or HTTP threads that have a running request plus this number.  
These threads consider the totality of all async execution requests across all async queues and each thread picks a unit of work from the oldest queue that has unstarted work units.  The age of the queue is the timestamp of its creation.  A queue is created whenever a query operator decides to split its work.  This scheduling favors thus old queries over new ones.  However any request is guaranteed one thread, that on which its initiating request is served. 

For a query processing workload, one should set  AsyncQueueMaxThreads to the number of cores minus the expected number of concurrent queries, this would in principle use all cores or core threads.
In practice for machines with large numbers of cores, e.g. 32 cores, a lower value may serve in practice better, subject to experimentation.
For a web crawling situation  where threads are waiting for the network for most of the time, a larger number will do better.


These parameters can be set at run time by a dba group user using the __dbf_set function.

The names of the parameters are respectively:

VectorSize = dc_batch_sz 
MaxVectorSize = dc_max_batch_sz
AdjustVectorSize = enable_dyn_batch_sz
ThreadsPerQuery = enable_qp 
AsyncQueueMaxThreads = aq_max_threads 



Thus, to set the maxinum number of outstanding parallel work units to 16, the SQL statement is __dbf_set ('enable_qp', 16);

