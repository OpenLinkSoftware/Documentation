<?xml version="1.0" encoding="UTF-8"?>
<section xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:id="rdfspongerprogrammerguide">
        <title>Sponger Programmers Guide</title>
        <para>The Sponger forms part of the extensible RDF framework built into Virtuoso Universal Server. A
key component of the Sponger's pluggable architecture is its support for Sponger Cartridges, which
themselves are comprised of an Entity Extractor and an Ontology Mapper. Virtuoso bundles numerous
pre-written cartridges for RDF data extraction from a wide range of data sources. However, developers
are free to develop their own custom cartridges. This programmer's guide describes how.</para>
        <para>The guide is a companion to the <link xlink:href="http://virtuoso.openlinksw.com/Whitepapers/pdf/sponger_whitepaper_10102007.pdf">Virtuoso Sponger</link>

   whitepaper. The latter describes the Sponger in depth, its architecture, configuration, use and integration with other Virtuoso facilities such as the Open Data Services (ODS) application framework. This guide focuses solely on custom cartridge development.</para>
        <section xml:id="virtuosospongeroverviewxmlset">
          <title>Configuration of CURIEs used by the Sponger</title>
          <para>For configuring CURIEs used by the Sponger which is exposed via Sponger
clients such as "description.vsp" - the VSP based information resource description utility,
you can use the <link linkend="fn_xml_set_ns_decl"><function>xml_set_ns_decl</function></link>

   function.</para>
          <para>Here is sample example to add curie pattern:</para>
          <programlisting>
-- Example link: http://linkeddata.uriburner.com/about/rdf/http://twitter.com/guykawasaki/status/1144945513#this
XML_SET_NS_DECL ('uriburner',
                 'http://linkeddata.uriburner.com/about/rdf/http://',
                 2);
</programlisting>
        </section>
        <section xml:id="virtuosospongeroverviewcartarch">
          <title>Cartridge Architecture</title>
          <para>The Sponger is comprised of cartridges which are themselves comprised of an entity extractor
and an ontology mapper. Entities extracted from non-RDF resources are used as the basis for generating
structured data by mapping them to a suitable ontology. A cartridge is invoked through its cartridge hook,
a Virtuoso/PL procedure entry point and binding to the cartridge's entity extractor and ontology mapper.</para>
          <para>
            <emphasis>Entity Extractor</emphasis>
          </para>
          <para>When an RDF aware client requests data from a network accessible resource via the Sponger the
following events occur:</para>
          <itemizedlist mark="bullet">
            <listitem>
              <para>A request is made for data in RDF form (explicitly via HTTP Accept Headers), and if
RDF is returned nothing further happens. </para>
            </listitem>
            <listitem>
              <para>If RDF isn't returned, the Sponger passes the data through a </para>
              <para>
                <emphasis>Entity Extraction Pipeline</emphasis>
              </para>
              <para>
(using Entity Extractors). </para>
            </listitem>
            <listitem>
              <para>The extracted data is transformed into RDF via a </para>
              <para>
                <emphasis>Mapping Pipeline</emphasis>
              </para>
              <para>. RDF instance data is generated by way of ontology matching and mapping. </para>
            </listitem>
            <listitem>
              <para>RDF instance data (aka. RDF Structured Linked Data) are returned to the client.</para>
            </listitem>
          </itemizedlist>
          <para>
            <emphasis>Extraction Pipeline</emphasis>
          </para>
          <para>Depending on the file or format type detected at ingest, the Sponger applies the appropriate
entity extractor. Detection occurs at the time of content negotiation instigated by the retrieval user
agent. The normal extraction pipeline processing is as follows:</para>
          <itemizedlist mark="bullet">
            <listitem>
              <para>The Sponger tries to get RDF data (including N3 or Turtle) directly from the dereferenced
URL. If it finds some, it returns it, otherwise, it continues.</para>
            </listitem>
            <listitem>
              <para>If the URL refers to a HTML file, the Sponger tries to find "link" elements referring to
RDF documents. If it finds one or more of them, it adds their triples into a temporary RDF graph and
continues its processing.</para>
            </listitem>
            <listitem>
              <para>The Sponger then scans for microformats or GRDDL. If either is found, RDF triples are
generated and added to a temporary RDF graph before continuing.</para>
            </listitem>
            <listitem>
              <para>If the Sponger finds eRDF or RDFa data in the HTML file, it extracts it from the HTML
file and inserts it into the RDF graph before continuing.</para>
            </listitem>
            <listitem>
              <para>If the Sponger finds it is talking with a web service such as Google Base, it maps
the API of the web service with an ontology, creates triples from that mapping and includes the triples
into the temporary RDF graph.</para>
            </listitem>
            <listitem>
              <para>The next fallback is scanning of the HTML header for different Web 2.0 types or RSS
1.1, RSS 2.0, Atom, etc. </para>
            </listitem>
            <listitem>
              <para>Failing those tests, the scan then uses standard Web 1.0 rules to search in the
header tags for metadata (typically Dublin Core) and transform them to RDF and again add them to the
temporary graph. Other HTTP response header data may also be transformed to RDF.</para>
            </listitem>
            <listitem>
              <para>If nothing has been retrieved at this point, the ODS-Briefcase metadata
extractor is tried.</para>
            </listitem>
            <listitem>
              <para>Finally, if nothing is found, the Sponger will return an empty graph.</para>
            </listitem>
          </itemizedlist>
          <para>
            <emphasis>Ontology Mapper</emphasis>
          </para>
          <para>Sponger ontology mappers peform the the task of generating RDF instance data from
extracted entities (non-RDF) using ontologies associated with a given data source type. They are
typically XSLT (using GRDDL or an in-built Virtuoso mapping scheme) or Virtuoso/PL based. Virtuoso
comes preconfigured with a large range of ontology mappers contained in one or more Sponger
cartridges.</para>
          <para>
            <emphasis>Cartridge Registry</emphasis>
          </para>
          <para>To be recognized by the SPARQL engine, a Sponger cartridge must be registered in
the Cartridge Registry by adding a record to the table DB.DBA.SYS_RDF_MAPPERS, either manually
via DML, or more easily through Conductor, Virtuoso's browser-based administration console,
which provides a UI for adding your own cartridges. (Sponger configuration using Conductor is
described in detail later.) The SYS_RDF_MAPPERS table definition is as follows:</para>
          <programlisting>
create table "DB"."DBA"."SYS_RDF_MAPPERS"
(
"RM_ID" INTEGER IDENTITY,  -- cartridge ID. Determines the order of the cartridge's invocation in the Sponger processing chain
"RM_PATTERN" VARCHAR,  -- a REGEX pattern to match the resource URL or MIME type
"RM_TYPE" VARCHAR,  -- which property of the current resource to match: "MIME" or "URL"
"RM_HOOK" VARCHAR,  -- fully qualified Virtuoso/PL function name
"RM_KEY" LONG VARCHAR,  -- API specific key to use
"RM_DESCRIPTION" LONG VARCHAR,  -- cartridge description (free text)
"RM_ENABLED" INTEGER,  -- a 0 or 1 integer flag to exclude or include the cartridge from the Sponger processing chain
"RM_OPTIONS" ANY,  -- cartridge specific options
"RM_PID" INTEGER IDENTITY,
PRIMARY KEY ("RM_PATTERN", "RM_TYPE")
);
</programlisting>
        </section>
        <section xml:id="virtuosospongeroverviewcartinvo">
          <title>Cartridge Invocation</title>
          <para>The Virtuoso SPARQL processor supports IRI dereferencing via the Sponger. If a SPARQL query
references non-default graph URIs, the Sponger goes out (via HTTP) to Fetch the Network Resource data source URIs and
inserts the extracted RDF data into the local RDF quad store. The Sponger invokes the appropriate
cartridge for the data source type to produce RDF instance data. If none of the registered cartridges
are capable of handling the received content type, the Sponger will attempt to obtain RDF instance
data via the in-built WebDAV metadata extractor.</para>
          <para>Sponger cartridges are invoked as follows:</para>
          <para>When the SPARQL processor dereferences a URI, it plays the role of an HTTP user agent
(client) that makes a content type specific request to an HTTP server via the HTTP request's Accept
headers. The following then occurs:</para>
          <itemizedlist mark="bullet">
            <listitem>
              <para>If the content type returned is RDF then no further transformation is needed and
the process stops. For instance, when consuming an (X)HTML document with a GRDDL profile, the profile
URI points to a data provider that simply returns RDF instance data.</para>
            </listitem>
            <listitem>
              <para>If the content type is not RDF (i.e. application/rdf+xml or text/rdf+n3 ), for
instance 'text/plain', the Sponger looks in the Cartridge Registry iterating over every record for
which the RM_ENABLED flag is true, with the look-up sequence ordered on the RM_ID column values.
For each record, the processor tries matching the content type or URL against the RM_PATTERN value
and, if there is match, the function specified in RM_HOOK column is called. If the function doesn't
exist, or signals an error, the SPARQL processor looks at next record.
          </para>
              <itemizedlist mark="bullet">
                <listitem>
                  <para>If the hook returns zero, the next cartridge is tried. (A cartridge function
can return zero if it believes a subsequent cartridge in the chain is capable of extracting more
RDF data.)</para>
                </listitem>
                <listitem>
                  <para>If the result returned by the hook is negative, the Sponger is instructed
that no RDF was generated and the process stops. </para>
                </listitem>
                <listitem>
                  <para>If the hook result is positive, the Sponger is informed that structured
data was retrieved and the process stops.</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>If none of the cartridges match the source data signature (content type or URL),
the ODS-Briefcase WebDAV metadata extractor and RDF generator is called.</para>
            </listitem>
          </itemizedlist>
          <para>
            <emphasis>Meta-Cartridges</emphasis>
          </para>
          <para>The above describes the RDF generation process for 'primary' Sponger cartridges. Virtuoso
also supports another cartridge type - a 'meta-cartridge'. Meta-cartridges act as post-processors in
the cartridge pipeline, augmenting entity descriptions in an RDF graph with additional information
gleaned from 'lookup' data sources and web services. Meta-cartridges are described in more detail in
a later section.</para>
          <figure xml:id="spong1" floatstyle="1">
            <title>Meta-Cartridges</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="ui/spong1.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section xml:id="virtuosospongercatrbundled">
          <title>Cartridges Bundled with Virtuoso</title>
          <section xml:id="virtuosospongercatrbundledrdfvad">
            <title>Cartridges VAD</title>
            <para>Virtuoso supplies a number of prewritten cartridges for extracting RDF data from a
variety of popular Web resources and file types. The cartridges are bundled as part of the cartridges_dav
VAD (Virtuoso Application Distribution).</para>
            <para>To see which cartridges are available, look at the 'Linked Data' screen in
        	Conductor. This can be reached through the Linked Data -&gt; Sponger -&gt; Extractor
        	Cartridges and Meta Cartridges menu items.</para>
            <figure xml:id="spong2" floatstyle="1">
              <title>RDF Cartridges</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="ui/spong2.png"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>To check which version of the cartridges VAD is installed, or to upgrade it,
refer to Conductor's 'VAD Packages' screen, reachable through the 'System Admin' &gt; 'Packages'
menu items.</para>
            <para>The latest VADs for the closed source releases of Virtuoso can be
<link xlink:href="http://download.openlinksw.com/download/">downloaded</link>

   from the downloads area on the OpenLink website. Select either the 'DBMS (WebDAV) Hosted' or
'File System Hosted' product format from the 'Distributed Collaborative Applications' section,
depending on whether you want the Virtuoso application to use WebDAV or native filesystem storage.
VADs for Virtuoso Open Source edition (VOS) are available for
<link xlink:href="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VOSDownload">download</link>

   from
the VOS Wiki.</para>
          </section>
          <section xml:id="virtuosospongercatrbundledexample">
            <title>Example Source Code</title>
            <para>For developers wanting example cartridge code, the most authoritative reference is
the cartridges VAD source code itself. This is included as part of the VOS distribution. After
downloading and unpacking the sources, the script used to create the cartridges, and the associated
stylesheets can be found in:</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>&lt;vos root&gt;/binsrc/rdf_mappers/rdf_mappers.sql</para>
              </listitem>
              <listitem>
                <para>&lt;vos root&gt;/binsrc/rdf_mappers/xslt/*.xsl</para>
              </listitem>
            </itemizedlist>
            <para>Alternatively, you can look at the actual cartridge implementations installed in your
Virtuoso instance by inspecting the cartridge hook function used by a particular cartridge. This is
easily identified from the 'Cartridge name' field of Conductor's 'RDF Cartridges' screen, after
selecting the cartridge of interest. The hook function code can be viewed from the 'Schema Objects'
screen under the 'Database' menu, by locating the function in the 'DB' &gt; 'Procedures' folder.
Stylesheets used by the cartridges are installed in the WebDAV folder DAV/VAD/cartridges/xslt.
This can be explored using Conductor's WebDAV interface. The actual rdf_mappers.sql file installed
with your system can also be found in the DAV/VAD/cartridges folder.</para>
          </section>
        </section>
        <section xml:id="virtuosospongercatrbundledcusgtomcart">
          <title>Custom Cartridge</title>
          <para>Virtuoso comes well supplied with a variety of Sponger cartridges and GRDDL filters.
When then is it necessary to write your own cartridge?</para>
          <para>In the main, writing a new cartridge should only be necessary to generate RDF from
a REST-style Web service not supported by an existing cartridge, or to customize the output from
an existing cartridge to your own requirements. Apart from these circumstances, the existing
Sponger infrastructure should meet most of your needs. This is particularly the case for
document resources.</para>
          <section xml:id="virtuosospongerdocres">
            <title>Document Resources</title>
            <para>We use the term document resource to identify content which is not being returned
from a Web service. Normally it can broadly be conceived as some form of document, be it a text
based entity or some form of file, for instance an image file.</para>
            <para>In these cases, the document either contains RDF, which can be extracted directly,
or it holds metadata in a supported format which can be transformed to RDF using an existing
filter.</para>
            <para>The following cases should all be covered by the existing Sponger cartridges:</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>embedded or linked RDF</para>
              </listitem>
              <listitem>
                <para>RDFa, eRDF and other popular microformats extractable directly or via GRDDL</para>
              </listitem>
              <listitem>
                <para>popular syndication formats (RSS 2.0 , Atom, OPML , OCS , XBEL)</para>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="virtuosospongergrddl">
            <title>GRDDL</title>
            <para>GRDDL (Gleaning Resource Descriptions from Dialects of Languages) is mechanism for deriving
RDF data from XML documents and in particular XHTML pages. Document authors may associate transformation
algorithms, typically expressed in XSLT, with their documents to transform embedded metadata into RDF.</para>
            <para>The cartridges VAD installs a number of GRDDL filters for transforming popular microformats
(such as RDFa, eRDF or hCalendar) into RDF. The available filters can be viewed, or configured, in
Conductor's 'GRDDL Filters for XHTML' screen. Navigate to the 'RDF Cartridges' screen using the
'RDF' &gt; 'RDF Cartridges' menu items, then SELECT the 'GRDDL Mappings' tab to display the 'GRDDL Filters
for XHTML' screen. GRDDL filters are held in the WebDAV folder /DAV/VAD/rdf_cartridges/xslt/ alongside
other XSLT templates. The Conductor interface allows you to add new GRDDL filters should you so wish.</para>
            <para>For an introduction to GRDDL, try the <link xlink:href="http://www.w3.org/TR/grddl-primer/">GRDDL Primer</link>

  . To underline GRDDL's utility, the primer
includes an example of transforming Excel spreadsheet data, saved as XML, into RDF.</para>
            <para>A comprehensive <link xlink:href="http://esw.w3.org/topic/CustomRdfDialects">list of stylesheets</link>

for transforming HTML and non-HTML XML dialects is maintained
on the ESW Wiki. The list covers a range of microformats, syndication formats and feedlists.</para>
            <para>To see which Web Services are already catered for, view the list of cartridges in Conductor's 'RDF Cartridges' screen.</para>
          </section>
        </section>
        <section xml:id="virtuosospongercreatecustcartr">
          <title>Creating Custom Cartridges</title>
          <para>The Sponger is fully extensible by virtue of its pluggable cartridge architecture. New data formats can
be fetched by creating new cartridges. While OpenLink is active in adding cartridges for new data sources,
you are free to develop your own custom cartridges. Entity extractors can be built using Virtuoso PL,
C/C++, Java or any other external language supported by Virtuoso's Server Extension API. Of course,
Virtuoso's own entity extractors are written in Virtuoso PL.</para>
          <section xml:id="virtuosospongercreatecustcartran">
            <title>The Anatomy of a Cartridge</title>
            <para>
              <emphasis>Cartridge Hook Prototype</emphasis>
            </para>
            <para>Every Virtuoso PL hook function used to plug a custom Sponger cartridge into the Virtuoso
SPARQL engine must have a parameter list with the following parameters (the names of the parameters are
not important, but their order and presence are):</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  <emphasis>in graph_iri varchar</emphasis>
                </para>
                <para>: the IRI of the graph being retrieved/crawled</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>in new_origin_uri varchar</emphasis>
                </para>
                <para>: the URL of the document being retrieved</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>in dest varchar</emphasis>
                </para>
                <para>: the destination/target graph IRI</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>inout content any</emphasis>
                </para>
                <para>: the content of the retrieved document</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>inout async_queue any</emphasis>
                </para>
                <para>: if the PingService initialization parameter
has been configured in the [SPARQL] section of the virtuoso.ini file, this is a pre-allocated asynchronous
queue to be used to call the ping service</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>inout ping_service any</emphasis>
                </para>
                <para>: the URL of a ping service, as assigned
to the PingService parameter in the [SPARQL] section of the virtuoso.ini configuration file.
PingTheSemanticWeb is an 
                <link linkend="virtuosospongerefping">example</link>
                 of a such a service.</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>inout api_key any</emphasis>
                </para>
                <para>: a string value specific to a given cartridge,
contained in the RC_KEY column of the DB.DBA.SYS_RDF_CARTRIDGES table. The value can be a single
string or a serialized array of strings providing cartridge specific data.</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>inout opts any</emphasis>
                </para>
                <para>: cartridge specific options held in a Virtuoso/PL
vector which acts as an array of key-value pairs.</para>
              </listitem>
            </itemizedlist>
            <para>
              <emphasis>Return Value</emphasis>
            </para>
            <para>If the hook procedure returns zero the next cartridge will be tried. If the result is negative
the sponging process stops, instructing the SPARQL engine that nothing was retrieved. If the result is
positive the process stops, this time instructing the SPARQL engine
that RDF data was successfully retrieved.</para>
            <para>If your cartridge should need to test whether other cartridges are configured to handle a
particular data source, the following extract taken from the RDF_LOAD_CALAIS hook procedure illustrates
how you might do this:</para>
            <programlisting>
if (xd is not null)
{
  -- Sponging successful. Load network resource data being fetched in the Virtuoso Quad Store:
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
  flag := 1;
}

declare ord any;
ord := (SELECT RM_ID FROM DB.DBA.SYS_RDF_MAPPERS WHERE
	  RM_HOOK = 'DB.DBA.RDF_LOAD_CALAIS');
for SELECT RM_PATTERN FROM DB.DBA.SYS_RDF_MAPPERS WHERE
  RM_ID &gt; ord and RM_TYPE = 'URL' and RM_ENABLED = 1 ORDER BY RM_ID do
{
  if (regexp_match (RM_PATTERN, new_origin_uri) is not null)
    -- try next candidate cartridge
    flag := 0;
}
return flag;
</programlisting>
            <para>
              <emphasis>Specifying the Target Graph</emphasis>
            </para>
            <para>Two cartridge hook function parameters contain graph IRIs, graph_iri and dest. graph_iri
identifies an input graph being crawled. dest holds the IRI specified in any input:grab-destination
pragma defined to control the SPARQL processor's IRI dereferencing. The pragma overrides the default
behaviour and forces all retrieved triples to be stored in a single graph, irrespective of their graph
of origin.</para>
            <para>So, under some circumstances depending on how the Sponger has been invoked and whether
it is being used to crawl an existing RDF graph, or derive RDF data from a non-RDF data source,
dest may be null.</para>
            <para>Consequently, when loading network resource being fetched as RDF data into the quad store, cartridges typically
specify the graph to receive the data using the coalesce function which returns the first non-null
parameter. e.g.</para>
            <programlisting>
DB.DBA.RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
</programlisting>
            <para>Here xd is an RDF/XML string holding the fetched RDF.</para>
            <para>
              <emphasis>Specifying &amp; Retrieving Cartridge Specific Options</emphasis>
            </para>
            <para>The hook function prototype allows cartridge specific data to be passed to a cartridge
through the RM_OPTIONS parameter, a Virtuoso/PL vector which acts as a heterogeneous array.</para>
            <para>In the following example, two options are passed, 'add-html-meta' and 'get-feeds'
with both values set to 'no'.</para>
            <programlisting>
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_OPTIONS
)
values (
  '(text/html)|(text/xml)|(application/xml)|(application/rdf.xml)',
  'MIME', 'DB.DBA.RDF_LOAD_HTML_RESPONSE', null, 'xHTML',
  vector ('add-html-meta', 'no', 'get-feeds', 'no')
);
</programlisting>
            <para>The RM_OPTIONS vector can be handled as an array of key-value pairs using the
get_keyword function. get_keyword performs a case sensitive search for the given keyword at
every even index of the given array. It returns the element following the keyword, i.e.
the keyword value.</para>
            <para>Using get_keyword, any options passed to the cartridge can be retrieved
using an approach similar to that below:</para>
            <programlisting>
create procedure DB.DBA.RDF_LOAD_HTML_RESPONSE (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout ret_body any, inout aq any, inout ps any, inout _key any,
  inout opts any )
{
  declare get_feeds, add_html_meta;
  ...
  get_feeds := add_html_meta := 0;
  if (isarray (opts) and 0 = mod (length(opts), 2))
  {
    if (get_keyword ('get-feeds', opts) = 'yes')
      get_feeds := 1;
    if (get_keyword ('add-html-meta', opts) = 'yes')
      add_html_meta := 1;
  }
  ...
</programlisting>
            <para>
              <emphasis>XSLT - The Fulchrum</emphasis>
            </para>
            <para>XSLT is the fulchrum of all OpenLink supplied cartridges. It provides the most convenient
means of converting structured data extracted from web content by a cartridge's Entity Extractor into RDF.</para>
            <para>
              <emphasis>Virtuoso's XML Infrastructure &amp; Tools</emphasis>
            </para>
            <para>Virtuoso's XML support and XSLT support are covered in detail in the on-line documentation.
Virtuoso includes a highly capable XML parser and supports XPath, XQuery, XSLT and XML Schema validation.</para>
            <para>Virtuoso supports extraction of XML documents from SQL datasets. A SQL long varchar, long xml
or xmltype column in a database table can contain XML data as text or in a binary serialized format.
 A string representing a well-formed XML entity can be converted into an entity object representing
the root node.</para>
            <para>While Sponger cartridges will not normally concern themselves with handling XML extracted
from SQL data, the ability to convert a string into an in-memory XML document is used extensively.
The function xtree_doc(string) converts a string into such a document and returns a reference to the
document's root. This document together with an appropriate stylesheet forms the input for
the transformation of the extracted entities to RDF using XSLT. The input string to xtree_doc
generally contains structured content derived from a web service.</para>
            <para>
              <emphasis>Virtuoso XSLT Support</emphasis>
            </para>
            <para>Virtuoso implements XSLT 1.0 transformations as SQL callable functions. The xslt() Virtuoso/PL function
applies a given stylesheet to a given source XML document and returns the transformed document. Virtuoso
provides a way to extend the abilities of the XSLT processor by creating user defined XPath functions.
The functions xpf_extension() and xpf_extension_remove() allow addition and removal of XPath extension
functions.</para>
            <para>
              <emphasis>General Cartridge Pipeline</emphasis>
            </para>
            <para>The broad pipeline outlined here reflects the steps common to most cartridges:</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>Redirect from the requested URL to a Web service which returns XML</para>
              </listitem>
              <listitem>
                <para>Stream the content into an in-memory XML document</para>
              </listitem>
              <listitem>
                <para>Convert it to the required RDF/XML, expressed in the chosen ontology, using XSLT</para>
              </listitem>
              <listitem>
                <para>Encode the RDF/XML as UTF-8</para>
              </listitem>
              <listitem>
                <para>Load the RDF/XML into the quad store</para>
              </listitem>
            </itemizedlist>
            <para>The <link xlink:href="http://musicbrainz.org/">MusicBrainz</link>

   cartridge typifies this approach. MusicBrainz is a community music
metadatabase which captures information about artists, their recorded works, and the relationships
between them. Artists always have a unique ID, so the URL
http://musicbrainz.org/artist/4d5447d7-c61c-4120-ba1b-d7f471d385b9.html takes you directly to entries
for John Lennon.</para>
            <para>If you were to look at this page in your browser, you would see that the information about
the artist contains no RDF data. However, the cartridge is configured to intercept requests to URLs of
the form http://musicbrainz.org/([^/]*)/([^.]*) and redirect to the cartridge to Fetch all the
available information on the given artist, release, track or label.</para>
            <para>The cartridge extracts entities by redirecting to the MusicBrainz XML Web Service using
as the basis for the initial query the item ID, e.g. an artist or label ID, extracted from the original
URL. Stripped to its essentials, the core of the cartridge is:</para>
            <programlisting>
webservice_uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&amp;inc=%U',
					kind, id, inc);
content := RDF_HTTP_URL_GET (webservice_uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
...
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/mbz2rdf.xsl', xt);
...
xd := serialize_to_UTF8_xml (xd);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
</programlisting>
            <para>In the above outline, RDF_HTTP_URL_GET sends a query to the MusicBrainz web service,
using query parameters appropriate for the original request, and retrieves the response using
Network Resource Fetch.</para>
            <para>The returned XML is parsed into an in-memory parse tree by xtree_doc. Virtuoso/PL
function RDF_MAPPER_XSLT is a simple wrapper around the function xslt which sets the current user
to dba before returning an XML document transformed by an XSLT stylesheet, in this case mbz2rdf.xsl.
Function serialize_to_UTF8_xml changes the character set of the in-memory XML document to UTF8.
Finally, RM_RDF_LOAD_RDFXML is a wrapper around RDF_LOAD_RDFXML which parses the content of an
RDF/XML string into a sequence of RDF triples and loads them into the quad store. XSLT stylesheets
are usually held in the DAV/VAD/cartridges/xslt folder of Virtuoso's WebDAV store.
registry_get('cartridges_path') returns the Cartridges VAD path, 'DAV/VAD/cartridges', from the
Virtuoso registry.</para>
            <para>
              <emphasis>Error Handling with Exit Handlers</emphasis>
            </para>
            <para>Virtuoso condition handlers determine the behaviour of a Virtuoso/PL procedure when a
condition occurs. You can declare one or more condition handlers in a Virtuoso/PL procedure for
general SQL conditions or specific SQLSTATE values. If a statement in your procedure raises an
SQLEXCEPTION condition and you declared a handler for the specific SQLSTATE or SQLEXCEPTION
condition the server passes control to that handler. If a statement in your Virtuoso/PL procedure
raises an SQLEXCEPTION condition, and you have not declared a handler for the specific SQLSTATE
or the SQLEXCEPTION condition, the server passes the exception to the calling procedure (if any).
If the procedure call is at the top-level, then the exception is signaled to the calling client.</para>
            <para>A number of different condition handler types can be declared (see the <link xlink:href="http://docs.openlinksw.com/virtuoso/handlingplcondit.html">Virtuoso reference documentation</link>

for more details.) Of these, exit handlers are probably all you will need. An example is shown below
which handles any SQLSTATE. Commented out is a debug statement which outputs the message describing
the SQLSTATE.</para>
            <programlisting>
create procedure DB.DBA.RDF_LOAD_SOCIALGRAPH (in graph_iri varchar, ...)
{
  declare qr, path, hdr any;
  ...
  declare exit handler for sqlstate '*'
  {
    -- dbg_printf ('%s', __SQL_MESSAGE);
    return 0;
  };
  ...
  -- data extraction and mapping successful
  return 1;
}
</programlisting>
            <para>Exit handlers are used extensively in the Virtuoso supplied cartridges. They are useful
for ensuring graceful failure when trying to convert content which may not conform to your expectations.
The RDF_LOAD_FEED_SIOC procedure (which is used internally by several cartridges) shown below uses this
approach:</para>
            <programlisting>
-- /* convert the feed in rss 1.0 format to sioc */
create procedure DB.DBA.RDF_LOAD_FEED_SIOC (in content any, in iri varchar, in graph_iri varchar, in is_disc int := '')
{
  declare xt, xd any;
  declare exit handler for sqlstate '*'
    {
      goto no_sioc;
    };
  xt := xtree_doc (content);
  xd := DB.DBA.RDF_MAPPER_XSLT (
      registry_get ('_cartridges_path_') || 'xslt/feed2sioc.xsl', xt,
      vector ('base', graph_iri, 'isDiscussion', is_disc));
  xd := serialize_to_UTF8_xml (xd);
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, iri, graph_iri);
  return 1;
no_sioc:
  return 0;
}
</programlisting>
            <para>
              <emphasis>Loading RDF into the Quad Store</emphasis>
            </para>
            <para>
              <emphasis>RDF_LOAD_RDFXML &amp; TTLP</emphasis>
            </para>
            <para>The two main Virtuoso/PL functions used by the cartridges for loading RDF data into the
Virtuoso quad store are DB.DBA.TTLP and DB.DBA.RDF_LOAD_RDFXML. Multithreaded versions of these functions,
DB.DBA.TTLP_MT and DB.DBA.RDF_LOAD_RDFXML_MT, are also available.</para>
            <para>RDF_LOAD_RDFXML parses the content of an RDF/XML string as a sequence of RDF triples and
loads then into the quad store. TTLP parses TTL (Turtle or N3) and places its triples into quad
storage. Ordinarily, cartridges use RDF_LOAD_RDFXML. However there may be occasions where you want
to insert statements written as TTL, rather than RDF/XML, in which case you should use TTLP.</para>
            <tip>
              <title>See Also:</title>
              <itemizedlist mark="bullet">
                <listitem>
                  <para>
                    <link linkend="rdfinsertmethodsapifunct">Loading RDF using API functions</link>
                  </para>
                </listitem>
              </itemizedlist>
            </tip>
            <para>
              <emphasis>Attribution</emphasis>
            </para>
            <para>Many of the OpenLink supplied cartridges actually use RM_RDF_LOAD_RDFXML to load data
into the quad store. This is a thin wrapper around RDF_LOAD_RDFXML which includes in the generated
graph an indication of the external ontologies being used. The attribution takes the form:</para>
            <programlisting>
&lt;ontologyURI&gt; a opl:DataSource .
&lt;spongedResourceURI&gt; rdfs:isDefinedBy &lt;ontologyURI&gt; .
&lt;ontologyURI&gt; opl:hasNamespacePrefix "&lt;ontologyPrefix&gt;" .
</programlisting>
            <para>where prefix opl: denotes the ontology http://www.openlinksw.com/schema/attribution#.</para>
            <para>
              <emphasis>Deleting Existing Graphs</emphasis>
            </para>
            <para>Before loading network resource fetched RDF data into a graph, you may want to delete any existing graph
with the same URI. To do so, select the 'RDF' &gt; 'List of Graphs' menu commands in Conductor, then use
the 'Delete' command for the appropriate graph. Alternatively, you can use one of the following SQL
commands:</para>
            <programlisting>
SPARQL CLEAR GRAPH
-- or
DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_iri)
</programlisting>
            <para>
              <emphasis>Proxy Service Data Expiration</emphasis>
            </para>
            <para>When the Proxy Service is invoked by a user agent, the Sponger records the expiry date
of the imported data in the table DB.DBA.SYS_HTTP_SPONGE. The data invalidation rules conform to those
of traditional HTTP clients (Web browsers). The data expiration time is determined based on subsequent
data fetches of the same resource. The first data retrieval records the 'expires' header. On subsequent
fetches, the current time is compared to the expiration time stored in the local cache. If HTTP 'expires'
header data isn't returned by the source data server, the Sponger will derive its own expiration time by
evaluating the 'date' header and 'last-modified' HTTP headers.</para>
          </section>
          <section xml:id="virtuosospongercreatecustcartrontolg">
            <title>Ontology Mapping</title>
            <para>After extracting entities from a web resource and converting them to an in-memory XML
document, the entities must be transformed to the target ontology using XSLT and an appropriate stylesheet.
A typical call sequence would be:</para>
            <programlisting>
xt := xtree_doc (content);
...
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/mbz2rdf.xsl', xt);
</programlisting>
            <para>Because of the wide variation in the data mapped by cartridges, it is not possible to present
a typical XSL stylesheet outline. The Examples section presented later includes detailed extracts from the
MusicBrainz? cartridge's stylesheet which provide a good example of how to map to an ontology. Rather than
attempting to be an XSLT tutorial, the material which follows offers some general guidelines.</para>
            <para>
              <emphasis>Passing Parameters to the XSLT Processor</emphasis>
            </para>
            <para>Virtuoso's XSLT processor will accept default values for global parameters from the optional
third argument of the xslt() function. This argument, if specified, must be a vector of parameter names
and values of the form vector(name1, value1,... nameN, valueN), where name1 ... nameN must be of type
varchar, and value1 ... valueN may be of any Virtuoso datatype, but may not be null.</para>
            <para>This extract from the Crunchbase cartridge shows how parameters may be passed to the XSLT
processor. The function RDF_MAPPER_XSLT (in xslt varchar, inout xt any, in params any := null) passes
the parameters vector directly to xslt().</para>
            <programlisting>
xt := DB.DBA.RDF_MAPPER_XSLT (
registry_get ('_cartridges_path_') || 'xslt/crunchbase2rdf.xsl', xt,
vector ('baseUri', coalesce (dest, graph_iri), 'base', base, 'suffix', suffix)
);
</programlisting>
            <para>The corresponding stylesheet crunchbase2rdf.xsl retrieves the parameters baseUri, base and suffix as follows:</para>
            <programlisting>
...
&lt;xsl:output method="xml" indent="yes" /&gt;
  &lt;xsl:variable name="ns"&gt;http://www.crunchbase.com/&lt;/xsl:variable&gt;
  &lt;xsl:param name="baseUri" /&gt;
  &lt;xsl:param name="base"/&gt;
  &lt;xsl:param name="suffix"/&gt;

  &lt;xsl:template name="space-name"&gt;
...
</programlisting>
            <para>
              <emphasis>An RDF Description Template</emphasis>
            </para>
            <para>
              <emphasis>Defining A Generic Resource Description Wrapper</emphasis>
            </para>
            <para>Many of the OpenLink cartridges create a resource description formed to a common "wrapper"
template which describes the relationship between the (usually) non-RDF source network resource being fetched
and the RDF description generated by the Sponger. The wrapper is appropriate for resources which can
broadly be conceived as documents. It provides a generic minimal description of the source document,
but also links to the much more detailed description provided by the Sponger. So, instead of just
emitting a resource description, the Sponger factors the container into the generated graph constituting
the RDF description.</para>
            <para>The template is depicted below:</para>
            <figure xml:id="spong3" floatstyle="1">
              <title>Template</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="ui/spong3.png"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>To generate an RDF description corresponding to the wrapper template, a stylesheet containing
the following block of instructions is used. This extract is taken from the eBay cartridge's stylesheet,
ebay2rdf.xsl. Many of the OpenLink cartridges follow a similar pattern.</para>
            <programlisting>
    &lt;xsl:param name="baseUri"/&gt;
    ...
    &lt;xsl:variable name="resourceURL"&gt;
	&lt;xsl:value-of select="$baseUri"/&gt;
    &lt;/xsl:variable&gt;
    ...

  &lt;xsl:template match="/"&gt;
	&lt;rdf:RDF&gt;
	    &lt;rdf:Description rdf:about="{$resourceURL}"&gt;
		&lt;rdf:type rdf:resource="Document"/&gt;
		&lt;rdf:type rdf:resource="Document"/&gt;
		&lt;rdf:type rdf:resource="Container"/&gt;
		&lt;sioc:container_of rdf:resource="{vi:proxyIRI ($resourceURL)}"/&gt;
		&lt;foaf:primaryTopic rdf:resource="{vi:proxyIRI ($resourceURL)}"/&gt;
		&lt;dcterms:subject rdf:resource="{vi:proxyIRI ($resourceURL)}"/&gt;
	    &lt;/rdf:Description&gt;
	    &lt;rdf:Description rdf:about="{vi:proxyIRI ($resourceURL)}"&gt;
		&lt;rdf:type rdf:resource="Item"/&gt;
		&lt;sioc:has_container rdf:resource="{$resourceURL}"/&gt;
		&lt;xsl:apply-templates/&gt;
	    &lt;/rdf:Description&gt;
	&lt;/rdf:RDF&gt;
    &lt;/xsl:template&gt;
    ...
</programlisting>
            <para>
              <emphasis>Using SIOC as a Generic Container Model</emphasis>
            </para>
            <para>The generic resource description wrapper just described uses SIOC to establish the
container/contained relationship between the source resource and the generated graph. Although the most
important classes for the generic wrapper are obviously Container and Item, SIOC provides a generic data
model of containers, items, item types, and associations between items which can be combined with other
 vocabularies such as FOAF and Dublin Core.</para>
            <para>SIOC defines a number of other classes, such as User, UserGroup, Role, Site, Forum and
Post. A separate SIOC types module (T-SIOC) extends the SIOC Core ontology by defining subclasses and
subproperties of SIOC terms. Subclasses include: AddressBook, BookmarkFolder, Briefcase, EventCalendar,
ImageGallery, Wiki, Weblog, BlogPost, Wiki plus many others.</para>
            <para>OpenLink Data Spaces (ODS) uses SIOC extensively as a data space "glue" ontology to
describe the base data and containment hierarchy of all the items managed by ODS applications
(Data Spaces). For example, ODS-Weblog is an application of type sioc:Forum. Each ODS-Weblog
application instance contains blogs of type sioct:Weblog. Each blog is a sioc:container_of posts
of type sioc:Post.</para>
            <para>Generally, when deciding how to describe resources handled by your own custom cartridge,
SIOC provides a useful framework for the description which complements the SIOC-based container model
adopted throughout the ODS framework.</para>
            <para>
              <emphasis>Naming Conventions for Sponger Generated Descriptions</emphasis>
            </para>
            <para>As can be seen from the stylesheet extract just shown, the URI of the resource
description generated by the Sponger to describe the network resource being fetched, is given by the
function {vi:proxyIRI ($resourceURL)} where resourceURL is the URL of the original network resource
being fetched. proxyIRI is an XPath extension function defined in rdf_mappers.sql as</para>
            <programlisting>
xpf_extension ('http://www.openlinksw.com/virtuoso/xslt/:proxyIRI', 'DB.DBA.RDF_SPONGE_PROXY_IRI');
</programlisting>
            <para>which maps to the Virtuoso/PL procedure DB.DBA.RDF_SPONGE_PROXY_IRI. This procedure in
turn generates a resource description URI which typically takes the form:
http://&lt;hostName:port&gt;/about/html/http/&lt;resourceURL&gt;#this</para>
          </section>
          <section xml:id="virtuosospongercreatecustcartrrgst">
            <title>Registering &amp; Configuring Cartridges</title>
            <para>Once you have developed a cartridge, you must register it in the Cartridge Registry
to have the SPARQL processor recognize and use it. You should have compiled your cartridge hook
function first by issuing a "create procedure DB.DBA.RDF_LOAD_xxx ..." command through one of
Virtuoso's SQL interfaces. You can create the required Cartridge Registry entry either by adding
a row to the SYS_REF_MAPPERS table directly using SQL, or by using the Conductor UI.</para>
            <section xml:id="virtuosospongercreatecustcartrrgstis">
              <title>Using SQLs</title>
              <para>If you choose register your cartridge using SQL, possibly as part of a Virtuoso/PL
script, the required SQL will typically mirror one of the following INSERT commands.</para>
              <para>Below, a cartridge for OpenCalais is being installed which will be tried when
the MIME type of the network resource data being fetched is one of text/plain, text/xml or text/html.
(The definition of the SYS_RDF_MAPPERS table was introduced earlier in section
'Cartridge Registry'.)</para>
              <programlisting>
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_ENABLED)
values (
  '(text/plain)|(text/xml)|(text/html)', 'MIME', 'DB.DBA.RDF_LOAD_CALAIS',
  null, 'Opencalais', 1);
</programlisting>
              <para>As an alternative to matching on the content's MIME type,
candidate cartridges to be tried in the conversion pipeline can be identified by matching the
data source URL against a URL pattern stored in the cartridge's entry in the Cartridge Registry.</para>
              <programlisting>
insert soft DB.DBA.SYS_RDF_MAPPERS (
  RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION, RM_OPTIONS)
values (
  '(http://api.crunchbase.com/v/1/.*)|(http://www.crunchbase.com/.*)', 'URL',
  'DB.DBA.RDF_LOAD_CRUNCHBASE', null, 'CrunchBase', null);
</programlisting>
              <para>The value of RM_ID to set depends on where in the cartridge invocation order you want
to position a particular cartridge. RM_ID should be set lower than 10028 to ensure the cartridge
is tried before the ODS-Briefcase (WebDAV) metadata extractor, which is always the last mapper to
be tried if no preceding cartridge has been successful.</para>
              <programlisting>
UPDATE DB.DBA.SYS_RDF_MAPPERS
SET RM_ID = 1000
WHERE RM_HOOK = 'DB.DBA.RDF_LOAD_BIN_DOCUMENT';
</programlisting>
            </section>
            <section xml:id="virtuosospongercreatecustcartrrgstcn">
              <title>Using Conductor</title>
              <para>Cartridges can be added manually using the 'Add' panel of the 'RDF Cartridges' screen.</para>
              <figure xml:id="spong4" floatstyle="1">
                <title>RDF Cartridges</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="ui/spong4.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
            </section>
            <section xml:id="virtuosospongercreatecustcartrrgstit">
              <title>Installing Stylesheets</title>
              <para>Although you could place your cartridge stylesheet in any folder configured to be accessible
by Virtuoso, the simplest option is to upload them to the DAV/VAD/cartridges/xslt folder using the
WebDAV browser accessible from the Conductor UI.</para>
              <figure xml:id="spong6" floatstyle="1">
                <title>WebDAV browser</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="ui/spong6.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <para>Should you wish to locate your stylesheets elsewhere, ensure
that the DirsAllowed setting in the virtuoso.ini file is configured appropriately.</para>
            </section>
            <section xml:id="virtuosospongercreatecustcartrrgstap">
              <title>Setting API Key</title>
              <para>Some Cartridges require and API account and/or API Key to be
provided for accessing the required service. This can be done from the Linked Data -&gt; Sponger tab of the
Conductor by selecting the cartridge from the list provided, entering the API Account and API Key
in the dialog at the bottom of the page and click update to save, as indicated in the screenshot
below:</para>
              <figure xml:id="catr1" floatstyle="1">
                <title>Registering API Key</title>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="ui/cartrapikey.png"/>
                  </imageobject>
                </mediaobject>
              </figure>
              <para>For example, for the service Flickr developers must register
to obtain a key. See http://developer.yahoo.com/flickr/. In order
to cater for services which require an application key, the Cartridge Registry
SYS_RDF_MAPPERS table includes an RM_KEY column to store any key required for a
particular service. This value is passed to the service's cartridge through the
_key parameter of the cartridge hook function.</para>
              <para>Alternatively a cartridge can store a key value in the virtuoso.ini
configuration file and retrieve it in the hook function.</para>
            </section>
            <section xml:id="virtuosospongercreatecustcartrrgstflickr">
              <title>Flickr Cartridge</title>
              <para>This example shows an extract from the Flickr cartridge hook function
DB.DBA.RDF_LOAD_FLICKR_IMG and the use of an API key. Also, commented out, is a call to
cfg_item_value() which illustrates how the API key could instead be stored and retrieved
from the SPARQL section of the virtuoso.ini file.
         </para>
              <programlisting>
create procedure DB.DBA.RDF_LOAD_FLICKR_IMG (
in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
inout _ret_body any, inout aq any, inout ps any, inout _key any,
inout opts any )
{
declare xd, xt, url, tmp, api_key, img_id, hdr, exif any;
declare exit handler for sqlstate '*'
{
 return 0;
};
tmp := sprintf_inverse (new_origin_uri,
  'http://farm%s.static.flickr.com/%s/%s_%s.%s', 0);
img_id := tmp[2];
api_key := _key;
--cfg_item_value (virtuoso_ini_path (), 'SPARQL', 'FlickrAPIkey');
if (tmp is null or length (tmp) &lt;&gt; 5 or not isstring (api_key))
  return 0;
url :=  sprintf('http://api.flickr.com/services/rest/?method=flickr.photos.getInfo&amp;photo_id=%s&amp;api_key=%s',img_id, api_key);
tmp := http_get (url, hdr);
</programlisting>
            </section>
          </section>
          <section xml:id="virtuosospongercreatecustcartrexmp">
            <title>MusicBrainz Example: A Music Metadatabase</title>
            <para>To illustrate some of the material presented so far, we'll delve
deeper into the <link xlink:href="http://musicbrainz.org/">MusicBrainz</link>

   cartridge mentioned earlier.</para>
            <para>
              <emphasis>MusicBrainz XML Web Service</emphasis>
            </para>
            <para>The cartridge extracts data through the <link xlink:href="http://musicbrainz.org/doc/XMLWebService">MusicBrainz XML Web Service</link>

   using, as the basis
for the initial query, an item type and MBID (MusicBrainz ID) extracted from the original URI submitted
to the RDF proxy. A range of item types are supported including artist, release and track.</para>
            <para>Using the album "Imagine" by John Lennon as an example, a standard HTML description of
the album (which has an MBID of f237e6a0-4b0e-4722-8172-66f4930198bc) can be retrieved direct from
MusicBrainz using the URL:</para>
            <programlisting>
http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html
</programlisting>
            <para>Alternatively, information can be extracted in XML form through the web service.
A description of the tracks on the album can be obtained with the query:</para>
            <programlisting>
http://musicbrainz.org/ws/1/release/f237e6a0-4b0e-4722-8172-66f4930198bc?type=xml&amp;inc=tracks
</programlisting>
            <para>The XML returned by the web service is shown below (only the first two tracks
are shown for brevity):</para>
            <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;metadata xmlns="http://musicbrainz.org/ns/mmd-1.0#"
   xmlns:ext="http://musicbrainz.org/ns/ext-1.0#"&gt;
    &lt;release
xml:id="f237e6a0-4b0e-4722-8172-66f4930198bc" type="Album Official" &gt;
      &lt;title&gt;Imagine&lt;/title&gt;
        &lt;text-representation language="ENG" script="Latn"/&gt;
        &lt;asin&gt;B0000457L2&lt;/asin&gt;
        &lt;track-list&gt;
          &lt;track
xml:id="b88bdafd-e675-4c6a-9681-5ea85ab99446"&gt;
            &lt;title&gt;Imagine&lt;/title&gt;
            &lt;duration&gt;182933&lt;/duration&gt;
          &lt;/track&gt;
          &lt;track
xml:id="b38ce90d-3c47-4ccd-bea2-4718c4d34b0d"&gt;
            &lt;title&gt;Crippled Inside&lt;/title&gt;
            &lt;duration&gt;227906&lt;/duration&gt;
          &lt;/track&gt;
	  . . .
        &lt;/track-list&gt;
      &lt;/release&gt;
  &lt;/metadata&gt;
</programlisting>
            <para>Although, as shown above, MusicBrainz defines its own <link xlink:href="http://musicbrainz.org/doc/MusicBrainzXMLMetaData">XML Metadata Format</link>

   to represent
music metadata, the MusicBrainz sponger converts the raw data to a subset of the <link xlink:href="http://musicontology.com/">Music Ontology</link>

  ,
an RDF vocabulary which aims to provide a set of core classes and properties for describing music
on the Semantic Web. Part of the subset used is depicted in the following RDF graph (representing
in this case a John Cale album).</para>
            <figure xml:id="spong7" floatstyle="1">
              <title>RDF graph</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="ui/spong7.png"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>With the prefix mo: denoting the Music Ontology at http://purl.org/ontology/mo/, it can be
seen that artists are represented by instances of class mo:Artist, their albums, records etc. by instances
of class mo:Release and tracks on these releases by class mo:Track. The property foaf:made links an
artist and his/her releases. Property mo:track links a release with the tracks it contains</para>
            <para>
              <emphasis>RDF Output</emphasis>
            </para>
            <para>An RDF description of the album can be obtained by sponging the same URL, i.e. by submitting it to the Sponger's proxy interface using the URL:</para>
            <programlisting>
http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html
</programlisting>
            <para>The extract below shows part of the (reorganized) RDF output returned by the Sponger
for "Imagine". Only the album's title track is included.</para>
            <programlisting>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
 xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"&gt;

&lt;rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html"&gt;
  &lt;rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Document"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html"&gt;
  &lt;foaf:primaryTopic xmlns:foaf="http://xmlns.com/foaf/0.1/"
   rdf:resource="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:about="http://purl.org/ontology/mo/"&gt;
  &lt;rdf:type rdf:resource="http://www.openlinksw.com/schema/attribution#DataSource"/&gt;
&lt;/rdf:Description&gt;
...
&lt;rdf:Description
 rdf:about="http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html"&gt;
  &lt;rdfs:isDefinedBy rdf:resource="http://purl.org/ontology/mo/"/&gt;

&lt;/rdf:Description&gt;
...

&lt;!-- Record description --&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"&gt;
  &lt;rdf:type rdf:resource="http://purl.org/ontology/mo/Record"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"&gt;
  &lt;dc:title xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;Imagine&lt;/dc:title&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"&gt;
  &lt;mo:release_status xmlns:mo="http://purl.org/ontology/mo/" rdf:resource="http://purl.org/ontology/mo/official"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"&gt;
  &lt;mo:release_type xmlns:mo="http://purl.org/ontology/mo/"
   rdf:resource="http://purl.org/ontology/mo/album"/&gt;
&lt;/rdf:Description&gt;

&lt;!-- Title track description --&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/release/f237e6a0-4b0e-4722-8172-66f4930198bc.html#this"&gt;
  &lt;mo:track xmlns:mo="http://purl.org/ontology/mo/"
   rdf:resource="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"/&gt;
&lt;/rdf:Description&gt;
&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"&gt;
  &lt;rdf:type rdf:resource="http://purl.org/ontology/mo/Track"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"&gt;
  &lt;dc:title xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;Imagine&lt;/dc:title&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"&gt;
  &lt;mo:track_number xmlns:mo="http://purl.org/ontology/mo/"&gt;1&lt;/mo:track_number&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description
 rdf:about="http://demo.openlinksw.com/about/rdf/http://musicbrainz.org/track/b88bdafd-e675-4c6a-9681-5ea85ab99446.html#this"&gt;
  &lt;mo:duration xmlns:mo="http://purl.org/ontology/mo/" rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;182933&lt;/mo:duration&gt;
&lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</programlisting>
            <para>
              <emphasis>Cartridge Hook Function</emphasis>
            </para>
            <para>The cartridge's hook function is listed below. It is important to note that MusicBrainz
 supports a variety of query types, each of which returns a different set of information, depending
on the item type being queried. Full details can be found on the MusicBrainz? site. The sponger
cartridge is capable of handling all the query types supported by MusicBrainz? and is intended to
be used in a drill-down scenario, as would be the case when using an RDF browser such as the
<link xlink:href="http://ode.openlinksw.com/">OpenLink Data Explorer (ODE)</link>

  . This example focuses primarily on the types release and track.</para>
            <programlisting>
create procedure DB.DBA.RDF_LOAD_MBZ (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout _ret_body any, inout aq any, inout ps any, inout _key any,
  inout opts any)
{
  declare kind, id varchar;
  declare tmp, incs any;
  declare uri, cnt, hdr, inc, xd, xt varchar;
  tmp := regexp_parse ('http://musicbrainz.org/([^/]*)/([^\.]+)', new_origin_uri, 0);
  declare exit handler for sqlstate '*'
  {
    -- dbg_printf ('%s', __SQL_MESSAGE);
    return 0;
  };
  if (length (tmp) &lt; 6)
    return 0;

  kind := subseq (new_origin_uri, tmp[2], tmp[3]);
  id :=   subseq (new_origin_uri, tmp[4], tmp[5]);
  incs := vector ();
  if (kind = 'artist')
    {
      inc := 'aliases artist-rels label-rels release-rels track-rels url-rels';
      incs :=
      	vector (
	'sa-Album', 'sa-Single', 'sa-EP', 'sa-Compilation', 'sa-Soundtrack',
	'sa-Spokenword', 'sa-Interview', 'sa-Audiobook', 'sa-Live', 'sa-Remix', 'sa-Other'
	, 'va-Album', 'va-Single', 'va-EP', 'va-Compilation', 'va-Soundtrack',

	'va-Spokenword', 'va-Interview', 'va-Audiobook', 'va-Live', 'va-Remix', 'va-Other'
	);
    }
  else if (kind = 'release')
    inc := 'artist counts release-events discs tracks artist-rels label-rels release-rels track-rels url-rels track-level-rels labels';
  else if (kind = 'track')
    inc := 'artist releases puids artist-rels label-rels release-rels track-rels url-rels';
  else if (kind = 'label')
    inc := 'aliases artist-rels label-rels release-rels track-rels url-rels';
  else
    return 0;
  if (dest is null)
    DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_iri);
  DB.DBA.RDF_LOAD_MBZ_1 (graph_iri, new_origin_uri, dest, kind, id, inc);
  DB.DBA.TTLP (sprintf ('&lt;%S&gt; &lt;http://xmlns.com/foaf/0.1/primaryTopic&gt; &lt;%S&gt; .\n&lt;%S&gt; a &lt;http://xmlns.com/foaf/0.1/Document&gt; .',
  	new_origin_uri, DB.DBA.RDF_SPONGE_PROXY_IRI (new_origin_uri), new_origin_uri),
  	'', graph_iri);
  foreach (any inc1 in incs) do
    {
      DB.DBA.RDF_LOAD_MBZ_1 (graph_iri, new_origin_uri, dest, kind, id, inc1);
    }
  return 1;
};
</programlisting>
            <para>The hook function uses a subordinate procedure RDF_LOAD_MBZ_1:</para>
            <programlisting>
create procedure DB.DBA.RDF_LOAD_MBZ_1 (in graph_iri varchar, in new_origin_uri varchar,
   in dest varchar, in kind varchar, in id varchar, in inc varchar)
{
  declare uri, cnt, xt, xd, hdr any;
  uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&amp;inc=%U', kind, id, inc);
  cnt := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
  xt := xtree_doc (cnt);
  xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/mbz2rdf.xsl', xt,
        vector ('baseUri', new_origin_uri));
  xd := serialize_to_UTF8_xml (xd);
  DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
};
</programlisting>
            <para>
              <emphasis>XSLT Stylesheet</emphasis>
            </para>
            <para>The key sections of the MusicBrainz XSLT template relevant to this example are
listed below. Only the sections relating to an artist, his releases, or the tracks on those
releases, are shown.</para>
            <programlisting>
&lt;!DOCTYPE xsl:stylesheet [
&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;
&lt;!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
&lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#"&gt;
&lt;!ENTITY mo "http://purl.org/ontology/mo/"&gt;
&lt;!ENTITY foaf "http://xmlns.com/foaf/0.1/"&gt;
&lt;!ENTITY mmd "http://musicbrainz.org/ns/mmd-1.0#"&gt;
&lt;!ENTITY dc "http://purl.org/dc/elements/1.1/"&gt;
]&gt;

&lt;xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf=""
    xmlns:rdfs=""
    xmlns:foaf=""
    xmlns:mo=""
    xmlns:mmd=""
    xmlns:dc=""
    &gt;

    &lt;xsl:output method="xml" indent="yes" /&gt;
    &lt;xsl:variable name="base" select="'http://musicbrainz.org/'"/&gt;
    &lt;xsl:variable name="uc"&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/xsl:variable&gt;
    &lt;xsl:variable name="lc"&gt;abcdefghijklmnopqrstuvwxyz&lt;/xsl:variable&gt;

  &lt;xsl:template match="/mmd:metadata"&gt;
	&lt;rdf:RDF&gt;
	    &lt;xsl:apply-templates /&gt;
	&lt;/rdf:RDF&gt;
    &lt;/xsl:template&gt;

    ...

  &lt;xsl:template match="mmd:artist[@type='Person']"&gt;
	&lt;mo:MusicArtist rdf:about="{vi:proxyIRI (concat($base,'artist/',@id,'.html'))}"&gt;
	    &lt;foaf:name&gt;&lt;xsl:value-of select="mmd:name"/&gt;&lt;/foaf:name&gt;
	    &lt;xsl:for-each select="mmd:release-list/mmd:release|mmd:relation-list[@target-type='Release']/mmd:relation/mmd:release"&gt;
		&lt;foaf:made rdf:resource="{vi:proxyIRI (concat($base,'release/',@id,'.html'))}"/&gt;
	    &lt;/xsl:for-each&gt;
	&lt;/mo:MusicArtist&gt;
	&lt;xsl:apply-templates /&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="mmd:release"&gt;
	&lt;mo:Record rdf:about="{vi:proxyIRI (concat($base,'release/',@id,'.html'))}"&gt;
	    &lt;dc:title&gt;&lt;xsl:value-of select="mmd:title"/&gt;&lt;/dc:title&gt;
	    &lt;mo:release_type rdf:resource="{translate (substring-before (@type, ' '),
                                                          $uc, $lc)}"/&gt;
	    &lt;mo:release_status rdf:resource="{translate (substring-after (@type, ' '), $uc,
                                                  $lc)}"/&gt;
	    &lt;xsl:for-each select="mmd:track-list/mmd:track"&gt;
		&lt;mo:track rdf:resource="{vi:proxyIRI (concat($base,'track/',@id,'.html'))}"/&gt;

	    &lt;/xsl:for-each&gt;
	&lt;/mo:Record&gt;
	&lt;xsl:apply-templates select="mmd:track-list/mmd:track"/&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="mmd:track"&gt;
	&lt;mo:Track rdf:about="{vi:proxyIRI (concat($base,'track/',@id,'.html'))}"&gt;
	    &lt;dc:title&gt;&lt;xsl:value-of select="mmd:title"/&gt;&lt;/dc:title&gt;
	    &lt;mo:track_number&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/mo:track_number&gt;
	    &lt;mo:duration rdf:datatype="integer"&gt;
             &lt;xsl:value-of select="mmd:duration"/&gt;
           &lt;/mo:duration&gt;
	    &lt;xsl:if test="artist[@id]"&gt;
		&lt;foaf:maker rdf:resource="{vi:proxyIRI (concat ($base, 'artist/',
                                          artist/@id, '.html'))}"/&gt;
	    &lt;/xsl:if&gt;
	    &lt;mo:musicbrainz rdf:resource="{vi:proxyIRI (concat ($base, 'track/', @id, '.html'))}"/&gt;
	&lt;/mo:Track&gt;
    &lt;/xsl:template&gt;

    ...

  &lt;xsl:template match="text()"/&gt;
&lt;/xsl:stylesheet&gt;
</programlisting>
          </section>
          <section xml:id="virtuosospongercreatecartentextmapcont">
            <title>Entity Extractor &amp; Mapper Component</title>
            <para>
Used to extract RDF from a Web Data Source the Virtuoso Sponger Cartridge RDF Extractor consumes services from: Virtuoso PL, C/C++, Java
based RDF Extractors</para>
            <para>The RDF mappers provide a way to extract metadata from non-RDF documents such as HTML pages,
images Office documents etc. and pass to SPARQL sponger (crawler which retrieve missing
source graphs). For brevity further in this article the "RDF mapper" we simply will call "mapper".
</para>
            <para>The mappers consist of PL procedure (hook) and extractor, where extractor itself can be built
using PL, C or any external language supported by Virtuoso server.</para>
            <para>Once the mapper is developed it must be plugged into the SPARQL engine by adding a record
in the table DB.DBA.SYS_RDF_MAPPERS.</para>
            <para>If a SPARQL query instructs the SPARQL processor to retrieve target graph into local storage,
then the SPARQL sponger will be invoked. If the target graph IRI represents a dereferenceable URL
then content will be retrieved using content negotiation. The next step is the content type
to be detected:</para>
            <itemizedlist>
              <listitem>
                <para>If RDF and no further transformation such as GRDDL is needed, then the process would stop.</para>
              </listitem>
              <listitem>
                <para>If such as 'text/plain' and is not known to have metadata, then the SPARQL sponger will
look in the DB.DBA.SYS_RDF_MAPPERS table by order of RM_ID and for every matching URL or MIME
type pattern (depends on column RM_TYPE) will call the mapper hook.

</para>
                <itemizedlist>
                  <listitem>
                    <para>If hook returns zero the next mapper will be tried;
</para>
                  </listitem>
                  <listitem>
                    <para>If result is negative the process would stop instructing the SPARQL nothing was retrieved;
</para>
                  </listitem>
                  <listitem>
                    <para>If result is positive the process would stop instructing the SPARQL that metadata was retrieved.
</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
            <section xml:id="virtuosospongercartridgesextractorpl">
              <title>Virtuoso/PL based Extractors</title>
              <para>
                <emphasis>PL hook requirements:</emphasis>
              </para>
              <para>Every PL function used to plug a mapper into SPARQL engine must have following parameters in
the same order:</para>
              <itemizedlist>
                <listitem>
                  <para>in graph_iri varchar: the graph IRI which is currently retrieved</para>
                </listitem>
                <listitem>
                  <para>in new_origin_uri varchar: the URL of the document retrieved</para>
                </listitem>
                <listitem>
                  <para>in destination varchar: the destination graph IRI</para>
                </listitem>
                <listitem>
                  <para>inout content any: the content of the document retrieved by SPARQL sponger </para>
                </listitem>
                <listitem>
                  <para>inout async_queue any: an asynchronous queue, can be used to push something to execute
on background if needed.</para>
                </listitem>
                <listitem>
                  <para>inout ping_service any: the value of [SPARQL] - PingService INI parameter, could be used
to configure a service notification such as pingthesemanticweb.com</para>
                </listitem>
                <listitem>
                  <para>inout api_key any: a plain text id single key value or serialized vector of key structure,
basically the value of RM_KEY column of the DB.DBA.SYS_RDF_MAPPERS table.</para>
                </listitem>
              </itemizedlist>
              <para>Note: the names of the parameters are not important, but their order and presence are!</para>
              <para>
                <emphasis>Example Implementation:</emphasis>
              </para>
              <para>In the example script below we implement a basic mapper, which maps a text/plain mime type to an
imaginary ontology, which extends the class Document from FOAF with properties 'txt:UniqueWords'
and 'txt:Chars', where the prefix 'txt:' we specify as 'urn:txt:v0.0:'.</para>
              <programlisting>
use DB;

create procedure DB.DBA.RDF_LOAD_TXT_META
 (
  in graph_iri varchar,
  in new_origin_uri varchar,
  in dest varchar,
  inout ret_body any,
  inout aq any,
  inout ps any,
  inout ser_key any
  )
{
  declare words, chars int;
  declare vtb, arr, subj, ses, str any;
  declare ses any;
  -- if any error we just say nothing can be done
  declare exit handler for sqlstate '*'
    {
      return 0;
    };
  subj := coalesce (dest, new_origin_uri);
  vtb := vt_batch ();
  chars := length (ret_body);

  -- using the text index procedures we get a list of words
  vt_batch_feed (vtb, ret_body, 1);
  arr := vt_batch_strings_array (vtb);

  -- the list has 'word' and positions array, so we must divide by 2
  words := length (arr) / 2;
  ses := string_output ();

  -- we compose a N3 literal
  http (sprintf ('&lt;%s&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Document&gt; .\n', subj), ses);
  http (sprintf ('&lt;%s&gt; &lt;urn:txt:v0.0:UniqueWords&gt; "%d" .\n', subj, words), ses);
  http (sprintf ('&lt;%s&gt; &lt;urn:txt:v0.0:Chars&gt; "%d" .\n', subj, chars), ses);
  str := string_output_string (ses);

  -- we push the N3 text into the local store
  DB.DBA.TTLP (str, new_origin_uri, subj);
  return 1;
};

DELETE FROM DB.DBA.SYS_RDF_MAPPERS WHERE RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';

INSERT SOFT DB.DBA.SYS_RDF_MAPPERS (RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION)
VALUES ('(text/plain)', 'MIME', 'DB.DBA.RDF_LOAD_TXT_META', null, 'Text Files (demo)');

-- here we set order to some large number so don't break existing mappers
update DB.DBA.SYS_RDF_MAPPERS
SET RM_ID = 2000
WHERE RM_HOOK = 'DB.DBA.RDF_LOAD_TXT_META';
</programlisting>
              <para>To test the mapper we just use /sparql endpoint with option 'Retrieve remote RDF data
for all missing source graphs' to execute:</para>
              <programlisting>
SELECT *
FROM &lt;URL-of-a-txt-file&gt;
WHERE { ?s ?p ?o }
</programlisting>
              <para>It is important that the SPARQL_UPDATE role to be granted to "SPARQL" account in order
to allow local repository update via Network Resource Fetch feature.</para>
              <para>
                <emphasis>Authentication in Sponger</emphasis>
              </para>
              <para>To enable usage of user defined authentication, there are added more parameters to the
/proxy/rdf and /sparql endpoints. So to use it, the RDF browser and iSPARQL should send following
url parameters:</para>
              <itemizedlist>
                <listitem>
                  <para>for /proxy/rdf endpoint:
</para>
                  <programlisting>
'login=&lt;account name&gt;'
</programlisting>
                </listitem>
                <listitem>
                  <para>for /sparql endpoint:
</para>
                  <programlisting>
get-login=&lt;account name&gt;
</programlisting>
                </listitem>
              </itemizedlist>
            </section>
            <section xml:id="virtuosospongerrdfmappersregistry">
              <title>Registry</title>
              <para>The table DB.DBA.SYS_RDF_MAPPERS is used as registry for registering RDF mappers.</para>
              <programlisting>
create table DB.DBA.SYS_RDF_MAPPERS (
    RM_ID integer identity,         -- mapper ID, designate order of execution
    RM_PATTERN varchar,             -- a REGEX pattern to match URL or MIME type
    RM_TYPE varchar default 'MIME', -- what property of the current resource to match: MIME or URL are supported at present
    RM_HOOK varchar,                -- fully qualified PL function name e.q. DB.DBA.MY_MAPPER_FUNCTION
    RM_KEY  long varchar,           -- API specific key to use
    RM_DESCRIPTION long varchar,    -- Mapper description, free text
    RM_ENABLED integer default 1,   -- a flag 0 or 1 integer to include or exclude the given mapper from processing chain
    primary key (RM_TYPE, RM_PATTERN))
;
</programlisting>
              <para>The current way to register/update/unregister a mapper is just a DML statement e.g.
NSERT/UPDATE/DELETE.</para>
            </section>
            <section xml:id="virtuosospongerrdfmappersexec">
              <title>Execution order and processing</title>
              <para>When SPARQL retrieves a resource with unknown content it will look in the mappers registry
and will loop over every record having RM_ENABLED flag true. The sequence of look-up is based on
ordering by RM_ID column. For every record it will either try matching the MIME type or URL against
RM_PATTERN value and if there is match the function specified in RM_HOOK column will be called.
If the function doesn't exists or signal an error the SPARQL will look at next record.</para>
              <para>When it stops looking? It will stop if value returned by mapper function is positive or
negative number, if the return is negative processing stops with meaning no RDF was supplied,
if return is positive the meaning is that RDF data was extracted, if zero integer is returned
then SPARQL will look for next mapper. The mapper function also can return zero if it is expected
next mapper in the chain to get more RDF data.</para>
              <para>If none of the mappers matches the signature (MIME type nor URL) the built-in WebDAV
metadata extractor will be called.</para>
            </section>
            <section xml:id="virtuosospongerrdfmappersextfunc">
              <title>Extension function</title>
              <para>The mapper function is a PL stored procedure with following signature:</para>
              <programlisting>
THE_MAPPER_FUNCTION_NAME (
        in graph_iri varchar,
        in origin_uri varchar,
        in destination_uri varchar,
        inout content varchar,
        inout async_notification_queue any,
        inout ping_service any,
        inout keys any
        )
{
   -- do processing here
   -- return -1, 0 or 1 (as explained above in Execution order and processing section)
}
;
</programlisting>
              <para>
                <emphasis>Parameters</emphasis>
              </para>
              <itemizedlist>
                <listitem>
                  <para>graph_iri - the target graph IRI</para>
                </listitem>
                <listitem>
                  <para>origin_uri - the current URI of processing</para>
                </listitem>
                <listitem>
                  <para>destination_uri - get:destination value</para>
                </listitem>
                <listitem>
                  <para>content - the resource content</para>
                </listitem>
                <listitem>
                  <para>async_notification_queue - if INI parameter PingService is specified in SPARQL
section in the INI file, this is a pre-allocated asynchronous queue to be used to call
ping service</para>
                </listitem>
                <listitem>
                  <para>ping_service - the URL of the ping service configured in SPARQL section in the
INI in PingService parameter</para>
                </listitem>
                <listitem>
                  <para>keys - a string value contained in the RM_KEY column for given mapper, can be
single string or serialized array, generally can be used as mapper specific data.</para>
                </listitem>
              </itemizedlist>
              <para>
                <emphasis>Return value</emphasis>
              </para>
              <itemizedlist>
                <listitem>
                  <para>0 - no data was retrieved or some next matching mapper must extract more data</para>
                </listitem>
                <listitem>
                  <para>1 - data is retrieved, stop looking for other mappers</para>
                </listitem>
                <listitem>
                  <para>-1 - no data is retrieved, stop looking for more data</para>
                </listitem>
              </itemizedlist>
            </section>
            <section xml:id="virtuosospongerrdfmapperspackage">
              <title>Cartridges package content</title>
              <para>The Virtuoso supply as a <link xlink:href="http://s3.amazonaws.com/opldownload/uda/vad-packages/6.3/virtuoso/cartridges_dav.vad">cartridges_dav.vad</link>

   VAD package a cartridge for extracting RDF data
from certain popular Web resources and file types. It can be installed (if not already) using
VAD_INSTALL function, see the VAD chapter in documentation on how to do that.</para>
              <para>
                <emphasis>HTTP-in-RDF</emphasis>
              </para>
              <para>Maps the HTTP request response to HTTP Vocabulary in RDF, see http://www.w3.org/2006/http#.</para>
              <para>This mapper is disabled by default. If it's enabled , it must be first in order of execution.</para>
              <para>Also it always will return 0, which means any other mapper should push more data.</para>
              <para>
                <emphasis>HTML</emphasis>
              </para>
              <para>This mapper is composite, it looking for metadata which can specified in a HTML pages as
follows:</para>
              <itemizedlist>
                <listitem>
                  <para>Embedded/linked RDF
  </para>
                  <itemizedlist>
                    <listitem>
                      <para>scan for meta in RDF
</para>
                      <programlisting>
&lt;link rel="meta" type="application/rdf+xml"
</programlisting>
                    </listitem>
                    <listitem>
                      <para>RDF embedded in xHTML (as markup or inside XML comments)
</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
                <listitem>
                  <para>Micro-formats

</para>
                  <itemizedlist>
                    <listitem>
                      <para>GRDDL - GRDDL Data Views: RDF expressed in XHTML and XML: http://www.w3.org/2003/g/data-view#
</para>
                    </listitem>
                    <listitem>
                      <para>eLinked Data - http://purl.org/NET/erdf/profile
</para>
                    </listitem>
                    <listitem>
                      <para>RDFa
</para>
                    </listitem>
                    <listitem>
                      <para>hCard - http://www.w3.org/2006/03/hcard
</para>
                    </listitem>
                    <listitem>
                      <para>hCalendar - http://dannyayers.com/microformats/hcalendar-profile
</para>
                    </listitem>
                    <listitem>
                      <para>hReview - http://dannyayers.com/micromodels/profiles/hreview
</para>
                    </listitem>
                    <listitem>
                      <para>relLicense - CC license: http://web.resource.org/cc/schema.rdf
</para>
                    </listitem>
                    <listitem>
                      <para>Dublin Core (DCMI) - http://purl.org/dc/elements/1.1/
</para>
                    </listitem>
                    <listitem>
                      <para>geoURL - http://www.w3.org/2003/01/geo/wgs84_pos#
</para>
                    </listitem>
                    <listitem>
                      <para>Google Base - OpenLink Virtuoso specific mapping
</para>
                    </listitem>
                    <listitem>
                      <para>Ning Metadata 
</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
                <listitem>
                  <para>Feeds extraction

</para>
                  <itemizedlist>
                    <listitem>
                      <para>RSS/Linked Data - SIOC &amp; AtomOWL
</para>
                    </listitem>
                    <listitem>
                      <para>RSS 1.0 - RSS/RDF, SIOC &amp; AtomOWL
</para>
                    </listitem>
                    <listitem>
                      <para>Atom 1.0 - RSS/RDF, SIOC &amp; AtomOWL
</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
                <listitem>
                  <para>xHTML metadata transformation using FOAF (foaf:Document) and Dublin Core
properties (dc:title, dc:subject etc.)</para>
                </listitem>
              </itemizedlist>
              <para>The HTML page mapper will look for RDF data in order as listed above, it will try to extract
metadata on each step and will return positive flag if any of the above step give a RDF data. In
case where page URL matches some of other RDF mappers listed in registry it will return 0 so
next mapper to extract more data. In order to function properly, this mapper must be executed
before any other specific mappers.</para>
              <para>
                <emphasis>Flickr URLs</emphasis>
              </para>
              <para>This mapper extracts metadata of the Flickr images, using Flickr REST API. To function
properly it must have configured key. The Flickr mapper extracts metadata using: CC license,
Dublin Core, Dublin Core Metadata Terms, GeoURL, FOAF, EXIF: http://www.w3.org/2003/12/exif/ns/ ontology.
</para>
              <para>
                <emphasis>Amazon URLs</emphasis>
              </para>
              <para>This mapper extracts metadata for Amazon articles, using Amazon REST API. It needs a Amazon
API key in order to be functional.</para>
              <para>
                <emphasis>eBay URLs</emphasis>
              </para>
              <para>Implements eBay REST API for extracting metadata of eBay articles, it needs a key and user
name to be configured in order to work.</para>
              <para>
                <emphasis>Open Office (OO) documents</emphasis>
              </para>
              <para>The OO documents contains metadata which can be extracted using UNZIP, so this extractor
needs Virtuoso unzip plugin to be configured on the server.</para>
              <para>
                <emphasis>Yahoo traffic data URLs</emphasis>
              </para>
              <para>Implements transformation of the result of Yahoo traffic data to RDF.
</para>
              <para>
                <emphasis>iCal files</emphasis>
              </para>
              <para>Transform iCal files to RDF as per http://www.w3.org/2002/12/cal/ical# .</para>
              <para>
                <emphasis>Binary content, PDF, PowerPoint</emphasis>
              </para>
              <para>The unknown binary content, PDF and MS PowerPoint files can be transformed to RDF using
Aperture framework (http://aperture.sourceforge.net/). This mapper needs Virtuoso with Java hosting
support, Aperture framework and MetaExtractor.class installed on the host system in order to work.</para>
              <para>The Aperture framework &amp; MetaExtractor.class must be installed on the system before to
install the <link xlink:href="http://s3.amazonaws.com/opldownload/uda/vad-packages/6.3/virtuoso/cartridges_dav.vad">Cartridges VAD package</link>

  .
If the package is already installed, then to activate this mapper
you can just re-install the VAD.</para>
              <para>
                <emphasis>Setting-up Virtuoso with Java hosting to run Aperture framework</emphasis>
              </para>
              <itemizedlist>
                <listitem>
                  <para>Install a Virtuoso binary which includes built-in Java hosting support (The executable name will
indicate whether the required hosting support is built in - a suitably enabled executable will include
javavm in the name, for example virtuoso-javavm-t, rather than virtuoso-t).</para>
                </listitem>
                <listitem>
                  <para>Download the Aperture framework from http://aperture.sourceforge.net.</para>
                </listitem>
                <listitem>
                  <para>Unpack the contents of the framework's lib directory into an 'aperture' subdirectory of the
Virtuoso working directory, i.e. of the directory containing the database and virtuoso.ini files.</para>
                </listitem>
                <listitem>
                  <para>Ensure the Virtuoso working directory includes a 'lib' subdirectory containing the file
MetaExtractor.class. (At the current time MetaExtractor.class in not included in the cartridges VAD.
Please contact OpenLink Technical Support to obtain a copy.)</para>
                </listitem>
                <listitem>
                  <para>In the [Parameters] section of the virtuoso.ini configuration file:
</para>
                  <itemizedlist>
                    <listitem>
                      <para>Add the line (linebreaks have been inserted for clarity):
</para>
                      <programlisting>
JavaClasspath = lib:aperture/DFKIUtils2.jar:aperture/JempBox-0.2.0.jar:aperture/activation-1.0.2-upd2.jar:aperture/aduna-commons-xml-2.0.jar:
aperture/ant-compression-utils-1.7.1.jar:aperture/aperture-1.2.0.jar:aperture/aperture-examples-1.2.0.jar:aperture/aperture-test-1.2.0.jar:
aperture/applewrapper-0.2.jar:aperture/bcmail-jdk14-132.jar:aperture/bcprov-jdk14-132.jar:aperture/commons-codec-1.3.jar:aperture/commons-httpclient-3.1.jar:
aperture/commons-lang-2.3.jar:aperture/demork-2.1.jar:aperture/flickrapi-1.0.jar:aperture/fontbox-0.2.0-dev.jar:aperture/htmlparser-1.6.jar:
aperture/ical4j-1.0-beta4.jar:aperture/infsail-0.1.jar:aperture/jacob-1.10.jar:aperture/jai_codec-1.1.3.jar:aperture/jai_core-1.1.3.jar:aperture/jaudiotagger-1.0.8.jar:
aperture/jcl104-over-slf4j-1.5.0.jar:aperture/jpim-0.1-aperture-1.jar:aperture/junit-3.8.1.jar:aperture/jutf7-0.9.0.jar:aperture/mail-1.4.jar:
aperture/metadata-extractor-2.4.0-beta-1.jar:aperture/mstor-0.9.11.jar:aperture/nrlvalidator-0.1.jar:aperture/openrdf-sesame-2.2.1-onejar-osgi.jar:
aperture/osgi.core-4.0.jar:aperture/pdfbox-0.7.4-dev-20071030.jar:aperture/poi-3.0.2-FINAL-20080204.jar:aperture/poi-scratchpad-3.0.2-FINAL-20080204.jar:
aperture/rdf2go.api-4.6.2.jar:aperture/rdf2go.impl.base-4.6.2.jar:aperture/rdf2go.impl.sesame20-4.6.2.jar:aperture/rdf2go.impl.util-4.6.2.jar:
aperture/slf4j-api-1.5.0.jar:aperture/slf4j-jdk14-1.5.0.jar:aperture/unionsail-0.1.jar:aperture/winlaf-0.5.1.jar
</programlisting>
                    </listitem>
                    <listitem>
                      <para>Ensure DirsAllowed includes directories /tmp, (or the temporary directory for the host
operating system), lib and aperture.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
                <listitem>
                  <para>Start the Virtuoso server with java hosting support</para>
                </listitem>
                <listitem>
                  <para>Configure the cartridge either by installing the cartridges VAD or, if the VAD is already
installed, by executing procedure DB.DBA.RDF_APERTURE_INIT.</para>
                </listitem>
                <listitem>
                  <para>During the VAD installation process, RDF_APERTURE_INIT() configures the Aperture cartridge. If
you look in the list of available cartridges under the RDF &gt; Sponger tab in Conductor, you should see
an entry for 'Binary Files'.</para>
                </listitem>
              </itemizedlist>
              <para>To check the cartridge has been configured, connect with Virtuoso's ISQL tool:</para>
              <itemizedlist>
                <listitem>
                  <para>Issue the command:
</para>
                  <programlisting>
SQL&gt; SELECT udt_is_available('APERTURE.DBA.MetaExtractor');
</programlisting>
                </listitem>
                <listitem>
                  <para>Copy a test PDF document to the Virtuoso working directory, then execute:
</para>
                  <programlisting>
SQL&gt; SELECT APERTURE.DBA."MetaExtractor"().getMetaFromFile ('some_pdf_in_server_working_dir.pdf', 0);

... some RDF data should be returned ...
</programlisting>
                </listitem>
              </itemizedlist>
              <para>You should now be able to Fetch all Network Resource document types supported by the Aperture framework, (using
one of the standard Sponger invocation mechanisms, for instance with a URL of the form
http://example.com/about/rdf/http://targethost/targetfile.pdf), subject to the MIME type pattern
filters configured for the cartridge in the Conductor UI. By default the Aperture cartridge is
registered to match MIME types (application/octet-stream)|(application/pdf)|(application/mspowerpoint).
To Fetch all the Network Resource MIME types Aperture is capable of handling, changed the MIME type pattern to
'application/.*'.</para>
              <para>Important: The installation guidelines presented above have been verified on Mac OS X with
Aperture 1.2.0. Some adjustment may be needed for different operating systems or versions of Aperture.</para>
              <para>
                <emphasis>Examples &amp; tutorials</emphasis>
              </para>
              <para>How to write own RDF mapper? Look at Virtuoso tutorial on this subject
http://demo.openlinksw.com/tutorial/rdf/rd_s_1/rd_s_1.vsp .
</para>
            </section>
          </section>
        </section>
        <section xml:id="virtuosospongercreatecustcartrxslt">
          <title>Meta-Cartridges</title>
          <para>So far the discussion has centered on 'primary' cartridges. However,
Virtuoso supports an alternative type of cartridge, a 'meta-cartridge'. The way a
meta-cartridge operates is essentially the same as a primary cartridge, that is it
has a cartridge hook function with the same signature and its inserts data into the
quad store through entity extraction and ontology mapping as before. Where meta-cartridges
differ from primary cartridges is in their intent and their position in the cartridge
invocation pipeline.</para>
          <para>The purpose of meta-cartridges is to enrich graphs produced by other (primary)
cartridges. They serve as general post-processors to add additional information about selected
entities in an RDF graph. For instance, a particular meta-cartridge might be designed to search
for entities of type 'umbel:Country' in a given graph, and then add additional statements about
each country it finds, where the information contained in these statements is retrieved from the
web service targeted by the meta-cartridge. One such example might be a 'World Bank' meta-cartridge
which adds information relating to a country's GDP, its exports of goods and services as a percentage
of GDP etc; retrieved using the <link xlink:href="http://developer.worldbank.org/docs/">World Bank web service API</link>

  .
In order to benefit from the World Bank meta-cartridge, any primary cartridge which might generate instance data relating to countries should
ensure that each country instance it handles is also described as being of rdf:type 'umbel:Country'.
Here, the <link xlink:href="http://wiki.umbel.org/index.php/Welcome">UMBEL</link>

   (Upper Mapping and Binding Exchange Layer) ontology is used as a data-source-agnostic
classification system. It provides a core set of 20,000+ subject concepts which act as "a fixed set of
reference points in a global knowledge space". The use of UMBEL in this way serves to decouple
meta-cartridges from primary cartridges and data source specific ontologies.</para>
          <para>Virtuoso includes two default meta-cartridges which use
UMBEL and <link xlink:href="http://www.opencalais.com/">OpenCalais</link>

   to augment source graphs.</para>
          <para>
            <emphasis>Registration</emphasis>
          </para>
          <para>Meta-cartridges must be registered in the RDF_META_CARTRIDGES table, which fulfills a role
similar to the SYS_RDF_MAPPERS table used by primary cartridges. The structure of the table, and the
meaning and use of its columns, are similar to SYS_RDF_MAPPERS. The meta-cartridge hook function
signature is identical to that for primary cartridges.</para>
          <para>The RDF_META_CARTRIDGES table definition is as follows:</para>
          <programlisting>
create table DB.DBA.RDF_META_CARTRIDGES (
MC_ID INTEGER IDENTITY,		-- meta-cartridge ID. Determines the order of the
                           	   meta-cartridge's invocation in the Sponger
                                 processing chain
MC_SEQ INTEGER IDENTITY,
MC_HOOK VARCHAR,			-- fully qualified Virtuoso/PL function name
MC_TYPE VARCHAR,
MC_PATTERN VARCHAR, 		-- a REGEX pattern to match resource URL or
					   MIME type
MC_KEY VARCHAR,			-- API specific key to use
MC_OPTIONS ANY,			-- meta-cartridge specific options
MC_DESC LONG VARCHAR, 		-- meta-cartridge description (free text)
MC_ENABLED INTEGER		-- a 0 or 1 integer flag to exclude or include
					   meta-cartridge from Sponger processing chain
);
</programlisting>
          <para>(At the time of writing there is no Conductor UI for registering meta-cartridges, they must be
registered using SQL. A Conductor interface for this task will be added in due course.)</para>
          <para>
            <emphasis>Invocation</emphasis>
          </para>
          <para>Meta-cartridges are invoked through the post-processing hook procedure RDF_LOAD_POST_PROCESS
which is called, for every document retrieved, after RDF_LOAD_RDFXML loads fetched data into the Quad
Store.</para>
          <para>Cartridges in the meta-cartridge registry (RDF_META_CARTRIDGES) are configured to match a given
MIME type or URI pattern. Matching meta-cartridges are invoked in order of their MC_SEQ value. Ordinarily
a meta-cartridge should return 0, in which case the next meta-cartridge in the post-processing chain will
be invoked. If it returns 1 or -1, the post-processing stops and no further meta-cartridges are invoked.</para>
          <para>The order of processing by the Sponger cartridge pipeline is thus:</para>
          <orderedlist>
            <listitem>
              <para>Try to get RDF in the form of TTL or RDF/XML. If RDF is retrieved if go to step 3</para>
            </listitem>
            <listitem>
              <para>Try generating RDF through the Sponger primary cartridges as before</para>
            </listitem>
            <listitem>
              <para>Post-process the RDF using meta-cartridges in order of their MC_SEQ value. If a meta-cartridge returns 1 or -1, stop the post-processing chain.</para>
            </listitem>
          </orderedlist>
          <para>Notice that meta-cartridges may be invoked even if primary cartridges are not.</para>
          <section xml:id="virtuosospongercreatecustcartrexfm">
            <title>Example - A Campaign Finance Meta-Cartridge for Freebase</title>
            <para>
              <emphasis>Note</emphasis>
            </para>
            <para>The example which follows builds on a Freebase Sponger cartridge developed prior to the announcement of Freebase's
support for generating Linked Data through the endpoint http://rdf.freebase.com/ . The OpenLink cartridge
has since evolved to reflect these changes. A snapshot of the Freebase cartridge and stylesheet compatible
with this example can be found <link linkend="virtuosospongerfreeb">here</link>

  .</para>
            <para><link xlink:href="http://www.freebase.com/">Freebase</link>

   is an open community database of the world's information which serves facts
and statistics rather than articles. Its designers see this difference in emphasis from article-oriented
databases as beneficial for developers wanting to use Freebase facts in other websites and applications.</para>
            <para>Virtuoso includes a Freebase cartridge in the cartridges VAD. The aim of the example cartridge presented here is to provide a lightweight
meta-cartridge that is used to conditionally add triples to graphs generated by the Freebase cartridge,
if Freebase is describing a U.S. senator.</para>
            <para>
              <emphasis>New York Times Campaign Finance (NYTCF) API</emphasis>
            </para>
            <para>The <link xlink:href="http://developer.nytimes.com/docs/campaign_finance_api?authChecked=1">New York Times Campaign Finance (NYTCF) API</link>

   allows you to retrieve contribution and
expenditure data based on United States Federal Election Commission filings. You can retrieve totals
for a particular presidential candidate, see aggregates by ZIP code or state, or get details on a
particular donor.</para>
            <para>The API supports a number of query types. To keep this example from being overly long,
the meta-cartridge supports just one of these - a query for the candidate details. An example query
and the resulting output follow:</para>
            <para>
              <emphasis>Query:</emphasis>
            </para>
            <programlisting>
http://api.nytimes.com/svc/elections/us/v2/president/2008/finances/candidates/obama,barack.xml?api-key=xxxx
</programlisting>
            <para>Result:</para>
            <programlisting>
&lt;result_set&gt;
 &lt;status&gt;OK&lt;/status&gt;
 &lt;copyright&gt;
  Copyright (c) 2008 The New York Times Company. All Rights Reserved.
 &lt;/copyright&gt;
 &lt;results&gt;
  &lt;candidate&gt;
    &lt;candidate_name&gt;Obama, Barack&lt;/candidate_name&gt;
    &lt;committee_id&gt;C00431445&lt;/committee_id&gt;
    &lt;party&gt;D&lt;/party&gt;
    &lt;total_receipts&gt;468841844&lt;/total_receipts&gt;
    &lt;total_disbursements&gt;391437723.5&lt;/total_disbursements&gt;
    &lt;cash_on_hand&gt;77404120&lt;/cash_on_hand&gt;
    &lt;net_individual_contributions&gt;426902994&lt;/net_individual_contributions&gt;
    &lt;net_party_contributions&gt;150&lt;/net_party_contributions&gt;
    &lt;net_pac_contributions&gt;450&lt;/net_pac_contributions&gt;
    &lt;net_candidate_contributions&gt;0&lt;/net_candidate_contributions&gt;
    &lt;federal_funds&gt;0&lt;/federal_funds&gt;
    &lt;total_contributions_less_than_200&gt;222694981.5&lt;/total_contributions_less_than_200&gt;
    &lt;total_contributions_2300&gt;76623262&lt;/total_contributions_2300&gt;
    &lt;net_primary_contributions&gt;46444638.81&lt;/net_primary_contributions&gt;
    &lt;net_general_contributions&gt;30959481.19&lt;/net_general_contributions&gt;
    &lt;total_refunds&gt;2058240.92&lt;/total_refunds&gt;
    &lt;date_coverage_from&gt;2007-01-01&lt;/date_coverage_from&gt;
    &lt;date_coverage_to&gt;2008-08-31&lt;/date_coverage_to&gt;
  &lt;/candidate&gt;
 &lt;/results&gt;
&lt;/result_set&gt;
</programlisting>
            <para>
              <emphasis>Sponging Freebase</emphasis>
            </para>
            <para>
              <emphasis>Using OpenLink Data Explorer</emphasis>
            </para>
            <para>The following instructions assume you have the <link xlink:href="http://ode.openlinksw.com/">OpenLink Data Explorer (ODE)</link>

   browser extension installed in your browser.</para>
            <para>An HTML description of Barack Obama can be obtained directly from Freebase by pasting the
 following URL into your browser: http://www.freebase.com/view/en/barack_obama</para>
            <para>To view RDF data fetched from this page, select 'Linked Data Sources' from the browser's
'View' menu. An OpenLink Data Explorer interface will load in a new tab.</para>
            <para>Clicking on the 'Barack Obama' link under the 'Person' category displayed by ODE fetches
RDF data using the Freebase cartridge. Click the 'down arrow' adjacent to the 'Barack Obama' link to
explore the retrieved data.</para>
            <para>Assuming your Virtuoso instance is running on port 8890 on localhost, the list of data caches displayed
by ODE should include: http://example.com/about/html/http/www.freebase.com/view/en/barack_obama#this</para>
            <para>The information displayed in the rest of the page relates to the entity instance identified by this URI. The prefix http://example.com/about/html/http/ prepended to the
original URI indicates that the Sponger Proxy Service has been invoked. The Sponger creates an associated
entity instance (identified by the above URI with the #this suffix) which holds network resource information being fetched
about the original entity.</para>
            <para>
              <emphasis>Using the Command Line</emphasis>
            </para>
            <para>As an alternative to ODE, you can perform Network Resource Fetch from the command line with the command:</para>
            <programlisting>
curl -H "Accept: text/xml" "http://example.com/about/html/http/www.freebase.com/view/en/barack_obama"
</programlisting>
            <para>To view the results, you can use Conductor's browser-based SPARQL interface (e.g.
http://example.com/sparql) to query the resulting graph generated by the Sponger,
http://www.freebase.com/view/en/barack_obama.</para>
            <para>
              <emphasis>Installing the Meta-Cartridge</emphasis>
            </para>
            <para>To register the meta-cartridge, a procedure similar to the following can be used:</para>
            <programlisting>
create procedure INSTALL_RDF_LOAD_NYTCF ()
{
  -- delete any previous NYTCF cartridge installed as a primary cartridge
  DELETE FROM SYS_RDF_MAPPERS WHERE RM_HOOK = 'DB.DBA.RDF_LOAD_NYTCF';
  -- register in the meta-cartridge post-processing chain
  INSERT SOFT DB.DBA.RDF_META_CARTRIDGES (MC_PATTERN, MC_TYPE, MC_HOOK,
    MC_KEY, MC_DESC, MC_OPTIONS)
    VALUES (
    'http://www.freebase.com/view/.*',
    'URL', 'DB.DBA.RDF_LOAD_NYTCF', '2c1d95a62e5fxxxxx', 'Freebase NYTCF',
    vector ());
};
</programlisting>
            <para>Looking at the list of cartridges in Conductor's 'RDF Cartridges' screen, you will
see that the Freebase cartridge is configured by default to perform Network Resource Fetch of URIs which match the pattern
"http://www.freebase.com/view/.*" The meta-cartridge is configured to match on the same URI pattern.</para>
            <para>To use the Campaign Finance API, you must register and request an API key. The script
above shows an invalid key. Replace it with your own key before executing the procedure.</para>
            <para>
              <emphasis>NYTCF Meta-Cartridge Functions</emphasis>
            </para>
            <para>The meta-cartridge function definitions are listed below. They can be executed by
pasting them into Conductor's iSQL interface.</para>
            <programlisting>
-- New York Times: Campaign Finance Web Service
-- See http://developer.nytimes.com/docs/campaign_finance_api

-- DB.DBA.RDF_NYTCF_LOOKUP is in effect a lightweight lookup cartridge that is used
-- to conditionally add triples to graphs generated by the Wikipedia and
-- Freebase cartridges. These cartridges call on RDF_NYTCF_LOOKUP when
-- handling an entity of rdf:type yago:Congressman109955781. The NYTCF lookup
-- cartridge (aka a metacartridge) is used to return campaign finance data
-- for the candidate in question retrieved from the New York Times Campaign
-- Finance web service.
create procedure DB.DBA.RDF_NYTCF_LOOKUP(
  in candidate_id any, 		-- id of candidate
  in graph_iri varchar,		-- graph into which the additional campaign finance triples should be loaded
  in api_key varchar		-- NYT finance API key
)
{
  declare version, campaign_type, year any;
  declare nyt_url, hdr, tmp any;
  declare xt, xd any;

  -- Common parameters - The NYT API only supports the following values at present:
  version := 'v2';
  campaign_type := 'president';
  year := '2008';

  -- Candidate summaries
  -- nyt_url := sprintf('http://api.nytimes.com/svc/elections/us/%s/%s/%s/finances/totals.xml?api-key=%s',
  --	version, campaign_type, year, api_key);

  -- Candidate details
  nyt_url := sprintf('http://api.nytimes.com/svc/elections/us/%s/%s/%s/finances/candidates/%s.xml?api-key=%s',
  	version, campaign_type, year, candidate_id, api_key);

  tmp := http_client_ext (nyt_url, headers=&gt;hdr, proxy=&gt;connection_get ('sparql-get:proxy'));
  if (hdr[0] not like 'HTTP/1._ 200 %')
    signal ('22023', trim(hdr[0], '\r\n'), 'DB.DBA.RDF_LOAD_NYTCF_LOOKUP');
  xd := xtree_doc (tmp);

  -- baseUri specifies what the generated RDF description is about
  -- &lt;rdf:Description rdf:about="{baseUri}"&gt;
  -- Example baseUri's:
  -- http://example.com/about/rdf/http://www.freebase.com/view/en/barack_obama#this
  -- http://example.com/about/rdf/http://www.freebase.com/view/en/hillary_rodham_clinton#this
  declare path any;
  declare lang, k, base_uri varchar;

  if (graph_iri like 'http://rdf.freebase.com/ns/%.%')
    base_uri := graph_iri;
  else
    {
      path := split_and_decode (graph_iri, 0, '%\0/');
      k := path [length(path) - 1];
      lang := path [length(path) - 2];

      base_uri := sprintf ('http://rdf.freebase.com/ns/%U.%U', lang, k);
    }

  xt := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/nytcf2rdf.xsl', xd,
      	vector ('baseUri', base_uri));
  xd := serialize_to_UTF8_xml (xt);
  DB.DBA.RDF_LOAD_RDFXML (xd, '', graph_iri);
}
;

create procedure DB.DBA.RDF_MQL_RESOURCE_IS_SENATOR (
  in fb_graph_uri varchar	-- URI of graph containing Freebase resource
)
{
  -- Check if the resource described by Freebase is a U.S. senator. Only then does it make sense to query for campaign finance
  -- data from the NYT data space.
  --
  -- To test for senators, we start by looking for two statements in the Freebase cartridge output, similar to:
  --
  -- &lt;rdf:Description rdf:about="http://example.com/about/rdf/http://www.freebase.com/view/en/hillary_rodham_clinton#this"&gt;
  --   &lt;rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/&gt;
  --   &lt;rdfs:seeAlso rdf:resource="http://en.wikipedia.org/wiki/Hillary_Rodham_Clinton"/&gt;
  --   ...
  -- where the graph generated by the Sponger will be &lt;http://www.freebase.com/view/en/hillary_rodham_clinton&gt;
  --
  -- To test whether a resource is a senator:
  -- 1) Check whether the Freebase resource is of rdf:type foaf:Person
  -- 2) Extract the person_name from the Wikipedia URI referenced by rdfs:seeAlso
  -- 3) Use the extracted person_name to build a URI to DBpedia's description of the person.
  -- 4) Query the DBpedia description to see if the person is of rdf:type yago:Senator110578471
  declare xp, xt, tmp any;
  declare qry varchar;			-- SPARQL query
  declare qry_uri varchar;		-- query URI
  declare qry_res varchar;		-- query result
  declare dbp_resource_name varchar;	-- Equivalent resource name in DBpedia
  declare fb_resource_uri varchar; 	-- Freebase resource URI
  declare path any;
  declare lang, k varchar;

  declare exit handler for sqlstate '*' {
    return 0;
  };

  if (fb_graph_uri like 'http://rdf.freebase.com/ns/%.%')
    fb_resource_uri := fb_graph_uri;
  else
    {
      path := split_and_decode (fb_graph_uri, 0, '%\0/');
      if (length (path) &lt; 2)
	return 0;

      k := path [length(path) - 1];
      lang := path [length(path) - 2];

      fb_resource_uri := sprintf ('http://rdf.freebase.com/ns/%U.%U', lang, k);
    }

  -- 1) Check whether the Freebase resource is a politician from united_states
  {
    declare stat, msg varchar;
    declare mdata, rset any;

    qry := sprintf ('sparql ask from &lt;%s&gt; where { &lt;%s&gt; &lt;http://rdf.freebase.com/ns/people.person.profession&gt; &lt;http://rdf.freebase.com/ns/en.politician&gt; ; &lt;http://rdf.freebase.com/ns/people.person.nationality&gt; &lt;http://rdf.freebase.com/ns/en.united_states&gt; . }', fb_graph_uri, fb_resource_uri);
    exec (qry, stat, msg, vector(), 1, mdata, rset);
    if (length(rset) = 0 or rset[0][0] &lt;&gt; 1)
      return 0;
  }

  return 1;
}
;

create procedure DB.DBA.RDF_LOAD_NYTCF_META (in graph_iri varchar, in new_origin_uri varchar,  in dest varchar,
    inout _ret_body any, inout aq any, inout ps any, inout _key any, inout opts any)
{
  declare candidate_id, candidate_name any;
  declare api_key any;
  declare indx, tmp any;
  declare ord int;

  declare exit handler for sqlstate '*'
  {
    return 0;
  };

  if (not DB.DBA.RDF_MQL_RESOURCE_IS_SENATOR (new_origin_uri))
    return 0;

  -- TO DO: hardcoded for now
  -- Need a mechanism to specify API key for meta-cartridges
  -- Could retrieve from virtuoso.ini?
  api_key := _key;

  -- NYT API supports a candidate_id in one of two forms:
  -- candidate_id ::= {candidate_ID} | {last_name [,first_name]}
  -- first_name is optional. If included, there should be no space after the comma.
  --
  -- However, because this meta cartridge supplies additional triples for the
  -- Wikipedia or Freebase cartridges, only the second form of candidate_id is
  -- supported. i.e. We extract the candidate name, rather than a numeric
  -- candidate_ID (FEC committee ID) from the Wikipedia or Freebase URL.
  --
  -- It's assumed that the source URI includes the candidate's first name.
  -- If it is omitted, the NYT API will return information about *all* candidates
  -- with that last name - something we don't want.

  indx := strstr(graph_iri, 'www.freebase.com/view/en/');
  if (indx is not null)
  {
    -- extract candidate_id from Freebase URI
    tmp := sprintf_inverse(subseq(graph_iri, indx), 'www.freebase.com/view/en/%s', 0);
    if (length(tmp) &lt;&gt; 1)
      return 0;
    candidate_name := tmp[0];
  }
  else
  {
    indx := strstr(graph_iri, 'wikipedia.org/wiki/');
    if (indx is not null)
    {
      -- extract candidate_id from Wikipedia URI
      tmp := sprintf_inverse(subseq(graph_iri, indx), 'wikipedia.org/%s', 0);
      if (length(tmp) &lt;&gt; 1)
        return 0;
      candidate_name := tmp[0];
    }
    else
      {
	tmp := sprintf_inverse(graph_iri, 'http://%s.freebase.com/ns/%s/%s', 0);
	if (length (tmp) &lt;&gt; 3)
	  tmp := sprintf_inverse(graph_iri, 'http://%s.freebase.com/ns/%s.%s', 0);
	if (length (tmp) &lt;&gt; 3)
	  return 0;
	candidate_name := tmp[2];
      }
  }

  -- split candidate_name into its component parts
  --   candidate_name is assumed to be firstname_[middlename_]*lastname
  --   e.g. hillary_rodham_clinton (Freebase), Hillary_clinton (Wikipedia)
  {
    declare i, _end, len int;
    declare names, tmp_name varchar;

    names := vector ();
    tmp_name := candidate_name;
    len := length (tmp_name);
    while (1)
    {
      _end := strchr(tmp_name, '_');
      if (_end is not null)
      {
        names := vector_concat (names, vector(subseq(tmp_name, 0, _end)));
        tmp_name := subseq(tmp_name, _end + 1);
      }
      else
      {
        names := vector_concat(names, vector(tmp_name));
        goto done;
      }
    }
done:
    if (length(names) &lt; 2)
      return 0;
    -- candidate_id ::= lastname,firstname
    candidate_id := sprintf('%s,%s', names[length(names)-1], names[0]);
  }

  DB.DBA.RDF_NYTCF_LOOKUP(candidate_id, coalesce (dest, graph_iri), api_key);
  return 0;
}
;
</programlisting>
            <para>
              <emphasis>NYTCF Meta-Cartridge Stylesheet</emphasis>
            </para>
            <para>The XSLT stylesheet, nyctf2rdf.xsl, used by the meta-cartridge to transform the base
Campaign Finance web service output to RDF is shown below. RDF_NYCTF_LOOKUP() assumes the stylesheet
is located alongside the other stylesheets provided by the cartridges VAD in the Virtuoso WebDAV
folder DAV/VAD/cartridges/xslt. You should create nyctf2rdf.xsl here from the following listing.
The WebDAV Browser interface in Conductor provides the easiest means to upload the stylesheet.</para>
            <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE xsl:stylesheet [
&lt;!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
&lt;!ENTITY nyt "http://www.nytimes.com/"&gt;
]&gt;

&lt;xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf=""
    xmlns:nyt=""
    &gt;
    &lt;xsl:output method="xml" indent="yes" /&gt;

  &lt;xsl:template match="/result_set/status"&gt;
      &lt;xsl:if test="text() = 'OK'"&gt;
        &lt;xsl:apply-templates mode="ok" select="/result_set/results/candidate"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="candidate" mode="ok"&gt;
      &lt;rdf:Description rdf:about="{vi:proxyIRI($baseUri)}"&gt;
	  &lt;nyt:candidate_name&gt;&lt;xsl:value-of select="candidate_name"/&gt;&lt;/nyt:candidate_name&gt;
	  &lt;nyt:committee_id&gt;&lt;xsl:value-of select="committee_id"/&gt;&lt;/nyt:committee_id&gt;
	  &lt;nyt:party&gt;&lt;xsl:value-of select="party"/&gt;&lt;/nyt:party&gt;
	  &lt;nyt:total_receipts&gt;&lt;xsl:value-of select="total_receipts"/&gt;&lt;/nyt:total_receipts&gt;
	  &lt;nyt:total_disbursements&gt;
	    &lt;xsl:value-of select="total_disbursements"/&gt;
	  &lt;/nyt:total_disbursements&gt;
	  &lt;nyt:cash_on_hand&gt;&lt;xsl:value-of select="cash_on_hand"/&gt;&lt;/nyt:cash_on_hand&gt;
	  &lt;nyt:net_individual_contributions&gt;
	    &lt;xsl:value-of select="net_individual_contributions"/&gt;
         &lt;/nyt:net_individual_contributions&gt;
	  &lt;nyt:net_party_contributions&gt;
	    &lt;xsl:value-of select="net_party_contributions"/&gt;
	  &lt;/nyt:net_party_contributions&gt;
	  &lt;nyt:net_pac_contributions&gt;
	    &lt;xsl:value-of select="net_pac_contributions"/&gt;
	  &lt;/nyt:net_pac_contributions&gt;
	  &lt;nyt:net_candidate_contributions&gt;
	    &lt;xsl:value-of select="net_candidate_contributions"/&gt;
	  &lt;/nyt:net_candidate_contributions&gt;
	  &lt;nyt:federal_funds&gt;&lt;xsl:value-of select="federal_funds"/&gt;&lt;/nyt:federal_funds&gt;
	  &lt;nyt:total_contributions_less_than_200&gt;
	    &lt;xsl:value-of select="total_contributions_less_than_200"/&gt;
	  &lt;/nyt:total_contributions_less_than_200&gt;
	  &lt;nyt:total_contributions_2300&gt;
	    &lt;xsl:value-of select="total_contributions_2300"/&gt;
	  &lt;/nyt:total_contributions_2300&gt;
	  &lt;nyt:net_primary_contributions&gt;
	    &lt;xsl:value-of select="net_primary_contributions"/&gt;
	  &lt;/nyt:net_primary_contributions&gt;
	  &lt;nyt:net_general_contributions&gt;
	    &lt;xsl:value-of select="net_general_contributions"/&gt;
	  &lt;/nyt:net_general_contributions&gt;
	  &lt;nyt:total_refunds&gt;&lt;xsl:value-of select="total_refunds"/&gt;&lt;/nyt:total_refunds&gt;
	  &lt;nyt:date_coverage_from rdf:datatype="date"&gt;
	    &lt;xsl:value-of select="date_coverage_from"/&gt;
	  &lt;/nyt:date_coverage_from&gt;
	  &lt;nyt:date_coverage_to rdf:datatype="date"&gt;
           &lt;xsl:value-of select="date_coverage_to"/&gt;
          &lt;/nyt:date_coverage_to&gt;
      &lt;/rdf:Description&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="text()|@*"/&gt;
&lt;/xsl:stylesheet&gt;
</programlisting>
            <para>The stylesheet uses the prefix nyt: (http://www.nytimes.com) for the predicates of
the augmenting triples. This has been used purely for illustration - you may prefer to define your
own ontology for RDF data derived from New York Times APIs.</para>
            <para>
              <emphasis>Testing the Meta-Cartridge</emphasis>
            </para>
            <para>After creating the required Virtuoso/PL functions and installing the stylesheet, you
should be able to test the meta-cartridge by sponging a Freebase page as described earlier using
ODE or the command line. For instance:</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>http://www.freebase.com/view/en/barack_obama , or </para>
              </listitem>
              <listitem>
                <para>http://www.freebase.com/view/en/hillary_rodham_clinton</para>
              </listitem>
            </itemizedlist>
            <para>You should see campaign finance data added to the graph created by the Sponger in the form of triples with predicates starting http://www.nytimes.com/xxx, e.g. http://www.nytimes.com/net_primary_contribution.</para>
            <para>
              <emphasis>How The Meta-Cartridge Works</emphasis>
            </para>
            <para>The comments in the meta-cartridge code detail how the cartridge works. In brief:</para>
            <para>Given the URI of the graph being created by the Freebase cartridge,
RDF_MQL_RESOURCE_IS_SENATOR checks if the resource described by Freebase is a U.S. senator.
Only then does it make sense to query for campaign finance data from the NYTCF data space.</para>
            <para>To test for senators, the procedure starts by looking for two statements in the Freebase cartridge output similar to:</para>
            <programlisting>
&lt;rdf:Description rdf:about="http://example.com/about/rdf/http://www.freebase.com/view/en/barack_obama#this"&gt;
  &lt;rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/&gt;
  &lt;rdfs:seeAlso rdf:resource="http://en.wikipedia.org/wiki/Barack_Obama"/&gt;
   ...
</programlisting>
            <para>where the graph generated by the Sponger will be</para>
            <programlisting>
&lt;http://www.freebase.com/view/en/barack_obama&gt;
</programlisting>
            <para>To test whether a resource is a senator, RDF_MQL_RESOURCE_IS_SENATOR</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>Checks whether the Freebase resource is of rdf:type foaf:Person</para>
              </listitem>
              <listitem>
                <para>Extracts the person's name from the Wikipedia URI referenced by rdfs:seeAlso</para>
              </listitem>
              <listitem>
                <para>Uses the extracted name to build a URI to DBpedia's description of the person. </para>
              </listitem>
              <listitem>
                <para>Queries the DBpedia description to see if the person is of rdf:type yago:Senator110578471 (

                <link xlink:href="http://www.mpi-inf.mpg.de/~suchanek/downloads/yago/">YAGO</link>
                 is a semantic knowledge base which provides a core set of concepts which in turn are used by DBpedia.)</para>
              </listitem>
            </itemizedlist>
            <para>Only if this is the case is the RDF_NYTCF_LOOKUP routine called to query for and return campaign finance data for the candidate. The form of the query and the resulting XML output from the Campaign Finance service were presented earlier.</para>
          </section>
        </section>
        <section xml:id="virtuosospongequeue">
          <title>Sponger Queue API</title>
          <section xml:id="virtuosospongequeuefn">
            <title>Functions</title>
            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  <emphasis>DB.DBA.RDF_SPONGER_QUEUE_ADD</emphasis>
                </para>
                <para>: This function is available when
           rdf cartridges vad is installed.
</para>
                <programlisting>
DB.DBA.RDF_SPONGER_QUEUE_ADD  (url, options);
</programlisting>
                <itemizedlist mark="bullet">
                  <listitem>
                    <para>
                      <emphasis>url
</emphasis>
                    </para>
                    <para>: the URI to perform Network Resource Fetch
</para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis>options
</emphasis>
                    </para>
                    <para>: an array usually typical sponger pragmas, for ex:
</para>
                    <programlisting>
vector ('get:soft',  'soft',  'refresh_free_text',  1);
</programlisting>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="virtuosospongequeuerwebs">
            <title>REST Web service</title>
            <para>The Sponger REST Web service has the following characteristics:</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>endpoint: http://cname/about/service</para>
              </listitem>
              <listitem>
                <para>parameters:
             </para>
                <itemizedlist mark="bullet">
                  <listitem>
                    <para>op=add: type of operation, for now addition to the queue is supported</para>
                  </listitem>
                  <listitem>
                    <para>uris=[json array]: an array of URIs to be added to the sponger queue, the format is JSON array, for example:
</para>
                    <programlisting>
 { "uris":["http://www.amazon.co.uk/Hama-Stylus-Input-Apple-iPad/dp/B003O0OM0C", "http://www.amazon.co.uk/Krusell-GAIA-Case-Apple-iPad/dp/B003QHXWWC" ] }
</programlisting>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
            <para>The service will return a json encoded result of the number of items added, for example:</para>
            <programlisting>
{ "result":2 }
</programlisting>
            <para>In case of error a JSON with error text will be returned and http status 500.</para>
            <bridgehead>cURL example</bridgehead>
            <orderedlist>
              <listitem>
                <para>Assume file.txt which contains URL encoded JSON string:
</para>
                <programlisting>
uris=%7B%20%22uris%22%3A%5B%22http%3A%2F%2Fwww.amazon.co.uk%2FHama-Stylus-Input-Apple-iPad%2Fdp%2FB003O0OM0C%22%2C%20%22http%3A%2F%2Fwww.amazon.co.uk%2FKrusell-GAIA-Case-Apple-iPad%2Fdp%2FB003QHXWWC%22%20%5D%20%7D
</programlisting>
              </listitem>
              <listitem>
                <para>Execute the following command:
</para>
                <programlisting>
curl -i -d@file.txt http://cname/about/service?op=add
HTTP/1.1 200 OK
Server: Virtuoso/06.02.3129 (Darwin) i686-apple-darwin10.0.0  VDB
Connection: Keep-Alive
Date: Thu, 05 May 2011 12:06:24 GMT
Accept-Ranges: bytes
Content-Type: applcation/json; charset="UTF-8"
Content-Length: 14

{ "result":2 }
</programlisting>
              </listitem>
            </orderedlist>
          </section>
        </section>
        <section xml:id="virtuosospongerelatedfunc">
          <title>Virtuoso functions usage examples</title>
          <section xml:id="virtuosospongerelatedfuncstring">
            <title>String Functions</title>
            <para>
              <emphasis>
                <link linkend="fn_sprintf_inverse">sprintf_inverse</link>
              </emphasis>
            </para>
            <programlisting>
tmp := sprintf_inverse (new_origin_uri, 'http://farm%s.static.flickr.com/%s/%s_%s.%s', 0);
img_id := tmp[2];
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_split_and_decode">split_and_decode</link>
              </emphasis>
            </para>
            <programlisting>
request_hdr := headers[0];
response_hdr := headers[1];
host := http_request_header (request, 'Host');
tmp := split_and_decode (request_hdr[0], 0, '\0\0 ');

http_method := tmp[0];
url := tmp[1];
protocol_version := substring (tmp[2], 6, 8);
tmp := rtrim (response_hdr[0], '\r\n');
tmp := split_and_decode (response_hdr[0], 0, '\0\0 ');
</programlisting>
          </section>
          <section xml:id="virtuosospongerelatedfuncrurl">
            <title>Retrieving URLs</title>
            <para>
              <emphasis>
                <link linkend="fn_http_get">http_get</link>
              </emphasis>
            </para>
            <programlisting>
url := sprintf('http://api.flickr.com/services/rest/?i"??
	method=flickr.photos.getInfo&amp;photo_id=%s&amp;api_key=%s', img_id, api_key);
tmp := http_get (url, hdr);
if (hdr[0] not like 'HTTP/1._ 200 %')
  signal ('22023', trim(hdr[0], '\r\n'), 'RDFXX');
xd := xtree_doc (tmp);
</programlisting>
            <para>
              <emphasis>DB.DBA.RDF_HTTP_URL_GET</emphasis>
            </para>
            <para>A wrapper around http_get. Retrieves a URL using the specified HTTP method
(defaults to GET). The function can handle proxies, redirects (up to fifteen) and HTTPS.</para>
            <programlisting>
uri := sprintf ('http://musicbrainz.org/ws/1/%s/%s?type=xml&amp;inc=%U',
	kind, id, inc);
cnt := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (cnt);
xd := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/mbz2rdf.xsl', xt, vector ('baseUri', new_origin_uri));
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_http_request_header">http_request_header</link>
              </emphasis>
            </para>
            <programlisting>
content := RDF_HTTP_URL_GET (rdf_url, new_origin_uri, hdr, 'GET',
		'Accept: application/rdf+xml, text/rdf+n3, */*');
ret_content_type := http_request_header (hdr, 'Content-Type', null, null);
</programlisting>
          </section>
          <section xml:id="virtuosospongerelatedfunchnxml">
            <title>Handling Non-XML Response Content</title>
            <para><emphasis>json_parse</emphasis>

  : Parses JSON content into a tree.</para>
            <programlisting>
url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
  content := http_get (url, hdr);
  tree := json_parse (content);
  tree := get_keyword ('ROOT', tree);
  tree := get_keyword ('result', tree);
</programlisting>
          </section>
          <section xml:id="virtuosospongerelatedfuncwrarb">
            <title>Writing Arbitrarily Long Text</title>
            <para>
              <emphasis>
                <link linkend="fn_http">http</link>
              </emphasis>
            </para>
            <programlisting>
-- Writing N3 to a string output stream using function http(), parsing the N3 into a graph, then loading the graph into the quad store.
ses := string_output ();
http ('@prefix opl: &lt;http://www.openlinksw.com/schema/attribution#&gt; .\n', ses);
http ('@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .\n', ses);
...
DB.DBA.TTLP (ses, base, graph);
DB.DBA.RDF_LOAD_RDFXML (strg, base, graph);
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_string_output">string_output</link>
              </emphasis>
            </para>
            <programlisting>
ses := string_output ();
cnt := http_get (sprintf ('http://download.finance.yahoo.com/d/quotes.csv?s=%U&amp;f=nsbavophg&amp;e=.csv',
    symbol));
arr := rdfm_yq_parse_csv (cnt);
http ('&lt;quote stock="NASDAQ"&gt;', ses);
foreach (any q in arr) do
  {
    http_value (q[0], 'company', ses);
    http_value (q[1], 'symbol', ses);
    ...
  }
  http ('&lt;/quote&gt;', ses);
  content := string_output_string (ses);
  xt := xtree_doc (content);
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_string_output_string">string_output_string</link>
              </emphasis>
            </para>
          </section>
          <section xml:id="virtuosospongerelatedfuncxmlxslt">
            <title>XML &amp; XSLT</title>
            <para>
              <emphasis>
                <link linkend="fn_xtree_doc">xtree_doc</link>
              </emphasis>
            </para>
            <programlisting>
content := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_xpath_eval">xpath_eval</link>
              </emphasis>
            </para>
            <programlisting>
profile := cast (xpath_eval ('/html/head/@profile', xt) as varchar);
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_xslt">DB.DBA.RDF_MAPPER_XSLT</link>
              </emphasis>
            </para>
            <programlisting>
tmp := http_get (url);
xd := xtree_doc (tmp);
xt := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_cartridges_path_') || 'xslt/atom2rdf.xsl',
	xd, vector ('baseUri', coalesce (dest, graph_iri)));
</programlisting>
          </section>
          <section xml:id="virtuosospongerelatedfunccharserconv">
            <title>Character Set Conversion</title>
            <para>
              <emphasis>
                <link linkend="fn_serialize_to_utf8_xml">serialize_to_UTF8_xml</link>
              </emphasis>
            </para>
            <programlisting>
xt := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_cartridges_path_') || 'xslt/crunchbase2rdf.xsl',
	xt, vector ('baseUri', coalesce (dest, graph_iri), 'base', base,
	'suffix', suffix));
xd := serialize_to_UTF8_xml (xt);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
</programlisting>
          </section>
          <section xml:id="virtuosospongerelatedfuncloaddata">
            <title>Loading Data Into the Quad Store</title>
            <para>
              <emphasis>
                <link linkend="fn_rdf_load_rdfxml">DB.DBA.RDF_LOAD_RDFXML</link>
              </emphasis>
            </para>
            <programlisting>
content := RDF_HTTP_URL_GET (uri, '', hdr, 'GET', 'Accept: */*');
xt := xtree_doc (content);
xd := DB.DBA.RDF_MAPPER_XSLT (
	registry_get ('_cartridges_path_') || 'xslt/mbz2rdf.xsl',
	xt, vector ('baseUri', new_origin_uri));
xd := serialize_to_UTF8_xml (xd);
DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
</programlisting>
            <para>
              <emphasis>
                <link linkend="fn_ttlp">DB.DBA.TTLP</link>
              </emphasis>
            </para>
            <programlisting>
sess := string_output ();
...
http (sprintf ('&lt;http://dbpedia.org/resource/%s&gt;
	&lt;http://xbrlontology.com/ontology/finance/stock_market#hasCompetitor&gt;
	&lt;http://dbpedia.org/resource/%s&gt; .\n',
	symbol, x), sess);
http (sprintf ('&lt;http://dbpedia.org/resource/%s&gt;
	&lt;http://www.w3.org/2000/01/rdf-schema#isDefinedBy&gt;
	&lt;http://finance.yahoo.com/q?s=%s&gt; .\n',
	 x, x), sess);
content := string_output_string (sess);
DB.DBA.TTLP (content, new_origin_uri, coalesce (dest, graph_iri));
</programlisting>
            <tip>
              <title>See Also:</title>
              <itemizedlist mark="bullet">
                <listitem>
                  <para>
                    <link linkend="rdfinsertmethodsapifunct">Loading RDF using API functions</link>
                  </para>
                </listitem>
              </itemizedlist>
            </tip>
          </section>
          <section xml:id="virtuosospongerelatedfuncdebugpoutput">
            <title>Debug Output</title>
            <para>
              <emphasis>
                <link linkend="fn_dbg_obj_print">dbg_obj_print</link>
              </emphasis>
            </para>
            <programlisting>
dbg_obj_print ('try all grddl mappings here');
</programlisting>
          </section>
        </section>
        <section xml:id="virtuosospongeref">
          <title>References</title>
          <itemizedlist mark="bullet">
            <listitem>
              <para>RDF Primer: http://www.w3.org/TR/2004/REC-rdf-primer-20040210/</para>
            </listitem>
            <listitem>
              <para>RDF/XML Syntax Specification: http://www.w3.org/TR/rdf-syntax-grammar/</para>
            </listitem>
            <listitem>
              <para>GRDDL Primer: http://www.w3.org/TR/grddl-primer/</para>
            </listitem>
          </itemizedlist>
          <section xml:id="virtuosospongerefping">
            <title>PingTheSemanticWeb RDF Notification Service</title>
            <para><link xlink:href="http://www.pingthesemanticweb.com/">PingtheSemanticWeb</link>

   (PTSW) is a repository for RDF documents. The PTSW web service
archives the location of recently created or updated RDF documents on the Web. It is intended
for use by crawlers or other types of software agents which need to know when and where the
latest updated RDF documents can be found. They can request a list of recently updated documents
as a starting location to crawl the Semantic Web.</para>
            <para>You may find this service useful for publicizing your own RDF content. Content authors can
notify PTSW that an RDF document has been created or updated by pinging the service with the URL of
the document. The Sponger supports this facility through the async_queue and ping_service parameters
of the cartridge hook function, where the ping_service parameter contains the ping service URL as
configured in the SPARQL section of the virtuoso.ini file:</para>
            <programlisting>
[SPARQL]
...
PingService = http://rpc.pingthesemanticweb.com/
...
</programlisting>
            <para>The configured ping service can be called using an asynchronous request and
the RDF_SW_PING procedure as illustrated below. </para>
            <programlisting>
create procedure DB.DBA.RDF_LOAD_HTML_RESPONSE (
  in graph_iri varchar, in new_origin_uri varchar, in dest varchar,
  inout ret_body any, inout async_queue any, inout ping_service any,
  inout _key any, inout opts any )
{
  ...
  if ( ... and async_queue is not null)
    aq_request (async_queue, 'DB.DBA.RDF_SW_PING',
                vector (ping_service, new_origin_uri));
</programlisting>
            <para>For more details refer to section <link linkend="asyncexecmultithread">Asynchronous Execution and Multithreading in Virtuoso/PL</link>

  </para>
          </section>
          <section xml:id="virtuosospongeremname">
            <title>Main Namespaces used by OpenLink Cartridges</title>
            <para>A list of the main namespaces / ontologies used by OpenLink-provided Sponger cartridges
is given below. Some of these ontologies may prove useful when creating your own cartridges.</para>
            <itemizedlist mark="bullet">
              <listitem>
                <para>- http://www.openlinksw.com/virtuoso/xslt/</para>
              </listitem>
              <listitem>
                <para>- http://example.com/schemas/XHTML# </para>
              </listitem>
              <listitem>
                <para>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# </para>
              </listitem>
              <listitem>
                <para>rdfs: http://www.w3.org/2000/01/rdf-schema# </para>
              </listitem>
              <listitem>
                <para>dc: http://purl.org/dc/elements/1.1/</para>
              </listitem>
              <listitem>
                <para>dcterms: http://purl.org/dc/terms/</para>
              </listitem>
              <listitem>
                <para>foaf: http://xmlns.com/foaf/0.1/</para>
              </listitem>
              <listitem>
                <para>sioc: http://rdfs.org/sioc/ns# </para>
              </listitem>
              <listitem>
                <para>sioct: http://rdfs.org/sioc/types# </para>
              </listitem>
              <listitem>
                <para>skos: http://www.w3.org/2004/02/skos/core# </para>
              </listitem>
              <listitem>
                <para>bibo: http://purl.org/ontology/bibo/</para>
              </listitem>
            </itemizedlist>
          </section>
          <section xml:id="virtuosospongerfreeb">
            <title>Freebase Cartridge &amp; Stylesheet</title>
            <para>Snapshots of the Freebase cartridge and stylesheet compatible with the meta-cartridge
example presented earlier in this document can be found below.</para>
            <para>
              <emphasis>DB.DBA.RDF_LOAD_MQL:</emphasis>
            </para>
            <programlisting>
--no_c_escapes-
create procedure DB.DBA.RDF_LOAD_MQL (in graph_iri varchar, in new_origin_uri varchar,  in dest varchar,
    inout _ret_body any, inout aq any, inout ps any, inout _key any, inout opts any)
{
  declare qr, path, hdr any;
  declare tree, xt, xd, types any;
  declare k, cnt, url, sa varchar;

  hdr := null;
  sa := '';
  declare exit handler for sqlstate '*'
    {
      --dbg_printf ('%s', __SQL_MESSAGE);
      return 0;
    };

  path := split_and_decode (new_origin_uri, 0, '%\0/');
  if (length (path) &lt; 1)
    return 0;
  k := path [length(path) - 1];
  if (path [length(path) - 2] = 'guid')
    k := sprintf ('"id":"/guid/%s"', k);
  else
  {
    if (k like '#%')
        k := sprintf ('"id":"%s"', k);
    else
      {
	sa := DB.DBA.RDF_MQL_GET_WIKI_URI (k);
    k := sprintf ('"key":"%s"', k);
  }
  }
  qr := sprintf ('{"ROOT":{"query":[{%s, "type":[]}]}}', k);
  url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
  cnt := http_get (url, hdr);
  tree := json_parse (cnt);
  xt := get_keyword ('ROOT', tree);
  if (not isarray (xt))
    return 0;
  xt := get_keyword ('result', xt);
  types := vector ();
  foreach (any tp in xt) do
    {
      declare tmp any;
      tmp := get_keyword ('type', tp);
      types := vector_concat (types, tmp);
    }
  --types := get_keyword ('type', xt);
  DELETE FROM DB.DBA.RDF_QUAD WHERE g =  iri_to_id(new_origin_uri);
  foreach (any tp in types) do
    {
      qr := sprintf ('{"ROOT":{"query":{%s, "type":"%s", "*":[]}}}', k, tp);
      url := sprintf ('http://www.freebase.com/api/service/mqlread?queries=%U', qr);
      cnt := http_get (url, hdr);
      --dbg_printf ('%s', cnt);
      tree := json_parse (cnt);
      xt := get_keyword ('ROOT', tree);
      xt := DB.DBA.MQL_TREE_TO_XML (tree);
      --dbg_obj_print (xt);
      xt := DB.DBA.RDF_MAPPER_XSLT (registry_get ('_cartridges_path_') || 'xslt/mql2rdf.xsl', xt,
      	vector ('baseUri', coalesce (dest, graph_iri), 'wpUri', sa));
      sa := '';
      xd := serialize_to_UTF8_xml (xt);
--      dbg_printf ('%s', xd);
      DB.DBA.RM_RDF_LOAD_RDFXML (xd, new_origin_uri, coalesce (dest, graph_iri));
    }
  return 1;
}
</programlisting>
            <para>
              <emphasis>mql2rdf.xsl:</emphasis>
            </para>
            <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!--
 -
 -  $Id$
 -
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -
 -  Copyright (C) 1998-2024 OpenLink Software
 -
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
--&gt;

&lt;!DOCTYPE xsl:stylesheet [
&lt;!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
&lt;!ENTITY bibo "http://purl.org/ontology/bibo/"&gt;
&lt;!ENTITY xsd  "http://www.w3.org/2001/XMLSchema#"&gt;
&lt;!ENTITY foaf "http://xmlns.com/foaf/0.1/"&gt;
&lt;!ENTITY sioc "http://rdfs.org/sioc/ns#"&gt;
]&gt;

&lt;xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:vi="http://www.openlinksw.com/virtuoso/xslt/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:sioc=""
    xmlns:bibo=""
    xmlns:foaf=""
    xmlns:skos="http://www.w3.org/2004/02/skos/core#"
    xmlns:dcterms= "http://purl.org/dc/terms/"
    xmlns:mql="http://www.freebase.com/"&gt;

    &lt;xsl:output method="xml" indent="yes" /&gt;

    &lt;xsl:param name="baseUri" /&gt;
    &lt;xsl:param name="wpUri" /&gt;

    &lt;xsl:variable name="ns"&gt;http://www.freebase.com/&lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
	&lt;rdf:RDF&gt;
	    &lt;xsl:if test="/results/ROOT/result/*"&gt;
		&lt;rdf:Description rdf:about="{$baseUri}"&gt;
		    &lt;rdf:type rdf:resource="Document"/&gt;
		    &lt;rdf:type rdf:resource="Document"/&gt;
		    &lt;rdf:type rdf:resource="Container"/&gt;
		    &lt;sioc:container_of rdf:resource="{vi:proxyIRI($baseUri)}"/&gt;
		    &lt;foaf:primaryTopic rdf:resource="{vi:proxyIRI($baseUri)}"/&gt;
		    &lt;dcterms:subject rdf:resource="{vi:proxyIRI($baseUri)}"/&gt;
		&lt;/rdf:Description&gt;
		&lt;rdf:Description rdf:about="{vi:proxyIRI($baseUri)}"&gt;
		    &lt;rdf:type rdf:resource="Item"/&gt;
		    &lt;sioc:has_container rdf:resource="{$baseUri}"/&gt;
		    &lt;xsl:apply-templates select="/results/ROOT/result/*"/&gt;
		    &lt;xsl:if test="$wpUri != ''"&gt;
			&lt;rdfs:seeAlso rdf:resource="{$wpUri}"/&gt;
		    &lt;/xsl:if&gt;
		&lt;/rdf:Description&gt;
	    &lt;/xsl:if&gt;
	&lt;/rdf:RDF&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="*[starts-with(.,'http://') or starts-with(.,'urn:')]"&gt;
	&lt;xsl:element namespace="{$ns}" name="{name()}"&gt;
	    &lt;xsl:attribute name="rdf:resource"&gt;
		&lt;xsl:value-of select="vi:proxyIRI (.)"/&gt;
	    &lt;/xsl:attribute&gt;
	&lt;/xsl:element&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="*[starts-with(.,'/')]"&gt;
	&lt;xsl:if test="local-name () = 'type' and . like '%/person'"&gt;
	    &lt;rdf:type rdf:resource="Person"/&gt;
	&lt;/xsl:if&gt;
	&lt;xsl:if test="local-name () = 'type'"&gt;
	    &lt;sioc:topic&gt;
		&lt;skos:Concept rdf:about="{vi:proxyIRI (concat ($ns, 'view', .))}"/&gt;
	    &lt;/sioc:topic&gt;
	&lt;/xsl:if&gt;

	&lt;xsl:element namespace="{$ns}" name="{name()}"&gt;
	    &lt;xsl:attribute name="rdf:resource"&gt;
		&lt;xsl:value-of select="vi:proxyIRI(concat ($ns, 'view', .))"/&gt;
	    &lt;/xsl:attribute&gt;
	&lt;/xsl:element&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="*[* and ../../*]"&gt;
	&lt;xsl:element namespace="{$ns}" name="{name()}"&gt;
	    &lt;xsl:attribute name="rdf:parseType"&gt;Resource&lt;/xsl:attribute&gt;
	    &lt;xsl:apply-templates select="@*|node()"/&gt;
	&lt;/xsl:element&gt;
    &lt;/xsl:template&gt;

  &lt;xsl:template match="*"&gt;
	&lt;xsl:if test="* or . != ''"&gt;
		&lt;xsl:choose&gt;
		    &lt;xsl:when test="name()='image'"&gt;
			&lt;foaf:depiction rdf:resource="{vi:mql-image-by-name (.)}"/&gt;
		    &lt;/xsl:when&gt;
		    &lt;xsl:otherwise&gt;
			&lt;xsl:element namespace="{$ns}" name="{name()}"&gt;
			    &lt;xsl:if test="name() like 'date_%'"&gt;
				&lt;xsl:attribute name="rdf:datatype"&gt;dateTime&lt;/xsl:attribute&gt;
			    &lt;/xsl:if&gt;
			    &lt;xsl:apply-templates select="@*|node()"/&gt;
			&lt;/xsl:element&gt;
		    &lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
	&lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</programlisting>
          </section>
        </section>
        <section xml:id="rdfspongerprogrammerguidepython">
          <title>Using Python to perform Virtuoso Sponging</title>
          <para>This section contains the generic steps to use Python language to extend the Virtuoso Sponger.</para>
          <orderedlist>
            <listitem>
              <para>Build the latest Python hosting module. It will introduce a new function 
              <code>python_exec ()</code>
              The parameters of python_exec are :</para>
              <itemizedlist mark="bullet">
                <listitem>
                  <para>string containing a python code, it should define one or more functions, see remarks below
</para>
                </listitem>
                <listitem>
                  <para>string containing name of function to be called
</para>
                </listitem>
                <listitem>
                  <para>list of parameters for the function 
</para>
                </listitem>
              </itemizedlist>
              <para>For Example:</para>
              <programlisting>
python_exec (file_to_string ('spoonge.py'), 'rdf4uri', 'http://url..', 'http://base...');
</programlisting>
              <para>The above means call the rdf4uri ('http://url..', 'http://base...') function from spoonge.py file.
It is importnat to know that python_exec is restricted to DBA only group and that the python source
should not have __main__ or this to be restricted in python code to not be called .
Any print etc. for stdout/stderr will go on server console if server is on foreground.
Can be used for debug for example but not for real work. </para>
              <para>The function is supposed to return just single string, don't try to return multiple results,
this will not work in this revision.
</para>
            </listitem>
            <listitem>
              <para>Setup the Virtuoso server INI to include python module:
</para>
              <programlisting>
...
[Plugins]
LoadPath = ../lib
Load1    = Hosting, hosting_python.so
...
</programlisting>
            </listitem>
            <listitem>
              <para>Download and install the rdflib package from http://www.rdflib.net/
Note before to build, disable Zope interface in rdflib as this not work with C-API correctly.
Or make sure Python has no Zope interfaces installed.
To disable the zope in rdflib, just comment out following in &lt;rdflibhome&gt;/rdflib/__init__.py:
</para>
              <programlisting>
 36 #from rdflib.interfaces import IIdentifier, classImplements
 37 #classImplements(URIRef, IIdentifier)
 38 #classImplements(BNode, IIdentifier)
 39 #classImplements(Literal, IIdentifier)
</programlisting>
              <para>Then do:</para>
              <programlisting>
perl setup.py build
perl setup.py --user install
</programlisting>
            </listitem>
            <listitem>
              <para>Get an example of python code for sponger like: http://www.ebusiness-unibw.org/wiki/Python4Spongers
and make sure you disable the last lines which not suitable for calling inside Sponger:
</para>
              <programlisting>
...
#if __name__ == '__main__':
#	rdf_xml = rdf4uri(uri='http://www.amazon.com/Apple-touch-Generation-NEWEST-MODEL/dp/B002M3SOBU/')
#	print rdf_xml
</programlisting>
              <para>Store the python code in sponge.py in server working directory.
Make sure this directory is allowed to read in DirsAllowed INI setting.</para>
            </listitem>
            <listitem>
              <para>Create a procedure and register with Sponger:
</para>
              <programlisting>
-- THIS IS FOR DEMO PURPOSE ONLY

-- for demo purposes we delete all other cartridges registrations to see effect from only this cartridge
delete from DB.DBA.SYS_RDF_MAPPERS;
delete from DB.DBA.RDF_META_CARTRIDGES;

-- register cartridge
insert soft DB.DBA.SYS_RDF_MAPPERS (RM_PATTERN, RM_TYPE, RM_HOOK, RM_KEY, RM_DESCRIPTION)
	values ('(http://.*amazon.[^/]+/[^/]+/dp/[^/]+(/.*)?)', 'URL', 'DB.DBA.RDF_LOAD_PYTHON_AMAZON_ARTICLE', null, 'Amazon articles');

-- the cartridge stored procedure itself
create procedure DB.DBA.RDF_LOAD_PYTHON_AMAZON_ARTICLE (in graph_iri varchar, in new_origin_uri varchar,  in dest varchar,
    inout _ret_body any, inout aq any, inout ps any, inout _key any, inout opts any)
{
  declare result any;
  -- we check first python hosting is capable to run code
  if (__proc_exists ('python_exec', 2) is null)
    return 0;
  -- handle any error
  declare exit handler for sqlstate '*'
    {
      -- log the error
      DB.DBA.RM_RDF_SPONGE_ERROR (current_proc_name (), graph_iri, dest, __SQL_MESSAGE);
      return 0;
    };
  -- call the python code
  result := python_exec (file_to_string ('sponge.py'), 'rdf4uri', new_origin_uri);
  -- in case of python error we will get integer zero, so we check
  if (not isstring (result))
    return 0;
  -- for demo purpose we delete all from this graph
  delete from DB.DBA.RDF_QUAD where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_iri);
  -- load the results
  DB.DBA.RDF_LOAD_RDFXML (result, new_origin_uri, coalesce (dest, graph_iri), 0);
  return 1;
}
;
</programlisting>
            </listitem>
            <listitem>
              <para>Test the Sponger code like this:
</para>
              <programlisting>
sparql define get:soft "soft" select * from &lt;http://www.amazon.com/Apple-touch-Generation-NEWEST-MODEL/dp/B002M3SOBU/&gt; { ?s ?p ?o };
</programlisting>
            </listitem>
          </orderedlist>
        </section>
      </section>
