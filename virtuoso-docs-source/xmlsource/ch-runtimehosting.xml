<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:id="ch-runtimehosting">
    <info>
      <title>Runtime Hosting</title>
      <abstract>
        <para>Virtuoso can be extended by in-process hosting of a number
of different run time environments.  This includes: Microsoft's .NET CLR (CLR),
the Mono ECMA-CLI (Mono), and the Java Virtual Machine (JVM).
Thus, you can create persistent stored modules, SQL functions,
and user defined data types using any Microsoft .NET or Mono
bound language, Java, and traditional languages such as 'C'/C++.</para>
        <para>Objects provided by hosted run times, such as Java and CLR can be
directly and transparently accessed from SQL.  This also means that
application logic in any hosted language can be exposed as a web
service.  By offering a choice of hosted run times in a cross platform
setting, Virtuoso adds a new degree of freedom for the application
designer.  Applications can now be developed and deployed on either
Windows, Linux or Unix, can be written in Java or any .net CLR bound
language and can talk to any database via Virtuoso's virtual databasing
capabilities.</para>
        <para>The Virtuoso Server Extension Interface (VSEI) provides C
 interfaces and hooks that enable developers to write external functionality
 that can be bolted on the side of Virtuoso and called as SQL functions.
</para>
      </abstract>
    </info>
    <section xml:id="rthactivation">
      <title>Runtime Environments</title>
      <para>The Virtuoso server in its standard build is a single executable.  To
 allow for external customizations based on VSEs the Virtuoso server engine
 becomes a callable library, the main function is re-written to incorporate other
 libraries and a new executable is created.
For example, a Virtuoso server
 that contains PHP support under Windows consists of: </para>
      <programlisting>
 65K virtuoso-odbc-php-t.exe
5.2M libvirtuoso-odbc-t.dll
1.2M php4ts.dll
</programlisting>
      <para>which replaces the usual <computeroutput>7M virtuoso-odbc-t.exe</computeroutput>

  .
 <computeroutput>virtuoso.odbc-php-t.exe</computeroutput>

   is then executed
 in the usual way.</para>
      <para>The Linux counterpart would be an
 <computeroutput>8M virtuoso-odbc-php-t</computeroutput>

   binary.</para>
      <para>The Virtuoso executable files provided in the installer are appropriately
 named to indicate which customizations are supported.  e.g. one that
 contains "php" and "clr" in the file name has been built with PHP and
 CLR support.</para>
      <para>The location of the support libraries (.DLL's) for the various
 customizations of Virtuoso on Windows must either be in the %PATH%;
 environment variable or be the same directory as the virtuoso .EXE file.
 Virtuoso will not be able to start otherwise.</para>
      <note>
        <title>Note:</title>
        <para>If Virtuoso is starting as a system service then the
 SYSTEM PATH must be altered as opposed to the USER PATH.  The USER PATH
 is appropriate to alter if Virtuoso is being started as that user, usually when
 in debug/foreground mode.  This is applicable to any required environment
 variables, not just PATH.</para>
      </note>
      <para>Hosted environments that require SQL access back to the database can
 make use of the in-process client mechanism.  Hosted Runtimes such as PHP
 and ASP .Net would ordinarily use an RPC based (ODBC) connection.  To improve
 the efficiency of the system, keeping it all in-process, a special connection
 can be made with no alteration to the API used in the code for communication.</para>
      <tip>
        <title>See Also:</title>
        <para>The <link linkend="inprocess">In-Process Client</link>

   keeps connections
   within Virtuoso avoiding unnecessary RPCs.</para>
      </tip>
    </section>
    <section xml:id="rthclr">
      <title>CLR, .Net &amp; ASPX Host</title>
      <para>The Common Language Runtime (CLR) is the foundation upon which the
 Microsoft® .NET strategy is built.  The CLR provides an execution environment
 that manages running code and provides services that make software development
 easier.  These services include automatic memory management, cross-language
 integration, interoperability with existing code and systems, simplified
 deployment, and a fine grained security system.  The .NET platform also
 brings with it a new programming language called C#.  It is very similar to Java
 and allows developers to make full use of all features available on the .NET runtime.</para>
      <para>The CLR can run a variety of different types of applications, such as:
 console applications, Web server scripts, traditional Win32-based applications,
  and more.</para>
      <para>The CLR provides a language specification for compilers to generate classes
 and code that can interoperate with other programming languages (The
 Common Language Specification: CLS) .  Any API that is written using a
 CLS provider language can be used by any language that is a CLS consumer.
 Compilers generate code in a format called Common Intermediate Language
 (CIL) which is an intermediate representation of a compiled program and is
 easy to compile to native code or be compiled using Just-in-Time (JIT)
 engines.  The restrictions placed by the runtime on the CIL byte codes
 ensures good potential for code optimization by the JIT compiler.  The runtime
 environment provides garbage collection, threading and a comprehensive class
 library.  All these things make code development easier and more appealing
 by allowing a mixture of languages to be collaborating to produce results, all
 contained within a managed sandbox to prevent bugs from breaking other running
 programs.</para>
      <para>Windows has compilers that target the virtual machine from a number
 of languages: Managed C++, JavaScript, Eiffel, Component Pascal, APL, Cobol,
 Perl, Python, Ruby, Scheme, Smalltalk, Standard ML, Haskell, Mercury and Oberon. </para>
      <para>Virtuoso is a CLR host.  It is responsible for initializing the runtime,
 defining the application domain (its runtime boundaries, security settings, etc),
 and executing user code within such domains.  Windows can be used
 as the development platform, a very developer friendly environment with
 a rich set of tools, but you  will not be restricted to Windows, .NET
 and IIS to run the assemblies produced.  Where .NET is not readily available
 or desired Virtuoso contains Mono, an open source re-implementation of
 Microsoft .NET, a vehicle making .NET cross-platform.  </para>
      <para>The CLR run time is a part of the Virtuoso process.  The Mono run time may be
run either as in-process or as out-of-process.  Hosted applications can make use of
the regular Virtuoso .net data provider to access Virtuoso SQL data and procedures.
 Microsoft ASPX files can also be run directly from Virtuoso either from
 the filesystem or WebDAV.  Each of these capabilities releases you from
 the Microsoft platforms without compromising your development platform.</para>
      <!-- You can create single-file or multifile assemblies using an IDE, such as Visual
Studio .NET, or the compilers and tools provided by the .NET Framework
SDK.  The simplest assembly is a single file that has a simple name and is
loaded into a single application domain. This assembly cannot be
referenced by other assemblies outside the application directory and
does not undergo version checking. To uninstall the application made up of
the assembly, you simply delete the directory where it resides. For many developers,
an assembly with these features is all that is needed to deploy an application.
-->

      <section xml:id="rthclrenvsetdotnet">
        <title>Environment Setup</title>
        <para>Follow the steps below to configure the CLR runtime environment
 with Virtuoso:</para>
        <orderedlist>
          <listitem>
            <formalpara>
              <title>Install .Net Framework SDK</title>
              <para>The .Net Framework can be downloaded from the Microsoft web site.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>Install virtclr.dll into the GAC</title>
              <para>The <computeroutput>virtclr.dll</computeroutput>

   library supplied with
  Virtuoso must be installed into the .Net 'Global Assembly Cache (GAC)'.</para>
            </formalpara>
            <para>.Net library components can be installed into the GAC using the command:
  <computeroutput>gacutil /i &lt;DLL&gt;</computeroutput>

  .  The gacutil utility is supplied
  with the .Net framework.  In this case we would use the command:</para>
            <programlisting>gacutil /i virtclr.dll</programlisting>
          </listitem>
          <listitem>
            <formalpara>
              <title>Register virtclr with COM</title>
              <para>The virtclr.dll library must be registered as COM object  using the
  'regasm' utility as follows:</para>
            </formalpara>
            <programlisting>regasm virtclr.dll</programlisting>
          </listitem>
          <listitem>
            <formalpara>
              <title>Install virt_http.dll into the GAC</title>
              <para>The <computeroutput>virt_http.dll</computeroutput>

   library supplied with
  Virtuoso must be installed into the .Net 'Global Assembly Cache (GAC)'.</para>
            </formalpara>
            <programlisting>gacutil /i virt_http.dll</programlisting>
          </listitem>
        </orderedlist>
        <note>
          <title>Note:</title>
          <para>The utilities gacutil and regasm are typically found in
 <computeroutput>%WINDIR%\Microsoft.NET\Framework\&lt;version&gt;</computeroutput>

 e.g. <computeroutput>C:\WINDOWS\Microsoft.NET\Framework\v1.0.3705.288</computeroutput>

  .</para>
        </note>
        <para>Failure to register the components successfully as described will generate
 "Virtuoso failed to initialize" messages.  The Virtuoso installer, however, should
 automatically register the components for you.</para>
        <para>Private assemblies must be deployed within the directory of the
 containing application and are found during runtime through a process called
 probing - a mapping from an assembly's identity to a file on disk that contains
 the manifest. </para>
        <para>By default, probing for private assemblies is done from the root directory
 (application base) of the calling application (Virtuoso in this case) and the subdirectories that
 follow naming conventions based on assembly name and culture.  You can
 customize this behavior by specifying a privatePath in your application's
 configuration file. The privatePath is a semi-colon delimited list of directories
 that the common language runtime will search for private assemblies.  These
 directory names are relative to the application base - they cannot point outside
 the application base. The directories in the privatePath will be searched after
 the application base itself.  The following configuration file adds a bin
 directory to the assembly search path: </para>
        <programlisting>
&lt;configuration&gt;
    &lt;runtime&gt;
        &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
            &lt;probing privatePath="bin"/&gt;
        &lt;/assemblyBinding&gt;
    &lt;/runtime&gt;
&lt;/configuration&gt;
</programlisting>
        <para>Configuration files are called:
 <computeroutput>&lt;application name&gt;.config</computeroutput>

  .  </para>
      </section>
      <section xml:id="rthclrdotnettest">
        <title>Testing the Virtuoso .NET Runtime Environment</title>
        <para>To test that you have successfully started the Virtuoso server with
 .NET CLR runtime support make a simple library, import the contained class
 into Virtuoso and call it.</para>
        <para>Using an text editor create a C# source file in the server
 root directory called sanity.cs, with the following contents:</para>
        <programlisting>
using System;

public class sanity
{
    public static string test(string  name) {
       return "Hello "+ name + ", from Virtuoso";
    }
}
</programlisting>
        <para>This sample needs to be compiled into bytecode assembly before it can
 be used.  Use a command prompt that is suitable set up to find .NET
 utilities in its path, the .NET Framework SDK installation provides a
 shortcut in the Start menu to a command prompt that is preconfigured.
 From the command prompt change directory to the Virtuoso server root
 containing the C# source file.</para>
        <programlisting>
C:\Program Files\OpenLink\Virtuoso 3.0\bin&gt;csc /target:library sanity.cs
Microsoft (R) Visual C# .NET Compiler version 7.00.9466
for Microsoft (R) .NET Framework version 1.0.3705
Copyright (C) Microsoft Corporation 2001. All rights reserved.
</programlisting>
        <para>Now this library must be introduce to the Virtuoso Server.  Using ISQL
 use the following commands to test the CLR:</para>
        <programlisting>
C:\Program Files\OpenLink\Virtuoso 3.0\bin&gt;isql 1112
Connected to OpenLink Virtuoso
Driver: 03.00.2315 OpenLink Virtuoso ODBC Driver
OpenLink Interactive SQL (Virtuoso), version 0.9849b.
Type HELP; for help and EXIT; to exit.
SQL&gt; DB..import_clr (vector ('sanity'), vector ('sanity'));

Done. -- 300 msec.
SQL&gt; select sanity::test('Rob');
callret
VARCHAR
______________________________________________

Hello Rob, from Virtuoso

1 Rows. -- 60 msec.
</programlisting>
        <para>Congratulations, you have proven that your Virtuoso server
 can run .NET classes.</para>
        <tip>
          <title>See Also:</title>
          <para>The Virtuoso Tutorials, which are installed with the Demo Virtuoso
 Server (port 1112), contains numerous samples further demonstrating the use
 of the CLR, .NET and Virtuoso.</para>
        </tip>
        <tip>
          <title>See Also:</title>
          <para>The <link linkend="createassembly">Create Assembly</link>

   Syntax</para>
          <para>The External Hosted <link linkend="createassembly">Create PROCEDURE</link>

   Syntax</para>
        </tip>
      </section>
    </section>
    <section xml:id="rthclrmono">
      <title>CLR &amp; Mono</title>
      <para>The Mono Project is an open development initiative sponsored by Ximian
 that is working to develop an open source, Unix version of the Microsoft .NET
 development and run time platform.  Its objective is to enable Unix developers to build
 and deploy cross-platform .NET Applications.  Likewise, this expands the
 capabilities of Windows programmers, this project opens .NET to non
 Windows platforms.  Mono will implement various Microsoft technologies that
 have now been submitted to the ECMA for standardization.</para>
      <para>The Goal is similar to that of Java, implementing a common virtual machine
 on multiple operating systems, however you are not restricted to one
 language.</para>
      <para>Like .NET, Mono contains a Common Language Infrastructure (CLI) virtual,
 machine that contains a class loader, Just-in-time compiler, and a garbage
 collecting runtime; a class library that can work with any language which
 works on the CLR; a compiler for the C# language.</para>
      <para>Windows has compilers that target the virtual machine from a number
 of languages: Managed C++, JavaScript, Eiffel, Component Pascal, APL, Cobol,
 Perl, Python, Ruby, Scheme, Smalltalk, Standard ML, Haskell, Mercury and Oberon.
 A single object system, threading system, class libraries, and garbage
 collection system can be shared across all these languages, the CLR.</para>
      <para>The CLR and the Common Type System (CTS) enables applications and
 libraries to be written in a collection of different languages that target
 the CLR byte code.  This means that you could define a class to do algebraic
 manipulation written in C#, that class can be reused from any other
 language that supports the CLI.  You could create a class in C#, subclass
 it in C++ and instantiate it in an Eiffel program.</para>
      <tip>
        <title>See Also:</title>
        <para>The <link linkend="createassembly">Create Assembly</link>

   Syntax</para>
        <para>The External Hosted <link linkend="createassembly">Create PROCEDURE</link>

   Syntax</para>
      </tip>
      <section xml:id="rthclrenvsetmono">
        <title>Environment Setup</title>
        <para>Ximian announced the launch of the Mono project, an effort to create
 an open source implementation of the .NET Development Framework.</para>
        <para>Follow the steps below to configure the CLR runtime environment
 with Virtuoso:</para>
        <orderedlist>
          <listitem>
            <formalpara>
              <title>Install Mono</title>
              <para>The Mono package is available from the
  <link xlink:href="http://www.go-mono.com/">Mono project home page</link>

   in the
  form of an RPM for Linux.  The source is also available.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>Make mscorlib.dll available to /usr/local/lib</title>
              <para>The mscorlib.dll is installed by Mono and needs to be symlinked from
  its default location to <computeroutput>/usr/local/lib</computeroutput>

  .</para>
            </formalpara>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="rthclrmonotest">
        <title>Testing the Virtuoso Mono Runtime Environment</title>
        <para>To test that you have successfully started the Virtuoso server with
 Mono CLR runtime support make a simple library, import the contained class
 into Virtuoso and call it.</para>
        <para>Using an text editor create a C# source file in the server
 root directory called sanity.cs, with the following contents:</para>
        <programlisting>
using System;

public class sanity
{
    public static string test(string  name) {
       return "Hello "+ name + ", from Virtuoso";
    }
}
</programlisting>
        <para>This sample needs to be compiled into bytecode assembly before it can
 be used.  Make sure you environment is configured to use Mono,
 change directory to the Virtuoso server root containing the C# source file.  Run:</para>
        <programlisting>
bash$ mcs /target:library sanity.cs
Compilation succeeded
</programlisting>
        <para>Now this library must be introduce to the Virtuoso Server.  Using ISQL
 use the following commands to test the CLR:</para>
        <programlisting>
C:\Program Files\OpenLink\Virtuoso 3.0\bin&gt;isql 1112
Connected to OpenLink Virtuoso
Driver: 03.00.2315 OpenLink Virtuoso ODBC Driver
OpenLink Interactive SQL (Virtuoso), version 0.9849b.
Type HELP; for help and EXIT; to exit.
SQL&gt; DB..import_clr (vector ('sanity'), vector ('sanity'));

Done. -- 300 msec.
SQL&gt; select sanity::test('Rob');
callret
VARCHAR
______________________________________________

Hello Rob, from Virtuoso

1 Rows. -- 60 msec.
</programlisting>
        <para>Congratulations, you have proven that your Virtuoso server
 can run .NET classes via Mono Runtime.</para>
        <tip>
          <title>See Also:</title>
          <para>The Virtuoso Tutorials, which are installed with the Demo Virtuoso
 Server (port 1112), contains numerous samples further demonstrating the use
 of the CLR, .NET, Mono and Virtuoso.</para>
        </tip>
        <tip>
          <title>See Also:</title>
          <para>The <link linkend="createassembly">Create Assembly</link>

   Syntax</para>
          <para>The External Hosted <link linkend="createassembly">Create PROCEDURE</link>

   Syntax</para>
        </tip>
      </section>
    </section>
    <!--
 -  
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -  
 -  Copyright (C) 1998-2024 OpenLink Software
 -  
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -  
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -  
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -  
 -  
-->

    <section xml:id="javaextvm">
      <title>Embedded Java VM API</title>
      <para>The Java VM is an embedded system within Virtuoso that allows the
  calling of class Java methods and getting class properties.  It uses the
  JAVA JNI API to interact with the JAVA VM.</para>
      <section xml:id="virtvsjvmthreads">
        <title>Correspondence Between Virtuoso &amp; Java VM Threads</title>
        <para>At maximum one Java VM will be started on demand. If a function from the
    Java VM API is called and no JVM is running, one will be started, as required.
    Since Virtuoso is multithreaded it requires JDK version 1.3 or above in order
    to make better use of it's multithreading support.  If the Java VM is already
    running the API VSEs attaches the current Virtuoso working thread, if not
    already attached, as a Java VM thread to the running VM.  The Virtuoso
    worker thread does not automatically detached itself from the Java VM after
    use, therefore, in order to prevent leaving redundant Virtuoso worker threads
    being left attached to the Java VM the
    <link linkend="fn_java_vm_detach"><function>java_vm_detach()</function></link>

    VSE should be used.</para>
        <para>The following require access to the Java VM:</para>
        <simplelist type="vert">
          <member>all Virtuoso JAVA PL API (JVM VSEs)</member>
          <member>allocating/deallocating/copying of the Virtuoso/PL Java VM class
      reference values.</member>
        </simplelist>
        <para>If no subsequent JVM VSEs are called after calling
    <function>java_vm_detach()</function>

  , the worker thread can still attach to
    the VM in order to deallocate or copy Java VM class reference values.
    In order to ensure that the worker thread is properly detached it is
    advisable to set all the variables that may hold Java VM class reference
    values to NULL, which deallocates their current value, before calling the
    <function>java_vm_detach()</function>

   JVM VSE.</para>
        <para>Attaching and detaching Virtuoso worker threads is marked as a debug
    level message in the Virtuoso Event log, so that these messages can be used to
    debug the process.</para>
      </section>
      <section xml:id="virtpljvmtypemapp">
        <title>Virtuoso/PL &lt;-&gt; Java VM Type Mapping Schema</title>
        <para>Since the Java language uses a different set of data types than
    Virtuoso a type mapping system has been established to allow the passage of data
    to and from Java.  All Java simple types are mapped to a corresponding
    Virtuoso type as follows:</para>
        <table>
          <title>Java - Virtuoso Data Type Mapping</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Java Type/Class</entry>
                <entry>Virtuoso Internal Type</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>boolean</entry>
                <entry>smallint</entry>
              </row>
              <row>
                <entry>char</entry>
                <entry>smallint</entry>
              </row>
              <row>
                <entry>double</entry>
                <entry>double precision</entry>
              </row>
              <row>
                <entry>float</entry>
                <entry>real</entry>
              </row>
              <row>
                <entry>int</entry>
                <entry>integer</entry>
              </row>
              <row>
                <entry>short</entry>
                <entry>integer</entry>
              </row>
              <row>
                <entry>long</entry>
                <entry>integer</entry>
              </row>
              <row>
                <entry>boolean</entry>
                <entry>smallint</entry>
              </row>
              <row>
                <entry>java.lang.String</entry>
                <entry>NVARCHAR</entry>
              </row>
              <row>
                <entry>java.util.Date</entry>
                <entry>DATETIME</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>All other Java objects are represented as a special Virtuoso value,
    which contains a reference to the Java object in the VM memory space.  When
    such a value is returned as a Virtuoso/PL return value or as a result set
    column, it calls the <function>java.lang.Object.toString()</function>

   method
    for the Java VM object it refers to and that result is returned to the
    calling client.</para>
        <para>Arrays are mapped to a Virtuoso vector of their elements.  The array
    handling routines are recursive, so each element may be a Java array or a
    scalar type.</para>
        <para>The above mappings are applied when converting Virtuoso/PL data to
    Java data as follows:</para>
        <simplelist type="vert">
          <member>method parameter values in java_call_method VSE</member>
          <member>method parameter values in java_new_object VSE</member>
          <member>property values in java_set_property VSE</member>
          <member>the instance parameters in
      java_call_method/java_get_property/java_set_property VSEs</member>
        </simplelist>
        <para>The above mappings are applied in the opposite direction
    (Java Data -&gt; Virtuoso/PL data) as follows:</para>
        <simplelist type="vert">
          <member>method return values in java_call_method VSE</member>
          <member>return value of the java_new_object VSE</member>
          <member>property values returned from java_get_property VSE</member>
        </simplelist>
      </section>
      <section xml:id="referencestojvminvpl">
        <title>References to Java VM Class Instances in Virtuoso/PL</title>
        <para>Java Class instances are represented as a Virtuoso/PL variable values
    using a Java VM Global Reference.  Each time such a Virtuoso/PL variable
    value is created or copied, it adds a Java VM Global Reference.  When it is
    freed, it removes the Java VM global reference, allowing the Java
    Garbage collector (GC) to free it.  Each of the API VSEs create a Java VM
    local frame upon it's start, and frees it upon exit. This allows for
    fast deallocation of the local objects created by mapping Virtuoso/PL native
    values to Java objects.</para>
      </section>
      <section xml:id="correctjavatype">
        <title>Specifying the Correct Java Type When Passing Values from Virtuoso/PL</title>
        <para>Each method parameter in the
    <function>java_new_object()</function>

  /<function>java_call_method()</function>

    can be either the value itself or a two-element vector.  When it is a
    two-element vector it's first element is the JNI type signature string,
    e.g.: for integer - I, for array of integers - [I], for
    java.lang.String - Ljava/lang/String.  The signature is important because
    the Java VM JNI API needs it in order to find the appropriate
    constructor/method/property.</para>
      </section>
      <section xml:id="virtjavabifs">
        <title>Virtuoso Java PL API VSEs</title>
        <para>The API consists of the following VSEs:</para>
        <simplelist type="vert">
          <member>
            <link linkend="fn_java_call_method">
              <function>java_call_method()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_set_property">
              <function>java_set_property()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_get_property">
              <function>java_get_property()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_load_class">
              <function>java_load_class()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_new_object">
              <function>java_new_object()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_vm_attach">
              <function>java_vm_attach()</function>
            </link>
          </member>
          <member>
            <link linkend="fn_java_vm_detach">
              <function>java_vm_detach()</function>
            </link>
          </member>
        </simplelist>
      </section>
      <section xml:id="jvmapisecurity">
        <title>Java Security</title>
        <para>Java classes are hosted in one of two modes:</para>
        <simplelist type="vert">
          <member>Restricted</member>
          <member>Unrestricted</member>
        </simplelist>
        <para>Java class Permissions are managed by security classes that fall into
  categories as follows listed with it managing class:</para>
        <simplelist type="vert">
          <member>File - java.io.FilePermission</member>
          <member>Socket - java.net.SocketPermission</member>
          <member>Net - java.net.NetPermission</member>
          <member>Security - java.security.SecurityPermission</member>
          <member>Runtime - java.lang.RuntimePermission</member>
          <member>Property - java.util.PropertyPermission</member>
          <member>AWT - java.awt.AWTPermission</member>
          <member>Reflect - java.lang.reflect.ReflectPermission</member>
          <member>Serializable - java.io.SerializablePermission</member>
        </simplelist>
        <para>Restricted classes are not allowed any of the above privileges.
	Virtuoso returns errors that are returned by the security manager if
	breaches in security are attempted by a hosted Java class.</para>
        <para>By default all Java classes are imported/created/hosted in restricted
  mode.  To create Java class based user defined types that are unrestricted
  you need to use create type syntax with UNRESTRICTED keyword.  The
  <link linkend="fn_import_jar"><function>import_jar()</function></link>

  function can also be used to import classes, its third optional parameter
  can be used to define the security mode.</para>
        <note>
          <title>Note:</title>
          <para>New behavior since Virtuoso 3.2 provides these two security modes
	defaulting to restricted.  Prior to this Java classes were hosted in
    unrestricted mode.</para>
        </note>
        <example xml:id="ex_javasecurity">
          <title>Java Security</title>
          <para>The class Write_file, shown below, will attempt to write to a file on
  the file system.  This class will be used to create a user defined type first
  in unrestricted mode and then in restricted mode to demonstrate how security
  exceptions are returned.</para>
          <para>Source of Write_file.java:</para>
          <programlisting>
import java.io.*;

public class Write_file
{
  public String write ()
    {
      String myFile = "foo";
      File f = new File(myFile);
      DataOutputStream dos;

      try
	{
	  dos = new DataOutputStream (new BufferedOutputStream(new FileOutputStream (myFile),128));
	  dos.writeBytes("ABC\n");
	  dos.flush();
	  dos.close();
	}

      catch (IOException ioe)
	{
	  System.out.println("writeFile: caught i/o exception");
	}

      return "OK";
    }
}
</programlisting>
          <para>Create the unrestricted type:</para>
          <programlisting>
create type "Write_file" language JAVA external name 'Write_file'
  unrestricted METHOD "write" ()
  returns nvarchar external type 'Ljava/lang/String;' external name 'write';
</programlisting>
          <para>Test calling the method:</para>
          <programlisting>
SQL&gt; select new Write_file().write();
callret
NVARCHAR
_________________________________________

OK
</programlisting>
          <para>Now we want to recreate the type in restricted mode, remembering to
  drop it first:</para>
          <programlisting>
drop type DB.DBA.write_file;

create type "Write_file" language JAVA external name 'Write_file'
  METHOD "write" ()
  returns nvarchar external type 'Ljava/lang/String;' external name 'write';
</programlisting>
          <para>Test calling the method:</para>
          <programlisting>
SQL&gt; select new Write_file().write();

*** Error 42000: [Virtuoso Driver][Virtuoso Server]JV001: Java exception
occurred : java.security.AccessControlException : access denied
(java.io.FilePermission foo write)
in  __udt_method_call:(BIF),
&lt;Top Level&gt;
at line 1 of Top-Level:
select new Write_file().write()
</programlisting>
          <para>Another way to import the above class is by use the
  <function>import_jar()</function>

   such as:</para>
          <programlisting>
import_jar (NULL, 'Write_file', 1) - will import java classes in unrestricted mode.
import_jar (NULL, 'Write_file') - will import java classes in restricted mode.
</programlisting>
        </example>
      </section>
    </section>
    <!--
 -
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -
 -  Copyright (C) 1998-2024 OpenLink Software
 -
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -
 -
-->

    <section xml:id="cinterface">
      <title>Virtuoso Server Extension Interface (VSEI) (C Interface)</title>
      <section xml:id="writingsqlcallablecfuncs">
        <title>Virtuoso Server Extension Interface (VSEI)</title>
        <para>The Virtuoso Server Extension Interface allows Virtuoso functionality
  to be extended by including new functions written in other languages
  such as C.  These new functions are SQL callable.</para>
        <para>These functions share the same C prototype and use
  Virtuoso internal APIs to do the following:</para>
        <simplelist type="vert">
          <member>Retrieve arguments.</member>
          <member>Assign values to output parameters.</member>
          <member>Compile and execute SQL/PL statements and fetch results.</member>
          <member>Signal SQL errors.</member>
          <member>Return values.</member>
        </simplelist>
        <para>A SQL-callable C function is called a Virtuoso Server Extension (VSE).
  These are external functions integrated into Virtuoso by linking their executable
  produced with a Virtuoso server in library format, rather than executable.
  VSEs were formally known as BIFs, which stood for Built-In Functions.
  Such functions must be exported using the <function>bif_define()</function>

  or <function>bif_define_typed()</function>

   C-functions when initializing the
  extended Virtuoso server.</para>
        <para>These functions will thereafter be invoked on server threads. The
  functions should be re-entrant and comply to some simple memory management
  conventions outlined below.</para>
        <para>
These functions may execute arbitrary C code and call arbitrary APIs,
to the extent these are compatible with the host operating system's threading model.
</para>
        <para>
Virtuoso VSEs can be debugged within the normal C debugger by either
starting Virtuoso under the debugger in foreground mode or by attaching the
debugger to a running process.
</para>
        <para>
Stack consumption should not be excessive: threads normally have 100K of stack
on 32 bit platforms.  The stack size may however be increased by settings in the virtuoso.ini file.
</para>
      </section>
      <section xml:id="sqlruntimeobjects">
        <title>SQL Run Time Objects</title>
        <para>
The Virtuoso Server Extension API introduces the following data types:
</para>
        <variablelist>
          <varlistentry>
            <term>box</term>
            <listitem>
              <para>
This is a run-time-typed block of memory which represents any SQL data type,
e.g.  number, string, array etc. Boxes have a type and length that are retrievable at run time
and can be allocated, freed and otherwise manipulated by functions appropriate to each type of box.
Boxes may form trees through use of heterogeneous arrays but should not form graphs.
</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>query_t</term>
            <listitem>
              <para>This is a compiled query, corresponding to a SQL statement or procedure compilation.
The 
              <parameter>query_t</parameter>
               is made from a SQL string and can thereafter be executed multiple times.
This is a read-only object, not affected by execution on any number of threads, analogously
to machine code not being affected by being executed.
</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>query_instance_t</term>
            <listitem>
              <para>This is a structure representing a query execution state. These are
created when executing a 
              <parameter>query_t</parameter>
              . This is analogous to
a stack frame of a C function.  It holds all relevant query state, such as
cursor positions, intermediate results, column values etc. This is passed to all
VSEs so they can have access to environment information such as current
transaction, current client etc. The query instance references the

              <parameter>query_t</parameter>
              .  As a rule, the query instance is specific to a thread.
A query instance can be relatively long lived in the case of a cursor, which may
live across multiple client-server message exchanges.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>state_slot_t</term>
            <listitem>
              <para>This is a part of 
              <parameter>query_t</parameter>
               that specifies or describes
a query time variable, column, parameter, intermediate result etc.  This is
analogous to an offset in a stack frame, it actually indexes a position inside a
query instance. Given the state slot and the instance, it is possible
to read or to set a value in the query state. Arguments of VSEs are passed as an
array of state.  Slots combined with the running query instance give the
arguments values, and can be used to set output parameters.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>local_cursor_t</term>
            <listitem>
              <para>When executing a select statement, the local cursor structure is
returned for accessing the result set rows. This is always a forward-only cursor.
This can be advanced, column values may be accessed and the cursor may be closed.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="memmanrules">
        <title>Memory Management Rules</title>
        <para>
All state slots in a query have distinct values.  With the exception of a reference
parameter, no value is referenced twice.  All state slot values can therefore be
recursively freed independently of each other.
</para>
        <para>
If a VSE returns data, this data must always be new, i.e. allocated inside the
VSE and may not be a copy of or include any of the arguments as a substructure.
All return values and arguments must be legitimate boxes and may not share a structure.
</para>
      </section>
      <section xml:id="servermainfunction">
        <title>Server Main Function</title>
        <para>
The server main function for a customized Virtuoso server has the following format:
</para>
        <programlisting>
static void (*old_ddl_hook) (client_connection_t *cli) = NULL;

static void
ddl_hook (client_connection_t *cli)
{
  if (old_ddl_hook)
    old_ddl_hook (cli);

  /* DDL code (depending on the server being fully initialized
    (ex: create table) ) goes here */
}

static void
init_func (void)
{
  old_ddl_hook = set_ddl_init_hook (ddl_hook);
  /* initialization code (prerequisite for server initialization
     (bif_define, unrelated init code) goes here */
}

int
main (int argc, char *argv[])
{
  VirtuosoServerSetInitHook (init_func);
  return VirtuosoServerMain (argc, argv);
}
</programlisting>
        <para>
There are three phases to custom code initialization:
</para>
        <simplelist type="vert">
          <member>execution of the <function>main()</function>

   function</member>
          <member>execution of the <function>init_func()</function>

   function</member>
          <member>execution of the <function>ddl_hook()</function>

   function</member>
        </simplelist>
        <para>The <function>init_func()</function>

   function is called before any server
initialization functions are called.  This is typically a place for defining new VSEs,
allocation of synchronization objects (since the server does not have any threads yet),
and/or custom code initialization not related to Virtuoso.  Here, the
<function>set_ddl_init_hook()</function>

   should be called also, if it exists,
to register the <function>ddl_hook()</function>

   callback function.
</para>
        <note>
          <title>Note:</title>
          <para>The <function>old_ddl_hook()</function>

   mechanism -
this allows queuing of the ddl_hooks.</para>
        </note>
        <para>The <function>ddl_hook()</function>

   function is called during normal
startup just before the roll forward, but after the server's internal structure has
been initialized.  This is typically a place to execute SQL statements to initialize
the extension.  The variable <parameter>client_connection_t *</parameter>

is passed to the function to provide the client connection that should
be used for SQL execution.</para>
        <para>The <function>main()</function>

   function can call
<function>VirtuosoServerSetInitHook()</function>

   if there is any
Virtuoso-related initialization to be performed, and should then call the
<function>VirtuosoServerMain()</function>

   function to start the
Virtuoso server.  The <function>VirtuosoServerMain()</function>

   function
will return control after the server has been shut down.</para>
      </section>
      <section xml:id="compilingandlinking">
        <title>Compiling &amp; Linking</title>
        <para>
The files should be compiled for the multi-threaded environment appropriate to the
operating system and should be linked accordingly e.g.
<computeroutput>-lm</computeroutput>

  , <computeroutput>-ldl</computeroutput>

  .</para>
        <para>The Virtuoso distribution contains the following libraries/object files:</para>
        <itemizedlist>
          <listitem>
            <formalpara>
              <title>libvirtuoso-* libraries/object files</title>
              <para>The Virtuoso engine.  The suffix denotes the kind of remote and threading
  support : -iodbc for iODBC, -udbc for UDBC, -t for native threads, -f for fiber
  threads.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>c_javavm object file</title>
              <para>the Virtuoso Java VM Integration file (no main function). This is the
  file to be linked in if the custom code executable needs to have Java VM
  support. To initialize the Java VM integration the C function
  <function>void bif_init_func_javavm (void)</function>

   should be called from the
  <function>VirtuosoServerSetInitHook</function>

   hook.  This file references
  the <computeroutput>libjvm</computeroutput>

   library from the Java JRE, hence,
  should also be appended to your linker options.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>c_bif_server_php object file</title>
              <para>The Virtuoso PHP integration support library.  This is the file to be
  linked in if the custom code executable needs to have the PHP support built
  in.  To initialize the PHP engine integration the C++ function
  <function>void init_func_php (void)</function>

   should be called from
  the <function>VirtuosoServerSetInitHook</function>

   hook.  Note that this file
  is a C++ object file and needs to be linked in accordingly.  This file
  references the libphp4 library.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>basec object file</title>
              <para>The Virtuoso .NET CLR Integration file.  This is the file to be linked
  in if the custom code executable needs to have the .NET CLR integration built
  in.  This is a C file.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>c_dotnet object file</title>
              <para>The Virtuoso .NET CLR Integration file.  This is the file to be linked in
  if the custom code executable needs to have the .NET CLR integration
  (and nothing but) built in.  This is a C++ file.  Binaries using this file
  should initialize the .NET CLR support by calling the C++ function
  <function>void bif_init_func_clr (void)</function>

   (defined in the basec object
  file) from the <function>VirtuosoServerSetInitHook</function>

   hook.  In order
  for the .NET CLR support to work correctly the
  <computeroutput>::CoInitialize</computeroutput>

   Win32 COM API should also be
  called before the <function>VirtuosoServerMain</function>

   call.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>sql_code_javavm object file</title>
              <para>This contains the DDL definitions for the Java VM support.  Executables
  using that binary should call the <function>sqls_define_javavm</function>

  function in their DDL init hook.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>sql_code_xslt object file</title>
              <para>This contains the DDL definitions of the XSLT stylesheets used in the
  Java VM &amp; CLI support.  Executables using that binary should call the
  <function>sqls_define_xslt</function>

   function in their DDL init hook.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>sql_code_clr object file</title>
              <para>This contains the DDL definitions for the .NET CLR integration support.
  Executables using that binary should call the <function>sqls_define_clr</function>

  function in their DDL init hook.</para>
            </formalpara>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="funcsbycat">
        <title>Functions by Category</title>
        <section xml:id="genboxfuncs">
          <title>General Box Functions</title>
          <para>The box, usually marked with the caddr_t data type is the basic representation
of any SQL data in Virtuoso.  All boxes have a run time data type, with a name
beginning with <computeroutput>DV_</computeroutput>

  .  All boxes have a 3 byte
run time length which allows for up to 16 MB of contiguous array size in SQL data.</para>
          <para>The further interpretation of the content of the box is determined by the
type tag.  The length is always an exact byte length, although the actual length
is rounded up to the next suitably aligned value.  The length and tag of a box
must never be changed while the box is allocated but the content is freely
writable.  The tag and length reside immediately under the pointer of the box,
so that a box, with the appropriate type cast will pass as a C array or string.</para>
          <para>Numbers are generally represented as boxes.  There is an exception for
small integers, which are always distinguishable from pointers.  Thus the range
from -10000 to 10000 are not allocated as boxes holding the value but can be
passed directly.  This is hidden however and the programmer need not be
concerned about this except sometimes when debugging.</para>
          <para>The byte order in boxes depends on the platform.</para>
          <para>The most important types are:</para>
          <simplelist type="vert">
            <member><emphasis>DV_SHORT_STRING</emphasis>

   -  The box contains a null
    terminated string of char. The box length is 1 + the count of characters,
    including the final 0 in the count.</member>
            <member><emphasis>DV_LONG_STRING</emphasis>

   - same as DV_SHORT_STRING.</member>
            <member><emphasis>DV_LONG_INT, TAG_BOX</emphasis>

   - The box is sizeof (long)
    long, with the long as element 0, in the appropriate byte order.</member>
            <member><emphasis>DV_SINGLE_FLOAT</emphasis>

   - sizeof (float) bytes,
    containing the float.</member>
            <member><emphasis>DV_DOUBLE_FLOAT</emphasis>

   - sizeof (double) bytes,
    contains the double.</member>
            <member><emphasis>DV_NUMERIC</emphasis>

   - opaque, contains a decimal floating
    point. The <function>numeric_t</function>

   functions can be used, see
    appropriate documentation.</member>
            <member><emphasis>DV_BIN</emphasis>

   - Binary string, no terminating 0
    counted in the length.</member>
            <member><emphasis>DV_DATETIME</emphasis>

   - datetime, opaque, dt_ functions
    can be used, see appropriate documentation.</member>
            <member><emphasis>DV_BLOB_HANDLE</emphasis>

   - Blob handle, opaque but
    convertible to string if short enough.</member>
            <member><emphasis>DV_ARRAY_OF_POINTER</emphasis>

   - Heterogeneous array,
    sizeof (caddr_t) * n_elements, first all elements are box pointers. The
    length is in bytes, so divide by sizeof (caddr_t).</member>
            <member><emphasis>DV_DB_NULL</emphasis>

   - a box of 0 bytes (header only),
    represents the SQL NULL value.</member>
          </simplelist>
        </section>
        <section xml:id="boxfunctions">
          <title>Box Functions</title>
          <para><funcsynopsis><funcprototype xml:id="fproto_dk_alloc_box"><funcdef>box_t <function>dk_alloc_box</function>

  </funcdef><paramdef choice="opt">uint32 <parameter>bytes</parameter>

  </paramdef><paramdef choice="opt">int <parameter>tag</parameter>

  </paramdef></funcprototype></funcsynopsis><function>dk_alloc_box()</function>

   allocates a box of the given size
and type.  The initial contents are undefined.</para>
          <para>
            <funcsynopsis>
              <funcprototype xml:id="fproto_dk_free_box">
                <funcdef>int <function>dk_free_box</function>

  </funcdef>
                <paramdef choice="opt">box_t <parameter>box</parameter>

  </paramdef>
              </funcprototype>
            </funcsynopsis>
          </para>
          <para><function>dk_free_box()</function>

   frees a box allocated by
<function>dk_alloc_box()</function>

  .  The argument may not be any other pointer.</para>
          <para>
            <funcsynopsis>
              <funcprototype xml:id="fproto_dk_free_tree">
                <funcdef>int <function>dk_free_tree</function>

  </funcdef>
                <paramdef choice="opt">box_t <parameter>box</parameter>

  </paramdef>
              </funcprototype>
            </funcsynopsis>
          </para>
          <para><function>dk_free_tree()</function>

   is like <function>dk_free_box()</function>

but will free recursively, following through DV_ARRAY_OF_POINTER boxes.</para>
          <para>
            <funcsynopsis>
              <funcprototype xml:id="fproto_box_length">
                <funcdef>uint32 <function>box_length</function>

  </funcdef>
                <paramdef choice="opt">box_t <parameter>box2</parameter>

  </paramdef>
              </funcprototype>
            </funcsynopsis>
          </para>
          <programlisting>
#define box_tag(box) \
	(*((dtp_t *) &amp;(((unsigned char *)(box))[-1])))
</programlisting>
          <para>
These return the length and the tag of a box.
</para>
          <funcsynopsis>
            <funcprototype xml:id="fproto_unbox">
              <funcdef>long <function>unbox</function>

  </funcdef>
              <paramdef choice="opt">box_t <parameter>n</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_num">
              <funcdef>box_t <function>box_num</function>

  </funcdef>
              <paramdef choice="opt">long <parameter>n</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_dv_short_string">
              <funcdef>box_t <function>box_dv_short_string</function>

  </funcdef>
              <paramdef choice="opt">char *<parameter>string</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_double">
              <funcdef>box_t <function>box_double</function>

  </funcdef>
              <paramdef choice="opt">double <parameter>d</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_float">
              <funcdef>box_t <function>box_float</function>

  </funcdef>
              <paramdef choice="opt">float <parameter>f</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <programlisting>
#define unbox_num(n) unbox(n)
#define unbox_float(f) (*((float *)f))
#define unbox_double(f) (*((double *)f))
#define unbox_string(s) ((char *)s)
</programlisting>
          <para>The above functions and macros convert between C data types and boxes.
<function>box_dv_short_string()</function>

   takes a
<computeroutput>char *</computeroutput>

   to any null terminated string and
allocates a string box of appropriate size.  This itself looks like a null
terminated string but has the box header with the run time length and type
under the pointer.</para>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_copy">
              <funcdef>box_t <function>box_copy</function>

  </funcdef>
              <paramdef choice="opt">box_t <parameter>box</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <para><function>box_copy()</function>

   returns an identical size box with the
same type and contents.</para>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_copy_tree">
              <funcdef>box_t <function>box_copy_tree</function>

  </funcdef>
              <paramdef choice="opt">box_t <parameter>box</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <para><function>box_copy_tree()</function>

   performs a recursive copy, traversing
<computeroutput>DV_ARRAY_OF_POINTER</computeroutput>

   references.</para>
          <funcsynopsis>
            <funcprototype xml:id="fproto_box_equal">
              <funcdef>int <function>box_equal</function>

  </funcdef>
              <paramdef choice="opt">box_t <parameter>b1</parameter>

  </paramdef>
              <paramdef choice="opt">box_t <parameter>b2</parameter>

  </paramdef>
            </funcprototype>
          </funcsynopsis>
          <para>Given two arbitrary boxes, returns true if they are recursively equal.</para>
          <example xml:id="boxexamples">
            <title>Box Examples</title>
            <para>Below is the code for box_copy_tree:</para>
            <programlisting>
box_t
box_copy (box_t box)
{
  dtp_t tag;
  uint32 len;
  box_t copy;

  if (!IS_BOX_POINTER (box))
    return box;

  tag = box_tag (box);
  if (box_copier[tag])
    return (box_copier[tag] (box));
  len = box_length (box);
  copy = dk_alloc_box (len, tag);
  memcpy (copy, box, (uint32) len);
  return copy;
}
</programlisting>
            <programlisting>
box_t
box_copy_tree (box_t box)
{
  box_t *copy;
  dtp_t tag;

  if (!IS_BOX_POINTER (box))
    return box;

  tag = box_tag (box);
  copy = (box_t *) box_copy (box);
  if (tag == DV_ARRAY_OF_POINTER || tag == DV_LIST_OF_POINTER)
    {
      uint32 inx, len = BOX_ELEMENTS (box);
      for (inx = 0; inx &lt; len; inx++)
	copy[inx] = box_copy_tree (((box_t *) box)[inx]);
    }

  return (box_t) copy;
}
</programlisting>
          </example>
          <note>
            <title>Note:</title>
            <para>The <function>IS_BOX_POINTER</function>

   check at the start will detect
the unboxed, 'bare' small integers which are actually not allocated
and can be returned by value.  Only then can box_tag be used to find the type.</para>
            <para>The DV_TYPE_OF macro should be used instead of box_tag when the type
is unknown to avoid de-referencing a small integer.</para>
            <para>Also note <function>BOX_ELEMENTS</function>

  , which is
box_length () / sizeof (caddr_t).  This is practical for iterating over arrays.</para>
          </note>
          <tip>
            <title>See Also</title>
            <para>The VSEI Functions

  .</para>
          </tip>
        </section>
      </section>
      <section xml:id="bifdefs">
        <title>VSEI Definition</title>
        <programlisting>
typedef caddr_t (*bif_t) (caddr_t *qst, caddr_t *error_return, state_slot_t ** arguments);
void bif_define (char *name, bif_t bif);
void bif_define_typed (char * name, bif_t bif, bif_type_t *bt);
</programlisting>
        <para>
These functions associate a function pointer to a VSE name.
The typed variant allows associating a value type used when inferring SQL
meta-data if the result is returned to a client.  The type can be one of the
following externs:</para>
        <simplelist type="vert">
          <member>

            extern <parameter>bif_type_t</parameter>

   bt_varchar;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_any;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_integer;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_double;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_float;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_numeric;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_convert;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_timestamp;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_time;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_date;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_datetime;
          </member>
          <member>
            extern <parameter>bif_type_t</parameter>

   bt_bin;

          </member>
        </simplelist>
        <para>If a VSE accesses indexes either by its own internal code or by executing
Virtuoso/PL statements, there becomes a potential for deadlocks.  To prevent
deadlocks, the Virtuoso/PL compiler must be informed of potential index usage inside
the VSE.  Special deadlock-safe code can be created for its needs.  The
<function>bif_set_uses_index()</function>

   function should be used after
<function>bif_define()</function>

   or <function>bif_define_typed()</function>

in such cases.</para>
        <!-- programlisting>
void bif_set_uses_index (bif_t bif);
</programlisting -->

        <para>The potential for deadlocking is always present if the VSE
executes Virtuoso/PL code or uses XPath/XSLT functions.  Other functions
of Virtuoso's C interface are deadlock-safe since they perform no database access.</para>
      </section>
      <section xml:id="sqlexception">
        <title>SQL Exceptions</title>
        <programlisting>
caddr_t srv_make_error (char *code, char *msg);
void sqlr_error (char *code, char *msg,...);
void sqlr_resignal (caddr_t err);
</programlisting>
        <para>
An error object is a three element array of type
<computeroutput>DV_ARRAY_OF_POINTER</computeroutput>

  , consisting of the number
3, the SQL state and the message.
The control flow in case of errors signalled inside VSEs is a longjmp to an outer context,
typically that of the calling stored procedure or top level query.  The condition is there
handled or sent to the next level up, ultimately to the ODBC, JDBC or Web client.
Executing a SQL statement inside a VSE always returns and never exits the VSE by longjmp.
Thus the VSE gets a first look at all SQL errors caused by statements executed by it.
</para>
        <para>
sqlr_error is the normal function for signaling a SQL state.  It takes a 5 character
SQL state, a printf format string and optional arguments, a la printf.
</para>
        <para>
sqlr_resignal is used to throw a condition to the next level handler.
This is typically done when executing a query which returns an error and
the error is sent up to the caller of the VSE.
</para>
        <para>
srv_make_error makes the error structure.  The expression
</para>
        <para>
sqlr_resignal (srv_make_error ("12345", "message"));
is equivalent to sqlr_error ("12345", "message");
</para>
        <note>
          <title>Note</title>
          <para>srv_make_error does not take the printf-type arguments.</para>
        </note>
        <para>
By convention a NULL pointer indicates no error.
sqlr_resignal (NULL) is an error.
</para>
        <para>
The macros:
</para>
        <programlisting>
#define ERR_STATE(err)  (((caddr_t*) err)[1])
#define ERR_MESSAGE(err)  (((caddr_t*) err)[2])
</programlisting>
        <para>
can be used to read an error returned by a statement.
</para>
      </section>
      <section xml:id="execingsql">
        <title>Executing SQL</title>
        <programlisting>
query_t * sql_compile (char *string2, client_connection_t * cli,
				caddr_t * err, int store_procs);
void qr_free (query_t * qr);

client_connection_t * qi_client (caddr_t * qi);
</programlisting>
        <para>
These functions allow executing SQL from VSEs.
First the SQL statement needs to be compiled with sql_compile. The statement may take
value parameters and may be a DDL or DML statement, including select, update,
procedure call, table creation etc.
</para>
        <para>
The query_t returned can be used multiple times on any number of simultaneous threads.
if an application repeatedly performs
the same queries the text can be compiled once and reused at infinitum.
</para>
        <para>
qr_free will free a query returned by sql_compile.
</para>
        <example>
          <title>Example</title>
          <programlisting>
{
  caddr_t err = NULL;
  query_t * qr  = sql_compile ("select * from SYS_USERS", qi_client (qst), &amp;err, 0);
  ...
  if (err)
  exit (-1);
  qr_free (qr);
}
</programlisting>
        </example>
        <programlisting>
caddr_t qr_rec_exec (query_t * qr, client_connection_t * cli,
    local_cursor_t ** lc_ret, query_instance_t * caller, stmt_options_t * opts,
    long n_pars, ...);
</programlisting>
        <para>
Once a query is compiled it can be executed and fetched.  This function executes
a query in the context of a VSE.  The execution is on behalf of the same
user and in the same transaction as the VSE.  This is only possible in the
context of a VSE, not at top level in the main program, for example.
</para>
        <para>
The first argument is the compiled query to execute.
The second is the client connection, obtained by qi_client from the qst argument of the VSE.
The lc_ret, if non NULL will get a be set to a newly allocated local_cursor_t * that allows
fetching rows from the result set. This only applies to a select statement.
The caller is the qst argument of the VSE,
The opts can be NULL.
The n_args is the count of query parameters, 0 if no parameters are passed.
</para>
        <para>
The return value is an error, suitable for sqlr_resignal.  A NULL value means success.
</para>
        <para>
It should be double-checked if the query access or potentially may access any tables or indexes.
If it may do this, the VSE must be described as deadlock-unsafe by
calling bif_set_uses_index() after bif_define() or bif_define_typed().
If qr_rec_exec access any tables or views, and the call of VSE from Virtuoso/PL
code is compiled as deadlock-safe, the whole server may be halted.
</para>
        <para>
If parameters are passed, a group of 3 actual parameters follows for each ? in the
query being executed.  In each such group the first is the name of the parameter, of
the form ":n", where n is the position of the parameter, starting at 0, so ":0"
corresponds to the 1st ? and ":11" to the 12th.
The second in the group of 3 is the value, usually a box pointer.
The third is the type, one of QRP_INT, QRP_STRING or QRP_RAW.
</para>
        <para>
QRP_INT means that the value will be converted to a box as by box_num.
QRP_STRING means that the value will be converted to a string as by box_dv_short_string.
In either case the value is allocated and freed as part of the execution.
QRP_RAW means that an arbitrary box is passed as is.  If so, this box will be freed in the
process and MUST NOT BE REFERENCED AGAIN in the VSE.
if the statement is a select, lc_ret should be specified and should be the address of a
local_cursor_t * variable, where the cursor can be returned.
</para>
        <programlisting>
long lc_next (local_cursor_t * lc);
caddr_t lc_nth_col (local_cursor_t * lc, int n);
void lc_free (local_cursor_t * lc);
</programlisting>
        <para>
These functions allow reading through a result set.
The local_cursor_t * must have come from qr_rec_exec.
</para>
        <para>
lc_next  will move the cursor one row forward.  The first call after the exec places the cursor
on the first row. A 0 return value indicates that the cursor is at end.  if 0 is returned at the
first call, the result set had zero rows.
The data member lc_error may be set and should be checked after calls to this function.
See examples. The value will be suitable for sqlr_resignal if copied (box_copy_tree).
</para>
        <para>
The lc_nth_col returns the value of the nth column of the current row. The index is 0 based.
The value is an arbitrary box pointer and is READ ONLY, to be copied (box_copy_tree) if the
application needs to keep it around.  The value will stay readable until the next lc_next or
lc_free.  Use DV_TYPE_OF et al to determine the type of the value.
</para>
        <para>
lc_free frees the cursor and any resources associated to it.
This has no effect on the transaction.
</para>
        <para>
The bif_my_select function returns an array with one element for each row of the SYS_KEYS table.
The rows are themselves arrays containing the column values.
</para>
      </section>
      <section xml:id="langfuncapi">
        <title>Adding New Languages And Encodings Into Virtuoso</title>
        <para>
There are too many languages to be able to support them all by default so
Virtuoso is user extensible in this respect.
The built-in 'x-any' language supports most languages to a degree,
but it is not the optimum solution for some specific languages or if
you want to perform a words' normalization to make text search more effective.
To make Virtuoso extensible,
language-specific functions are organized into <emphasis>language handlers</emphasis>

  , and handlers are
organized in hierarchical trees.  Every handler contains pointers to such functions as "count
words in given string", "call given callback once for every word in the string" etc.</para>
        <para>
XML documents and SQL procedures may identify languages by their
names, for example by value of <emphasis>xml:lang</emphasis>

   attribute,
<parameter>content_language</parameter>

   argument of
built-in functions, or by <parameter>__lang</parameter>

   option etc...
Every language handler defines up to two names of the language it supports, one matching ISO 639
regulations (e.g. 'en'), and one matching RFC 1766 (e.g. 'en-UK').
When Virtuoso finds a match to the language name specified, it searches through
the an internal hash-table.  If the name is unknown, the 'x-any' handler
will be returned as a default.</para>
        <para>
Custom language handlers should contain a pointer to a more generic handler, e.g. to the handler,
Handler may have NULLs stored instead of pointers to required functions, these NULLs will be
replaced with pointers to generic handler's functions automatically when the custom handler will be
activated.</para>
        <tip>
          <title>See Also:</title>
          <para>
            <link linkend="fn_lh_get_handler">lh_get_handler</link>
          </para>
          <para>
            <link linkend="fn_lh_load_handler">lh_load_handler</link>
          </para>
        </tip>
        <para>
There are two trees of language handlers in current version of Virtuoso. "Main"
tree starts from 'x-any' root and contains handlers of languages used in documents,
another tree starts from 'x-ftq-x-any' root contains handlers of
Free Text query ('ftq') languages.  The difference is in handling of wildcard characters:
query string 'hello, wo*ld' consists of two "words", 'hello' and 'wo*ld', and
'x-ftq-x-any' will properly locate them, but 'x-any' handler will report three words --
'hello', 'wo' and 'ld', because it knows nothing about special meaning of '*' in query
strings.  That is why every handler may contain a pointer to a handler of its own query language.</para>
        <para>
In addition to plain language handlers, it's possible to add handlers of "encoded language"
They are useful if you have large number of documents in some particular encoding and speed of
free text indexing is critical for your applications.  While usual handlers deal with Unicode data,
and it requires data to be decoded before processing, functions of "encoded language"
handler may accept buffers of encoded text, eliminating decoding.</para>
        <tip>
          <title>See Also:</title>
          <para>
            <link linkend="fn_elh_get_handler">elh_get_handler</link>
          </para>
          <para>
            <link linkend="fn_elh_load_handler">elh_load_handler</link>
          </para>
        </tip>
        <para>
The OpenLink Virtuoso Server distribution contains sources of sample language handler for 'en-UK' language.
The difference between 'x-any' handler and this one is in handling of abbreviations and numbers.
'en-UK' handler will read phrase '$3.54 per sq.inch.' as the sequence of words '3.54', 'per' and 'sq.inch',
instead of sequence '54', 'per', 'sq' and 'inch' that 'x-any' will read.  The generic 'x-any' handler
has no specific rules for dealing with the "decimal point" because in many scripts
"decimal comma" is used, thus '3.54' will be processed as pair of words '3' and '54',
but '3' will be ignored in many cases as noise word due to its 1-character length.</para>
        <para>
In addition to the language extension interface, Virtuoso provides an <emphasis>eh_load_handler</emphasis>

   function
to add new encodings, but it should be used solely for multi-character encodings which cannot be supported through
the usual Virtuoso <link linkend="internationalization">International Character Support</link>

  .
If an encoding was created by the <link linkend="fn_charset_define">CHARSET_DEFINE</link>

   function,
Virtuoso can build special lookup tables for very fast text translation from Unicode to the
encoding, thus you are not likely to gain in performance by writing your own C code, but some applications will
know nothing about your encoding because they will check only the SYS_CHARSETS system table.</para>
      </section>
    </section>
    <!--
 -  
 -  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
 -  project.
 -  
 -  Copyright (C) 1998-2024 OpenLink Software
 -  
 -  This project is free software; you can redistribute it and/or modify it
 -  under the terms of the GNU General Public License as published by the
 -  Free Software Foundation; only version 2 of the License, dated June 1991.
 -  
 -  This program is distributed in the hope that it will be useful, but
 -  WITHOUT ANY WARRANTY; without even the implied warranty of
 -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 -  General Public License for more details.
 -  
 -  You should have received a copy of the GNU General Public License along
 -  with this program; if not, write to the Free Software Foundation, Inc.,
 -  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 -  
 -  
-->

    <section xml:id="vseplugins">
      <title>VSEI Plugins</title>
      <para>Virtuoso functionality can be enhanced through external libraries by
loading shared objects or DLLs.  The new functions are written in a language of
the developer's choice and compiled to produce a shared library appropriate to the operating
system.  The path to the shared library must be declared in the Virtuoso INI
file and the server restarted before it can be used.</para>
      <para>The Virtuoso INI file uses a [Plugins] configuration section for listing
shared libraries for the server to load upon startup.  The layout is as
follows:</para>
      <programlisting>
[Plugins]
LoadPath = &lt;module path&gt; (example : /home/virtuoso/hosting)
Load1 = &lt;module type&gt;, &lt;module name&gt; (example : hosting_perl.so)
Load2 = &lt;module type 2&gt;, &lt;module name 2&gt;
..
LoadN = &lt;module type N&gt;, &lt;module name N&gt;
</programlisting>
      <para>Virtuoso reads the Load1, Load2, ... LoadN lines from the [Plugins]
section and attaches them according to their type. </para>
      <para><computeroutput>&lt;module path&gt;</computeroutput>

   is the directory
containing shared modules for use with Virtuoso.  (e.g. <computeroutput>/home/virtuoso/hosting</computeroutput>

  )</para>
      <para><computeroutput>&lt;module type&gt;</computeroutput>

   specifies the type of
module that is to be loaded, and hence how Virtuoso is to use it.  So far only
the "Hosting" type exists.  </para>
      <para><computeroutput>&lt;module name&gt;</computeroutput>

   is the file name of
the modules shared library or object.
(e.g. <computeroutput>hosting_perl.so</computeroutput>

  )</para>
      <para>The "Hosting" type defines entry points for initialization of the runtime
hosting environment, destruction of the user environment and execution of a
file or string containing commands in the hosted language.  It also returns a
list of file extensions that it is capable of processing.  Virtuoso
dynamically defines memory-resident (no disk image) HTTP server handlers for
each specified type.  For example, the Perl hosting plugin supports 'pl'
extension.  Hence, upon initialization of the hosting plugin, Virtuoso defines
the <function>__http_handler_pl(..)</function>

    function according to the API
for file type handlers in the Virtuoso HTTP server.  With this handler in place,
each hit on a .pl file (file system or WebDAV) with appropriate execute
permissions will cause the HTTP server to execute the code within it and return
the result instead of simple the file contents.</para>
      <para>The handler will call the __hosting_http_handler VSE with a special set
of parameters to represent the HTTP environment correctly.</para>
      <para>There's a VSE to call each of the hosting modules:</para>
      <para>
        <code>__hosting_http_handler (
     in <parameter>extension</parameter>

   varchar,
     in <parameter>content</parameter>

   varchar,
     [in <parameter>params</parameter>

   varchar, ]
     [in <parameter>lines</parameter>

   any, ]
     [inout <parameter>filename_head_ret</parameter>

   varchar, ]
     [in <parameter>options</parameter>

   any, ]
     [out <parameter>diag_ret</parameter>

   varchar]) returns varchar</code>
      </para>
      <para>such that:</para>
      <variablelist>
        <varlistentry>
          <term>extension</term>
          <listitem>
            <para>Selects plugin by supported extension handler.  e.g. pass 'pl' for the perl plugin.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>content</term>
          <listitem>
            <para>If &lt;filename_head_ret&gt; is NULL or unspecified this
   will be the name of the file containing the code to execute in the hosted
   environment, otherwise this will be program code to execute as a string.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>params</term>
          <listitem>
            <para>(optional) A string containing the HTTP parameters as encoded
   in the HTTP request body.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>lines</term>
          <listitem>
            <para>(optional) A vector (array) containing the HTTP request headers, in
   the same format as those passed to VSPs.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>filename_head_ret</term>
          <listitem>
            <para>(optional) On input this is the "name" to put on the command
   text passed in &lt;content&gt;.  If this is NULL it means that &lt;content&gt;
   holds the path and filename containing the commands.  On output this contains
   the HTTP headers of the HTTP response generated by the plugin, if any and
   in HTTP mode.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>options</term>
          <listitem>
            <para>(optional) A vector holding name/value pairs of strings
   passed as options to the plugin.  The Perl plugin sets
   the other options as environment variables before calling the perl code.</para>
            <para>There is a "<computeroutput>__VIRT_CGI</computeroutput>

  " =
   "<computeroutput>0</computeroutput>

  "/"<computeroutput>1</computeroutput>

  " option
   to control whether the plugin operates in HTTP mode
   (<computeroutput>__VIRT_CGI=1</computeroutput>

  )  i.e. implements the CGI
   interface and treats the output as an HTTP response.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>diag_ret</term>
          <listitem>
            <para>(optional) Returns various diagnostics messages returned
   while the code is running if any.  The perl plugin sets this to the collected
   STDERR messages.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The function will return a varchar containing the HTTP body if in HTTP mode
(<computeroutput>__VIRT_CGI = 1</computeroutput>

  ) or the messages printed to
STDOUT.</para>
      <para>Virtuoso will normally call to memory each plugin as required, and expel
it when finished.  This behavior can be controlled by the INI file parameter:</para>
      <programlisting>
[HTTPServer]
PersistentHostingModules = 1/0 default 0
</programlisting>
      <para>Setting <computeroutput>PersistentHostingModules</computeroutput>

   to "1"
prevents Virtuoso from removing the interpreters from the HTTP threads after
each request.</para>
      <example xml:id="ex_plugshostingsharedobjects">
        <title>Using the Perl Plugin</title>
        <para>Executing Perl code directly:</para>
        <programlisting>
select __hosting_http_handler ('pl', 'print "hello world"; ', '', vector (), 'helloworld.pl');
</programlisting>
        <programlisting>
returns : hello world
</programlisting>
        <para>Executing a perl script file (perl/test_print.pl in the Virtuoso
working directory):</para>
        <programlisting>
/perl/test_print.pl
-------------------
#!/usr/bin/perl
print "hello world file";
</programlisting>
        <programlisting>
select __hosting_http_handler ('pl', 'perl/test_print.pl');
</programlisting>
        <programlisting>
returns : hello world file
</programlisting>
      </example>
      <note>
        <title>Note:</title>
        <para>The hosting_perl hosting module uses the perl <function>tie()</function>

  function to "tie" up the STDIN, STDOUT, STDERR, exit()  and %ENV perl objects.
  Untying any of these may lead to unpredictable results.</para>
      </note>
    </section>
    <!--

For Java :
0) JDK or JRE needs to be installed
1) jvm.dll needs to be in %PATH% , *copy* will not work !
2) JavaClasspath (INI setting) needs to contain path to all .class .jar files which are used

There's a [Mono] INI section.
In there there are :
MONO_PATH - where your assemblies (non-system ones) are
MONO_ROOT - where the Mono is installed.
MONO_CFG_DIR - where the mono configuration files are
virtclr.dll - the full path to the above.

The three upcase values you can set also as env variables.

To start ASPX demos on Linux (demo machine) needed:

copy virt_aspx.dll and virtclr.dll in demo directory.
copy machine.config to demo/mono directory
export MONO_ROOT=/dbs/virtuoso/3.0/mono/lib

all necessary file can be found in =/dbs/virtuoso/3.0/mono

The virtclr.dll can be put on ever dir described in settings MONO_PATH (Global assembly cache in Windows).

But virt_aspx.dll need for now in db (application root dir)

For now we link static libmono.a and we need dll (classes) from some distribution.

The static link has two good sides:

We not depend from mono cvs tree status
We can fast put ours patchs.
Also will add necessary dll in distrib.

-->

  </chapter>
