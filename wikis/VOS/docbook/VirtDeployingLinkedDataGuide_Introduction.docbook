<docbook><section><title>VirtDeployingLinkedDataGuide_Introduction</title><para> </para>
<title> Deploying Linked Data - Part 1: Introduction</title> Deploying Linked Data - Part 1: Introduction
 <ulink url="">
 <ulink url="VirtDeployingLinkedDataGuide">Deploying Linked Data - TOC</ulink><bridgehead class="http://www.w3.org/1999/xhtml:h2">Section Contents</bridgehead>
 <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId311507">Introduction</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncWhThPrTo">What&#39;s The Current Problem?</ulink> </listitem>
<listitem><ulink url="#AncmozTocId883331">What is Linked Data?</ulink> </listitem>
<listitem><ulink url="#AncWhDoLiDaMeEn">What Does the Linked Data Meme Enable?</ulink> </listitem>
<listitem><ulink url="#AncmozTocId155253">Deployment Challenges</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncHttpUris">Exploiting HTTP URI Duality</ulink> </listitem>
<listitem><ulink url="#AncReWoObRe">Real-World Object Referencing</ulink> </listitem>
</itemizedlist></listitem>
<listitem><ulink url="#AncmozTocId643278">Resource Identity</ulink> </listitem>
<listitem><ulink url="#AncmozTocId21938">Hash &amp; Slash based URIs</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId48992">Hash URIs</ulink> </listitem>
<listitem><ulink url="#AncmozTocId938466">Slash URIs</ulink> </listitem>
</itemizedlist></listitem>
<listitem><ulink url="#AncmozTocId241439">Resolution of the Deployment Challenge</ulink> </listitem>
<listitem><ulink url="#AncmozTocId750408">Content Negotiation</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId507953">HttpRange-14 Recommendations</ulink> </listitem>
</itemizedlist></listitem>
<listitem><ulink url="#AncmozTocId602731">Content Negotiation &amp; Linked Data Deployment</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId737674">Content Negotiation with Hash URI Based Data Object Naming Scheme</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId916911">Example 1: Static descriptions of a Data Object</ulink> </listitem>
<listitem><ulink url="#AncmozTocId790086">Example 2: Dynamically derived descriptions of a Data Object using a SPARQL DESCRIBE</ulink> </listitem>
</itemizedlist></listitem>
<listitem><ulink url="#AncmozTocId76437">Content Negotiation with a Slash URI Based Data Object Naming Scheme</ulink> </listitem>
</itemizedlist></listitem>
<listitem><ulink url="#AncmozTocId502192">URL Rewriting</ulink> <itemizedlist mark="bullet" spacing="compact"><listitem><ulink url="#AncmozTocId998146">Using URL Rewriting to Solve Linked Data Deployment Challenges</ulink></listitem>
</itemizedlist></listitem>
</itemizedlist></listitem>
</itemizedlist><ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h2"> Introduction</bridgehead>
<para>The current ubiquitous World Wide Web (Web) is a mesh of &quot;Linked Documents&quot; connected by hypertext links.
 Each link serves the single purpose of connecting one document to another, and that&#39;s it.
 This widely understood and accepted Web interaction pattern is facilitated by a dual resource identification/location facility called a Uniform Resource Locator (URL) and a messaging protocol known as the <ulink url="HyperText">HyperText</ulink> Transfer Protocol (HTTP).</para>
<para>The popularity of the current &quot;Web of Documents&quot; (or &quot;Document Web&quot;) sometimes obscures the fact that from the outset Tim Berners-Lee envisaged the Web as an information space connecting disparate data spaces as part of a granular &quot;Web of Linked Data Items&quot;.
 In this more granular form of the Web, each item of data (a datum) is uniquely identified by a resolvable identifier called an HTTP URI and applicability extends to real-world objects; basically a scheme similar to Object or Entity Identity in the distributed database management technology realm.</para>
<para>Ultimately, evolving an erstwhile coarse and inherently opaque Web of &quot;Linked Documents&quot; into a fine grained mesh of &quot;Linked Data&quot;, is how the Web ultimately intersects with the original vision of: hyper-orthogonality across disparate data sources, long espoused by Ted Nelson, the father of hypermedia.</para>
<para>In this document we cover the use of Virtuoso as a Linked Data Deployment platform for injecting Linked Data meshes into the broader Web.</para>
<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3">What&#39;s The Current Problem?</bridgehead>
 The existing Document Web comprises a linked mesh of information-bearing documents, where we use the term &quot;information&quot; to mean &quot;data in a particular context&quot; and where, unfortunately, the context in question is frequently inherently subjective.
 The aim of Linked Data is to free information from its contextual confines and in so doing enable access and linking via the Web to objective raw data.<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> What is Linked Data?</bridgehead>
<para>&quot;Linked Data&quot; is the title of a <ulink url="http://www.w3.org/DesignIssues/LinkedData.html">Web Design Issues Note</ulink> by Berners-Lee that describes a best-practice recipe for injecting data into the Web as part of a broader effort to evolve the current Web of interlinked documents to a Web of Linked Data.
 The principles he outlined are as follows (paraphrased):</para>
<orderedlist spacing="compact"><listitem>Name things (real or abstract) in your universe-of-discourse (data spaces) using URIs.
</listitem>
<listitem>Use HTTP to construct URIs so that people can discover and explore your data via the Web.
</listitem>
<listitem>Expose useful information via your URIs </listitem>
<listitem>Enhance your URIs by adding links to other data on the Web using their URIs thereby enhancing the link density and richness of the Web.</listitem>
</orderedlist><ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3">What Does The Linked Data Meme Enable?</bridgehead>
<para>The underpinnings of Linked Data are provided by the Resource Description Framework (RDF), a framework for describing Web addressable resources through associated metadata (structured data about data).
 RDF (and supporting layers like RDFS and OWL) support the Entity-Attribute-Value (aka Subject-Predicate-Object) + Classes &amp; Relationships metadata model (EAV/CR).
 A model that&#39;s been with us since the inception of modern computing, long before the Web.</para>
<para>By following the Linked Data guidelines and endowing subjects, their attributes, and optionally attribute values, with HTTP URIs when producing EAV/CR model-based metadata, the result is a Web architecture friendly metadata scheme that makes possible a new level of link abstraction on the Web in which data item to data item &quot;hyperdata&quot; links predominate over document to document links.
 Ultimately, the Linked Data meme provides a vehicle for realizing the full capabilities of the Web as a platform for open data identification, data definition, data access, storage, representation, presentation, and integration.</para>
<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Deployment Challenges</bridgehead>
<para>The succinctness of the Linked Data principles summarised above hides an easily missed subtlety regarding the duality of HTTP URIs, in that they serve two essential roles in Linked Data deployment - they both identify Linked Data entities and provide access to Linked Data entity descriptions, i.e.
 entity metadata.
 Our everyday use of the Document Web unfortunately conflates identity and access, whereas in the Data Web these notions are quite distinct.</para>
<para>What do we mean by identity? People, places, ideas, music, and other real world objects (RWOs) possess &quot;identity&quot;, that is a collection of characteristics that distinguish them from another entity.
 Associated with this abstraction can be a label used as a unique identifier.
 In the case of Linked Data, we use URIs.</para>
<para>Accessing an entity is in effect to request information about it.
 The information returned comprises metadata describing the real world object.
 Access does not return the object itself (clearly this will be impossible if the object is a person!) but a description of it.
 Several descriptions of a object may exist, each offering a different perspective or representation format.
 Thus when you access, or de-reference, a URI, you request a description of an entity&#39;s characteristics as a Web-accessible document (aka an information resource).</para>
<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4">Exploiting HTTP URI Duality</bridgehead>
<para>Although the term URI is often used unadorned in the context of Linked Data, the need to support both identity and access requires that Linked Data URIs be HTTP URIs, which provide both entity identity and access to the entity&#39;s metadata.
 A URI may be classed as a locator (URL) or a name (URN).
 When a URN, a URI need only identify a resource.
 The resource may be abstract and consequently not dereferenceable.
 In the Linked Data realm, by limiting URIs to the HTTP scheme, the URIs become dereferenceable URLs, specifying both the identity and location of Web information resources.
 Moreover, HTTPs content negotiation mechanism provides a means for an HTTP client and server to negotiate the preferred representation at request time, for example to select between (X)HTML+RDFa, JSON, XML, RDF/XML, N3, Turtle, Trix and other possible representations.</para>
<para>The dual nature of HTTP URIs and their ability to furnish:</para>
<orderedlist spacing="compact"><listitem>RWO identifiers/names </listitem>
<listitem>RWO metadata document locators </listitem>
<listitem>Negotiable representations of the located metadata document</listitem>
</orderedlist><para>provides a powerful abstraction layer for platform independent data access not possible with the current Document Web.</para>
<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4">Real-World Object Referencing</bridgehead>
<para>Clearly the Linked Data Web and the Document Web are two dimensions of the same Web separated by a common element, the URI.
 In the Document Web, URIs are normally of the URL (rather than URN) variety, and identify &quot;physical&quot; Web documents (information resources) by their location, making no distinction between identity and access.
 In order for Linked Data style real-world data object referencing to work on the existing Web, all resource URIs need to be HTTP-based.
 In addition, on the deployment side, a Linked Data deployment platform needs to support:</para>
<itemizedlist mark="bullet" spacing="compact"><listitem>separation of identity from representation within the context of HTTP protocol mechanics </listitem>
<listitem>dynamic generation of proxy information resources that convey descriptions of a real-world object when its HTTP-based URI is dereferenced </listitem>
<listitem>transparent content negotiation that involves quality of service algorithms instigatable on the client and/or server sides </listitem>
<listitem>URL re-writing and query association</listitem>
</itemizedlist><para>We explore how these challenges can be met below.</para>
<ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Resource Identity</bridgehead>
<para> In the previous section we established the difference between Web resource URLs and real-world object URIs as object identification and naming mechanisms.
 In the sections that follow, we are going to explore different naming schemes and rules for establishing real-world object URIs in the Linked Data Web realm.</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Hash &amp; Slash based URIs</bridgehead>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> Hash URIs</bridgehead>
 One convention adopted by some Linked Data practitioners is the so-called &#39;hash URI&#39; scheme where a URI is combined with a fragment identifier (&#39;#&#39; and an identification character sequence) to construct a natural (human readable) identifier.
 e.g.<emphasis> &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI#this&gt;</emphasis> where the fragment identifier component of the URI enables use of the Web resource at <emphasis>&lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI&gt;</emphasis> as a proxy for conveying a descriptive representation of real-world object<emphasis> &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI#this&gt;</emphasis>.
<para><figure><graphic fileref="VirtDeployingLinkedDataGuide_Introduction/uri_semantics_hash_uri_scheme.png" /></figure> <emphasis>URI semantics - separating identification &amp; naming from representation</emphasis> </para><para>The fundamental advantage of this scheme comes down to the fact that resource descriptions are obtained via a single network hop.
 On the other hand it carries the disadvantage of being representation format specific with regards to the proxy resource used to convey descriptive representation of a given entity (or resource).
 For instance, you can only use this approach for RDF or HTML representations but not both within the context of the &quot;single hop&quot; benefit, so each additional descriptive representation will require a 30X redirect as examples later in this document with unveil.</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> Slash URIs</bridgehead>
<para>An alternative approach is a slash based scheme in which the resulting identifier looks -- for all intents and purposes -- like a typical Web resource URL, but at resource description request time the deployment server employs HTTP redirection to guide clients towards representation specific Web resource URLs that convey resource descriptions.
 Examples include:</para>
<itemizedlist mark="bullet" spacing="compact"><listitem><emphasis> &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt;</emphasis>: the URI uniquely identifies an entity (real-world data object) </listitem>
<listitem><emphasis> &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt;</emphasis>: the URI identifies an HTML-based representation of the entity being described </listitem>
<listitem><emphasis> &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt;</emphasis>: the URI identifies an RDF-based representation of the entity being described</listitem>
</itemizedlist><para>The fundamental advantage of this approach is that the URI and its associated resource description URLs are clearly discernible to a human observer.
 On the other hand it carries the disadvantage of additional network hops via mandatory 30X redirection from the real-world object URI to associated representation specific Web resource URLs conveying its description.</para>
<para><figure><graphic fileref="VirtDeployingLinkedDataGuide_Introduction/uri_semantics_slash_uri_scheme.png" /></figure> <emphasis>URI semantics - separating identification &amp; naming from representation</emphasis> </para><para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Resolution of the Deployment Challenge</bridgehead>
<para>As covered in the prior section, HTTP based URIs provide an ingenious mechanism for separating the identity of a real-world object from the representation of its description.
 The sections that follow cover some of the mechanics of content negotiation and the combined use of content negotiation, re-write rules, and the SPARQL query language to deliver a platform independent mechanism for deploying Linked Data into the Web.</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Content Negotiation</bridgehead>
 <emphasis>Content negotiation</emphasis> is an intrinsic HTTP protocol mechanism that makes it possible to serve different representations of a physical resource, or descriptions of a real-world object, from a single URI, such that software agents can choose which representation best fits their capabilities.<para>A browser or any other HTTP-based web application indicates its resource representation preferences by packaging these preferences in the &quot; Accept* &quot; headers of each HTTP request.
 For example, a browser could send the following HTTP request to indicate that it wants an HTML or XHTML based representation of the resource<emphasis> &lt;http://www.openlinksw.com/whitepapers/data_management&gt;</emphasis> in English or French: </para>
<programlisting>GET /whitepapers/data_management HTTP/1.1 
Host: www.openlinksw.com 
Accept: text/html, application/xhtml+xml 
Accept-Language: en, fr 
</programlisting><para> Here, the HTTP Accept: header sent by the browser indicates the MIME types it wants ( text/html or application/xhtml+xml , for HTML and XHTML, respectively).
 An RDF browser, in contrast, might stipulate a Content Type of application/rdf+xml or application/rdf+n3 indicating RDF/XML or N3 resource description representations respectively.</para>
<para> Rather than returning the content in the required format directly, Web servers often implement content negotiation by redirecting to an information resource URL associated with a physical resource that has been constructed in conformance with the content type of the request.
 For example, a server might respond with: </para>
<programlisting>HTTP/1.1 302 Found 
Location: http://www.openlinksw.com/whitepapers/data_management.en.html
</programlisting><para> The redirect is indicated by the <ulink url="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP status code</ulink>  302 (Found) .
 The client would then send another HTTP request for the new URL.
 HTTP defines a number of 3xx status codes, all of which indicate the client is being redirected.
 Instead of 302 , servers may also use 303 (See Other) to indicate the response to the request can be found at another location (which is also provided, via the &quot; Location: &quot; response header).</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> HttpRange-14 Recommendations</bridgehead>
 The problem of URI/resource-type interpretation was originally addressed by the W3C Technical Architecture Group (TAG) around 2005 and was known as the<emphasis> <ulink url="HttpRange">HttpRange</ulink>-14 </emphasis>issue.
 After a good deal of deliberation, the TAG proposed the guidelines below on the information that can be inferred from HTTP protocol response codes received when dereferencing a URI:<table><title /><tgroup><thead /><tbody><row><entry><emphasis>HTTP Response Code</emphasis></entry><entry><emphasis>Material Returned</emphasis></entry><entry><emphasis>Inference</emphasis></entry></row><row><entry> 200 (success) </entry><entry>A resource representation and its location</entry><entry>A Web information resource has been located in the desired representation.</entry></row><row><entry> 303 (see other) </entry><entry>A resource location</entry><entry>A redirection to the location of an associated Web information resource in a desired representation.</entry></row><row><entry> 4XX or 5XX (error) </entry><entry>Nothing</entry><entry>No Web information resource or resource location is discernible from the resource and representation combination used in the message.</entry></row></tbody></tgroup></table><ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> Content Negotiation &amp; Linked Data Deployment</bridgehead>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> Content Negotiation with Hash URI Based Data Object Naming Scheme</bridgehead>
<para> We give some examples of content negotiation using a hash-based URI scheme below.
 The examples assume that the &#39;#this&#39; suffix of a hash URI is not lost en-route to the Linked Data server, but this cannot be guaranteed.
 (From the perspective of Linked Data servers, the URIs http://demo.openlinksw.com/Northwind/Customer/ALFKI and http://demo.openlinksw.com/Northwind/Customer/ALFKI#this are identical, because nothing following the fragment identifier leaves the Web Client realm, due to the fact that the Web Client expects to process the &#39;#this&#39; suffix locally, post resource retrieval.) &gt; We give some examples of content negotiation using a hash-based URI scheme below.
 The examples assume that the &#39;#this&#39; suffix of a hash URI is not lost en-route to the Linked Data server, but this cannot be guaranteed.
 (From the perspective of Linked Data servers, the URIs http://demo.openlinksw.com/Northwind/Customer/ALFKI and http://demo.openlinksw.com/Northwind/Customer/ALFKI#this are identical, because nothing following the fragment identifier leaves the Web Client realm, due to the fact that the Web Client expects to process the &#39;#this&#39; suffix locally, post resource retrieval.)</para>
<para> Returning to our earlier example URIs, http://demo.openlinksw.com/Northwind/Customer/ALFKI and http://demo.openlinksw.com/Northwind/Customer/ALFKI#this, we can construct a decision table that demonstrates how a deployer of Linked Data would leverage content negotiation en route to alleviating the previously outlined Data Access and Data Reference challenges.</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h5"> Example 1: Static descriptions of a Data Object</bridgehead>
 The first example assumes the simplest case of there being static HTML and RDF documents available to provide HTML and RDF representations of the customer entity ALFKI.<table><title /><tgroup><thead /><tbody> <row> <entry><emphasis>URI</emphasis></entry> <entry><emphasis>URI Type</emphasis></entry> <entry><emphasis>Requested Representation (X)HTML</emphasis></entry> <entry><emphasis>Requested Representation RDF</emphasis></entry> </row> <row> <entry> http://demo.openlinksw.com/Northwind/Customer/ALFKI</entry> <entry>Web Resource URL</entry> <entry> 200 (OK) - if an (X)HTML information resource (document) exists on the serveror   404 - if (X)HTML document isn&#39;t available on serveror406 - if descriptive representation in this format isn&#39;t applicable</entry> <entry> 200 (OK) - if an RDF information resource exists on the server.</entry> </row> <row> <entry> http://demo.openlinksw.com/Northwind/Customer/ALFKI#this</entry> <entry>Hash based HTTP specific URN</entry> <entry> 303 (Redirect) - to an associated (X)HTML document that describes entity &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI#this&gt;,or 404 - if entity description isn&#39;t dereferenceable from this server</entry> <entry>   200 (OK) - Return RDF based information resource:   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI&gt;   that describes entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI#this&gt; using N3, Turtle, RDF/XML etc.
</entry> </row> </tbody></tgroup></table><ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h5"> Example 2: Dynamically derived descriptions of a Data Object using a SPARQL DESCRIBE</bridgehead>
<para> The next example illustrates the use of a SPARQL DESCRIBE query to provide an RDF rendering of the entity being dereferenced by the client.
 If only a few entities need to be described in RDF, and if we lacked an RDF quad store, we could legitimately provide these descriptions in the form of RDF documents, to which we redirect when the client requests RDF/XML.
 Obviously when the entities are described in a quad store, the sensible approach is to return an RDF description directly from the store by redirecting, via URL rewriting, to the store&#39;s SPARQL endpoint to request a description rendered by either a  <ulink url="http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/#construct">CONSTRUCT</ulink>  or  <ulink url="http://www.w3.org/TR/2006/CR-rdf-sparql-query-20060406/#describe">DESCRIBE</ulink>  query.
 The general forms are:</para>
<itemizedlist mark="bullet" spacing="compact"><listitem>DESCRIBE &lt;entity-uri&gt; FROM &lt;graph-uri&gt;  </listitem>
<listitem>CONSTRUCT { &lt;entity-uri&gt; ?p ?o } FROM &lt;graph-uri&gt; WHERE { &lt;entity-uri&gt; ?p ?o } </listitem>
</itemizedlist><para>Note: Both return an RDF graph.
 However the DESCRIBE query feature is &#39;unconstrained&#39;.
 The description returned in not prescribed by the SPARQL specification and is determined by the SPARQL query processor.
 (Virtuoso allows applications to tailor the description to their individual needs through the proprietary SPARQL define <ulink url="http://docs.openlinksw.com/virtuoso/rdfapiandsql.html#rdfsqlfromsparqldescribe">sql:describe-mode</ulink>  which is used to specify custom procedures for generating the DESCRIBE output.)</para>
<para> So, an RDF representation of entity ALFKI is provided by the result of a SPARQL DESCRIBE query.
 A dynamic HTML representation of ALFKI is obtained by rendering the RDF description (again extracted by a SPARQL DESCRIBE) as HTML.
 OpenLink uses just such an approach, using a presentation rendering template (description.vsp - described later) to render the base RDF description as HTML.</para>
<table><title /><tgroup><thead /><tbody> <row>   <entry><emphasis>URI</emphasis></entry>   <entry><emphasis>URI Interpretation</emphasis></entry>   <entry><emphasis>Requested Representation (X)HTML</emphasis></entry>   <entry><emphasis>Requested Representation RDF</emphasis></entry> </row><row>   <entry> http://demo.openlinksw.com/Northwind/Customer/ALFKI</entry>   <entry>Web Resource URL</entry>   <entry>     200 (OK) - if an (X)HTML information resource (document) exists on the server     or     404 - if (X)HTML document isn&#39;t available on server     or     406 - if descriptive representation in this format isn&#39;t applicable   </entry>   <entry>     200 (OK) - if an RDF information resource exists on the server.
  </entry> </row><row>   <entry>     http://demo.openlinksw.com/Northwind/Customer/ALFKI#this   </entry>   <entry>     Hash based HTTP specific URN   </entry>   <entry>     303 (Redirect) - to an associated (X)HTML document that describes entity:     &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI#this&gt;     or     404 - if an entity description isn&#39;t dereferenceable from this server.
  </entry>   <entry>     200 (OK) - Return RDF based information resource:     &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI&gt;     that describes entity:     &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI&amp;gt#this;     using N3, Turtle, RDF/XML etc.
         You can also use a SPARQL DESCRIBE URL to deliver the RDF based description but the provenance of the description     potentially becomes obscured.
  </entry> </row> </tbody></tgroup></table><para>In Example 1, when an HTML representation of http://demo.openlinksw.com/Northwind/Customer/ALFKI#this is requested, the client is re-directed (through a 303 response code) to the HTML document identified by http://demo.openlinksw.com/Northwind/Customer/ALFKI.
 In Example 2, the same result is achieved by different means.
 Again a request for an HTML representation of http://demo.openlinksw.com/Northwind/Customer/ALFKI#this results in the (dynamically derived) HTML document associated with http://demo.openlinksw.com/Northwind/Customer/ALFKI being returned.
 In this case though, an internal(rather than external 303) redirect is used, consequently the response code is 200.</para>
<para><figure><graphic fileref="VirtDeployingLinkedDataGuide_Introduction/report_writer_style_renditions.png" /></figure></para><para> It is also important to note that deploying Linked Data in this way is quite similar to using HTTP-based URLs as report-writer-style document identifiers.
 The key difference is that the data in the report is self-describing and granular; i.e.
 each entity in the page has an HTTP-based URI and the semantics of the relationship between the report and the associated entities can be explicitly expressed.
 Thus, the entity &quot;ALFKI&quot; is first exposed as the value of the &quot;foaf:primaryTopic&quot; property and then, when it&#39;s de-referenced, the associated description is returned via a document that is identified via a URL containing an escaped form of &quot;#&quot; (%23) which simply negates the ambiguity that fragment identifiers introduced when dealing with this the hash URI scheme i.e.
 the fragment ID is discarded at HTTP GET time by user agents since its sole use is for local processing.</para>
<para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> Content Negotiation with a Slash URI Based Data Object Naming Scheme</bridgehead>
 Using the slash URI naming scheme outlined above, the server responses to possible URI / content-type request combinations might be as follows:<table><title /><tgroup><thead /><tbody> <row> <entry> <emphasis>URI</emphasis> </entry> <entry><emphasis>Requested Representation (X)HTML</emphasis> </entry> <entry><emphasis>Requested Representation RDF</emphasis> </entry> </row><row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt; </entry> <entry>   303 (Redirect) to (X)HTML information resource at &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   303 (Redirect) to RDF information resource at &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> </row><row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   200 (OK) - Return an (X)HTML information resource that describes entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt; </entry> <entry>   406 (Not available in this representation)    Note: The &lt;head&gt; section of resource   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt;   could be used to point to   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt;   via &lt;link&gt; using the @rel property.
     You can also use RDFa within   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt;   to establish a link with   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> </row> <row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> <entry>   406 (Not available in this representation)      Note: The triples in the RDF information resource can be used to direct user agents to the resource   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   200 (OK) - Return an RDF information resource describing entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt;   using N3, Turtle, RDF/XML etc.
</entry> </row></tbody></tgroup></table><para>Again, if the base description data was being retrieved dynamically from a quad store, our table might become:</para>
<table><title /><tgroup><thead /><tbody> <row> <entry> <emphasis>URI</emphasis> </entry> <entry><emphasis>Requested Representation (X)HTML</emphasis> </entry> <entry><emphasis>Requested Representation RDF</emphasis> </entry> </row><row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt; </entry> <entry>   303 (Redirect) to (X)HTML information resource at &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   303 (Redirect) to RDF information resource at &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> </row><row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   200 (OK) - Return an (X)HTML information resource that describes entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt; </entry> <entry>   406 (Not available in this representation)    Note: The &lt;head&gt; section of resource   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt;   could be used to point to   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt;   via &lt;link&gt; using the @rel property.
     You can also use RDFa within   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt;   to establish a link with   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> </row> <row> <entry>   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/data&gt; </entry> <entry>   406 (Not available in this representation)      Note: The triples in the RDF information resource can be used to direct user agents to the resource   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/page&gt; </entry> <entry>   200 (OK) - Return an RDF information resource describing entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt;   using N3, Turtle, RDF/XML etc.
     You can also use a SPARQL DESCRIBE URL to deliver the RDF based description of the entity   &lt;http://demo.openlinksw.com/Northwind/Customer/ALFKI/id&gt;   but the provenance of the description potentially becomes obscured.
</entry> </row></tbody></tgroup></table><para> <ulink url="">
 </ulink></para>
<bridgehead class="http://www.w3.org/1999/xhtml:h3"> URL Rewriting</bridgehead>
 <emphasis>URL rewriting</emphasis> is the act of modifying a requested source URL prior to the final processing of that URL by a Web Server.<para>The ability to rewrite URLs may be desirable for many reasons that include:</para>
<itemizedlist mark="bullet" spacing="compact"><listitem>Changing Web information resource URLs on the a Web Server without breaking existing bookmarks held in User Agents (e.g., Web browsers) </listitem>
<listitem>URL compaction where shorter URLs may be constructed on a conditional basis for specific User Agents (e.g., Email clients) </listitem>
<listitem>Construction of search engine friendly URLs that enable richer indexing since most search engines cannot process parameterized URLs effectively.</listitem>
</itemizedlist><ulink url="">
<para> </para>
<bridgehead class="http://www.w3.org/1999/xhtml:h4"> Using URL Rewriting to Solve Linked Data Deployment Challenges</bridgehead>
<para> In the previous section we demonstrated how content negotiation and HTTP response messages could be used to address the data access issues arising from the use of URIs associated with resource identity and representation.</para>
<para> We determined earlier that URI naming schemes don&#39;t fully resolve the challenges associated with referencing data.
 To reiterate, this is demonstrated by the fact that the URIs<emphasis> http://demo.openlinksw.com/Northwind/Customer/ALFKI</emphasis> and <emphasis>http://demo.openlinksw.com/Northwind/Customer/ALFKI#this</emphasis> both appear as <emphasis>http://demo.openlinksw.com/Northwind/Customer/ALFKI</emphasis> to the Web Server, since data following the fragment identifier &quot;#&quot; never makes it that far.</para>
<para>The only way to address data referencing is by pre-processing source URIs (e.g., via regular expression or sprintf substitutions) as part of a URL rewriting processing pipeline.
 The pipeline process has to take the form of a set of rules that cater for elements such as HTTP Accept headers, HTTP response codes, HTTP response headers, and rule processing order.</para>
<para> An example of such a pipeline is depicted in the table below.</para>
<table><title /><tgroup><thead /><tbody> <row> <entry><emphasis>Source URI (Regular Expression Pattern)</emphasis></entry> <entry><emphasis>HTTP Accept Headers (Regular Expression)</emphasis></entry> <entry><emphasis>HTTP Response Code</emphasis></entry> <entry><emphasis>HTTP Response Headers</emphasis></entry> <entry><emphasis>Rule Processing Order</emphasis></entry> </row> <row> <entry> /Northwind/Customer/([^#]*) </entry> <entry>None (i.e.
 default)</entry> <entry> 200 or 303 responses depending on the user agent default or server side quality of service rules via Transparent Content Negotiation.</entry> <entry>None</entry> <entry>Normal (order irrelevant)</entry> </row> <row> <entry> /Northwind/Customer/([^#]*) </entry> <entry>(text/rdf.n3) | (application/rdf.xml)</entry> <entry> 303 redirect to a URL which DESCRIBEs the entity identified by the URI.</entry> <entry>None</entry> <entry>Normal (order irrelevant)</entry> </row> <row> <entry> /Northwind/Customer/([^#]*) </entry> <entry>(text/html) | (application/xhtml.xml)</entry> <entry>   406 (Not acceptable) , or if an (X)HTML document describing the entity exists 200 (OK) &amp; return the document, or   303 redirect to a URL which can render the requested representation.</entry> <entry>For 406: Vary: negotiate, accept Alternates: {&quot;ALFKI&quot; 0.9 {type application/rdf+xml}} </entry> <entry>Normal (order irrelevant)</entry> </row></tbody></tgroup></table><para>The flow between client and server, based on the above decision table is shown in the next figure.</para>
<para><figure><graphic fileref="VirtDeployingLinkedDataGuide_Introduction/Deploying_Linked_Data_fig1.png" /></figure> <emphasis>Client/server content negotiation for an RDF representation</emphasis> </para><para>The source URI patterns refer to virtual or physical directories at<emphasis> http://demo.openlinksw.com/</emphasis>.
 Rules can be placed at the head or tail of the pipeline, or applied in the order they are declared, by specifying a Rule Processing Order of First, Last, or Normal, respectively.
 The decision as to which representation to return for URI<emphasis> http://demo.openlinksw.com/Northwind/Customer/ALFKI</emphasis> is based on the MIME type(s) specified in any Accept header accompanying the request.</para>
<para>In the case of the last rule, the Alternates response header applies only to response code 406 .
 406 would be returned if there were no (X)HTML representation available for the requested resource.
 In the example shown, an alternative representation is available in RDF/XML.</para>
<para> When applied to matching HTTP requests, the last two rules might generate responses similar to those below.
 In the first cURL exchange, the target Virtuoso server redirects to a SPARQL endpoint that retrieves an RDF/XML representation of the requested entity: </para>
<programlisting>$ curl -I -H &quot;Accept: application/rdf+xml&quot; http://demo.openlinksw.com/Northwind/Customer/ALFKI
HTTP/1.1 303 See Other
Server: Virtuoso/05.00.3016 (Solaris) x86_64-sun-solaris2.10-64 PHP5
Connection: close
Content-Type: text/html; charset=ISO-8859-1
Date: Mon, 16 Jul 2007 22:40:03 GMT
Accept-Ranges: bytes
Location: /sparql?query=CONSTRUCT+{+%3Chttp%3A//demo.openlinksw.com/Northwind/Customer/ALFKI%23this%3E+%3Fp+%3Fo+}
    +FROM+%3Chttp%3A//demo.openlinksw.com/Northwind%3E
    +WHERE+{+%3Chttp%3A//demo.openlinksw.com/Northwind/Customer/ALFKI%23this%3E+%3Fp+%3Fo+}&amp;format=application/rdf%2Bxml
Content-Length: 0 
</programlisting><para> In the second cURL exchange, the target Virtuoso server indicates that there is no resource to deliver in the requested representation.
 It provides hints in the form of an alternate resource representation and URI that may be appropriate, i.e., an RDF/XML representation of the requested entity: </para>
<programlisting>$ curl -I -H &quot;Accept: text/html&quot; http://demo.openlinksw.com/Northwind/Customer/ALFKI
HTTP/1.1 406 Not Acceptable
Server: Virtuoso/05.00.3016 (Solaris) x86_64-sun-solaris2.10-64 PHP5
Connection: close
Content-Type: text/html; charset=ISO-8859-1
Date: Mon, 16 Jul 2007 22:40:23 GMT
Accept-Ranges: bytes
Vary: negotiate,accept
Alternates: {&quot;ALFKI&quot; 0.9 {type application/rdf+xml}}
Content-Length: 0 
</programlisting><para> <emphasis><ulink url="VirtDeployingLinkedDataGuide">Back</ulink></emphasis> to Deploying Linked Data Guide | <emphasis><ulink url="VirtDeployingLinkedDataGuide_UsingVirtuoso">Next:</ulink></emphasis> Deploying Linked Data Using Virtuoso </para>
</ulink></ulink></ulink></ulink></ulink></ulink></ulink></ulink></ulink></ulink></ulink></ulink></section></docbook>