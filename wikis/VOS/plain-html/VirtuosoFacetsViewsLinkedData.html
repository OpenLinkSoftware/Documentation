<html><body><div class="topic-text"><!--Begin of %META:TOPICPARENT{name="VOSIndex"}%--><p> </p>
<!--End of %META:TOPICPARENT{name="VOSIndex"}%--><h1><a name="Faceted Views over Large-Scale Linked Data"></a>Faceted Views over Large-Scale Linked Data</h1>
<!--Begin of %TOC{}%--><p> </p><div class="MACRO_TOC">  <div class="wikitoc">   <ul> <li><a href="#What">What</a></li> <li><a href="#Why">Why</a></li> <li><a href="#How">How</a></li>
<ul><li><a href="#Processing%20Large%20Hierarchies%20in%20SPARQL">Processing Large Hierarchies in SPARQL</a></li> <li><a href="#Inverse%20Functional%20Properties%20and%20Same%20As">Inverse Functional Properties and Same As</a></li> <li><a href="#Entity%20Ranking">Entity Ranking</a></li> <li><a href="#Query%20Evaluation%20Time%20Limits">Query Evaluation Time Limits</a></li> <li><a href="#Facets%20Web%20Service">Facets Web Service</a></li> <li><a href="#"></a></li> <li><a href="#Test%20System%20and%20Data">Test System and Data</a></li> <li><a href="#Future%20Work">Future Work</a></li> <li><a href="#Conclusions">Conclusions</a></li> <li><a href="#Tutorials">Tutorials</a></li> </ul><li><a href="#Related">Related</a></li> <li><a href="#References">References</a></li><p>  </p></ul>  </div> </div>
<!--End of %TOC{}%--><h2><a name="What"></a>What</h2>
 Faceted views over structured and semi structured data have been popular in user interfaces for some years.
 Deploying such views of arbitrary linked data at arbitrary scale has been hampered by lack of suitable back end technology.
 Many ontologies are also quite large, with hundreds of thousands of classes.<p>Also, the linked data community has been concerned with the processing cost and potential for denial of service presented by public SPARQL end points.</p>
<p>This article discusses how we use Virtuoso Cluster Edition for providing interactive browsing over billions of triples, combining full text search, structured querying and result ranking.
 We discuss query planning, run-time inferencing and partial query evaluation.
 This functionality is exposed through SPARQL, a specialized web service and a web user interface.</p>
<h2><a name="Why"></a>Why</h2>
<p>The transition of the web from a distributed document repository into a universal, ubiquitous database requires a new dimension of scalability for supporting rich user interaction.
 If the web is the database, then it also needs a query and report writing tool to match.
 A faceted user interaction paradigm has been found useful for aiding discovery and query of variously structured data.
 Numerous implementations exist but they are chiefly client side and are limited in the data volumes they can handle.</p>
<p>At the present time, linked data is well beyond prototypes and proofs of concept.
 This means that what was done in limited specialty domains before must now be done at real world scale, in terms of both data volume and ontology size.
 On the schema, or T box side, there exist many comprehensive general purpose ontologies such as Yago[1], OpenCyc[2], Umbel[3] and the DBpedia[4] ontology and many domain specific ones, such as [5].
 For these to enter into the user experience, the platform must be able to support the user&#39;s choice of terminology or terminologies as needed, preferably without blow up of data and concomitant slowdown.</p>
<p>Likewise, in the LOD world, many link sets have been created for bridging between data sets.Whether such linkage is relevant will depend on the use case.
 Therefore we provide fine grained control over which <code>owl:sameAs</code> assertions will be followed, if any.</p>
<p>Against this background, we discuss how we tackle incremental interactive query composition on arbitrary data with Virtuoso Cluster[6].</p>
<p> </p>
<h2><a name="How"></a>How</h2>
<p>Using SPARQL or a web/web service interface, the user can form combinations of text search and structured criteria, including joins to an arbitrary depth.
 If queries are precise and select a limited number of results, the results are complete.
 If queries would select tens of millions of results, partial results are shown.</p>
<p>The system being described is being actively developed as of this writing, early March of 2009 and is online at <code><a href="http://lod.openlinksw.com/">http://lod.openlinksw.com/</a></code>.
 The data set is a combination of DBpedia, MusicBrainz, Freebase, UniProt, NeuroCommons, Bio2RDF, and web crawls from <a href="http://www.pingthesemanticweb.com/">PingTheSemanticWeb.com</a>.</p>
<p>The hardware consists of two 8-core servers with 16G RAM and 4 disks each.
 The system runs on Virtuoso 6 Cluster Edition.
 All application code is written in SQL procedures with limited client side Ajax, the Virtuoso platform itself is in C.</p>
<p>The facets service allows the user to start with a text search or a fixed URI and to refine the search by specifying classes, property values etc., on the selected subjects or any subjects referenced therefrom.</p>
<p>This process generates queries involving combinations of text and structured criteria, often dealing with property and class hierarchies and often involving aggregation over millions of subjects, specially at the initial stages of query composition.
 To make this work with in interactive time, two things are needed:</p>
<ol><li>a query optimizer that can almost infallibly produce the right join order based on cardinalities of the specific constants in the query </li>
<li>a query execution engine that can return partial results after a timeout.</li>
</ol><p>It is often the case, specially at the beginning of query formulation, that the user only needs to know if there are relatively many or few results that are of a given type or involve a given property.
 Thus partially evaluating a query is often useful for producing this information.
 This must however be possible with an arbitrary query, simply citing precomputed statistics is not enough.</p>
<p>It has for a long time been a given that any search-like application ranks results by relevance.
 Whenever the facets service shows a list of results, not an aggregation of result types or properties, it is sorted on a composite of text match score and link density.</p>
<p>The article is divided into the following parts:</p>
<ul><li>SPARQL query optimization and execution adapted for run time inference over large subclass structures.
</li>
<li>Resolving identity with inverse functional properties </li>
<li>Ranking entities based on graph link density </li>
<li>SPARQL partial query evaluation for displaying partial results in fixed time </li>
<li>a facets web service providing an XML interface for submitting queries, so that the user interface is not required to parse SPARQL </li>
<li>a sample web interface for interacting with this </li>
<li>sample queries and their evaluation times against combinations of large LOD data sets</li>
</ul><p> </p>
<h3><a name="Processing Large Hierarchies in SPARQL"></a>Processing Large Hierarchies in SPARQL</h3>
<p>Virtuoso has for a long time had built-in superclass and superproperty inference.
 This is enabled by specifying the <code>DEFINE input:inference &quot;context&quot;</code> option, where context is previously declared to be all subclass, subproperty, equivalence, inverse functional property and same as relations defined in a given graph.
 The ontology file is loaded into its own graph and this is then used to construct the context.
 Multiple ontologies and their equivalences can be loaded into a single graph which then makes another context which holds the union of the ontology information from the merged source ontologies.</p>
<p>Let us consider a sample query combining a full text search and a restriction on the class of the desired matches:</p>
<br><pre>DEFINE  input:inference  &quot;yago&quot;
PREFIX  cy:  &lt;http://dbpedia.org/class/yago/&gt;
SELECT DISTINCT ?s1 AS ?c1
                ( bif:search_excerpt 
                  ( bif:vector ( &#39;Shakespeare&#39; ), ?o1 ) 
                ) AS ?c2
WHERE 
  {
    ?s1  ?s1textp ?o1                         .
    FILTER 
      ( bif:contains (?o1, &#39;&quot;Shakespeare&quot;&#39;) ) .
    ?s1  a        cy:Performer110415638
  } 
LIMIT 20
</pre><p> This selects all Yago performers that have a property that contains &quot;Shakespeare&quot; as a whole word.</p>
<p>The <code>DEFINE input:inference &quot;yago&quot;</code> clause means that subclass, subproperty and inverse functions property statements contained in the inference context called yago are considered when evaluating the query.
 The built-in function <code>bif:search_excerpt</code> makes a search engine style summary of the found text, highlighting occurrences of Shakespeare.</p>
<p>The <code>bif:contains</code> function in the filter specifies the full text search condition on ?o1.</p>
<p>This query is a typical example of queries that are executed all the time when a user refines a search.
 We will now look at how we can make an efficient execution plan for the query.
 First, we must know the cardinalities of the search conditions:</p>
<p>To see the count of subclasses of Yago performer, we can do:</p>
<br><pre>PREFIX  cy:  &lt;http://dbpedia.org/class/yago/&gt;
SELECT COUNT (*)
FROM &lt;http://dbpedia.org/yago.owl&gt;
WHERE 
  {
    ?s  rdfs:subClassOf  cy:Performer110415638 
    OPTION (TRANSITIVE, T_DISTINCT) 
  }
</pre><p> There are 4601 distinct subclasses, including indirect ones.
Next we look at how many Shakespeare mentions there are:</p>
<br><pre>SELECT COUNT (*) 
WHERE
  {
    ?s  ?p  ?o .
    FILTER 
      ( bif:contains (?o, &#39;Shakespeare&#39;) ) 
  }
</pre><p> There are 10267 subjects with Shakespeare mentioned in some literal.</p>
<br><pre>DEFINE input:inference &quot;yago&quot;
PREFIX cy: &lt;http://dbpedia.org/class/yago/&gt;
SELECT COUNT (*) 
WHERE 
  {
    ?s1  a  cy:Performer110415638
  }
</pre><p> There are 184885 individuals that belong to some subclass of performer.</p>
<p>This is the data that the SPARQL compiler must know in order to have a valid query plan.
 Since these values will wildly vary depending on the specific constants in the query, the actual database must be consulted as needed while preparing the execution plan.
 This is regular query processing technology but is now specially adapted for deep subclass and subproperty structures.</p>
<p>Conditions in the queries are not evaluated twice, once for the cardinality estimate and once for the actual run.
Instead, the cardinality estimate is a rapid sampling of the index trees that reads at most one leaf page.</p>
<p>Consider a B tree index, which we descend from top to the leftmost leaf containing a match of the condition.
 At each level, we count how many children would match and always select the leftmost one.
 When we reach a leaf, we see how many entries are on the page.
 From these observations, we extrapolate the total count of matches.</p>
<p>With this method, the guess for the count of performers is 114213, which is acceptably close to the real number.
Given these numbers, we see that it makes sense to first find the full text matches and then retrieve the actual classes of each and see if this class is a subclass of performer.
 This last check is done against a memory resident copy of the Yago hierarchy, the same copy that was used for enumerating the subclasses of performer.</p>
<p>However, the query</p>
<br><pre>DEFINE input:inference &quot;yago&quot;
PREFIX cy: &lt;http://dbpedia.org/class/yago/&gt;
SELECT DISTINCT ?s1 AS ?c1, 
                ( bif:search_excerpt 
                  ( bif:vector (&#39;Shakespeare&#39;), ?o1 ) 
                ) AS ?c2
WHERE 
  {
    ?s1  ?s1textp  ?o1                         .
    FILTER 
      ( bif:contains (?o1, &#39;&quot;Shakespeare&quot;&#39;) )  . 
    ?s1  a         cy:ShakespeareanActors
  }
</pre><p> will start with Shakespearean actors since this is a leaf class with only 74 instances and then check if the properties contain Shakespeare and return their search summaries.</p>
<p>In principle, this is common cost based optimization but is here adapted to deep hierarchies combined with text patterns.
An unmodified SQL optimizer would have no possibility of arriving at these results.</p>
<p>The implementation reads the graphs designated as holding ontologies when first needed and subsequently keeps a memory based copy of the hierarchy on all servers.
 This is used for quick iteration over sub/superclasses or properties as well as for checking if a given class or property is a subclass/property of another.
 Triples with OWL predicates <code>equivalentClass</code>, <code>equivalentProperty</code> and <code>sameAs</code> are also cached in the same data structure if they occur in the ontology graphs.</p>
<p>Also cardinality estimates for members of classes near the root of the class hierarchy take some time since a sample of each subclass is needed.
 These are cached for some minutes in the inference context, so that repeated queries will not redo the sampling.</p>
<p> </p>
<h3><a name="Inverse Functional Properties and Same As"></a> Inverse Functional Properties and Same As</h3>
<p>Specially when navigating social data, as in FOAF[7] and SIOC[8] spaces, there are many blank nodes that are identified by properties only.
 For this, we offer an option for automatically joining to subjects which share an IFP value with the subject being processed.
 For example, the query for the friends of friends of Kjetil Kjernsmo returns empty:</p>
<br><pre>SELECT COUNT (?f2) 
WHERE 
  {
    ?s   a             foaf:Person          ; 
         ?p            ?o                   ; 
         foaf:knows    ?f1                  .
    ?o   bif:contains  &quot;&#39;Kjetil Kjernsmo&#39;&quot;  .
    ?f1  foaf:knows    ?f2 
  }
</pre><p> But with the option</p>
<br><pre>DEFINE input:inference &quot;b3sifp&quot;
SELECT COUNT (?f2) 
WHERE 
  {
    ?s   a             foaf:Person          ; 
         ?p            ?o                   ; 
         foaf:knows    ?f1                  .
    ?o   bif:contains  &quot;&#39;Kjetil Kjernsmo&#39;&quot;  .
    ?f1  foaf:knows    ?f2 
  }
</pre><p> we get 4022.
 We note that there are many duplicates since the data is blank nodes only, with people easily represented 10 times.
 The context <code>b3sifp</code> simple declares that <code>foaf:name</code> and <code>foaf:mbox</code> sha1sum should be treated as inverse functional properties (IFP).
 The name is not an IFP in the actual sense but treating it as such for the purposes of this one query makes sense, otherwise nothing would be found.</p>
<p>This option is controlled by the choice of the inference context, which is selectable in the interface discussed below.</p>
<p>The IFP inference can be thought of as a transparent addition of a subquery into the join sequence.
 The subquery joins each subject to its synonyms given by sharing IFPs.
This subquery has the special property that it has the initial binding automatically in its result set.
 It could be expressed as:</p>
<br><pre>SELECT ?f 
WHERE 
  {
    ?k  foaf:name  &quot;Kjetil Kjernsmo&quot;  .
    { 
      SELECT ?org ?syn 
      WHERE 
        {
          ?org  ?p  ?key  .
          ?syn  ?p  ?key  .
          FILTER 
            ( bif:rdf_is_sub 
                ( &quot;b3sifp&quot;, ?p, &lt;b3s:any_ifp&gt;, 3 ) 
              &amp;&amp; 
              ?syn  !=  ?org 
            ) 
        }
    } 
    OPTION 
      ( 
        TRANSITIVE     , 
        T_IN (?org), 
        T_OUT (?syn), 
        T_MIN (0), 
        T_MAX (1) 
      ) 
    FILTER 
      ( ?org  =  ?k ) .
    ?syn foaf:knows ?f . 
  }
</pre><p> It is true that each subject shares IFP values with itself but the transitive construct with 0 minimum and 1 maximum depth allows passing the initial binding of <code>?org</code> directly to <code>?syn</code>, thus getting first results more rapidly.
 The <code>rdf_is_sub</code> function is an internal that simply tests whether <code>?p</code> is a subproperty of <code>b3s:any_ifp</code>.</p>
<p>Internally, the implementation has a special query operator for this and the internal form is more compact than would result from the above but the above could be used to the same effect.</p>
<p>The issues of run time vs precomputed identity inference through IFPs and <code>owl:sameAs</code> are discussed in much more detail at[9].</p>
<p>Our general position is that identity criteria are highly application specific and thus we offer the full spectrum of choice between run time and precomputing.
 Further, weaker identity statements than sameness are difficult to use in queries, thus we prefer identity with semantics of <code>owl:sameAs</code> but make this an option that can be turned on and off query by query.</p>
<p> </p>
<h3><a name="Entity Ranking"></a>Entity Ranking</h3>
<p>It is a common end user expectation to see text search results sorted by their relevance.
 The term entity rank refers to a quantity describing the relevance of a URI in an RDF graph.</p>
<p>This is a sample query using entity rank:</p>
<br><pre>PREFIX  yago:  &lt;http://dbpedia.org/class/yago/&gt;
PREFIX  prop:  &lt;http://dbpedia.org/property/&gt;
SELECT DISTINCT ?s2 AS ?c1 
WHERE 
  {
    ?s1  ?s1textp      ?o1                   .
    ?o1  bif:contains  &#39;Shakespeare&#39;         .
    ?s1  a             yago:Writer110794014  .
    ?s2  prop:writer   ?s1
  } 
ORDER BY DESC ( &lt;LONG::IRI_RANK&gt; (?s2) )
LIMIT 20 
OFFSET 0
</pre><p> This selects works where a writer with Shakespeare in some property is the writer.</p>
<p>Here the query returns subjects, thus no text search summaries, so only the entity rank of the returned subject is used.
 We order text results by a composite of text hit score and entity rank of the RDF subject where the text occurs.
The entity rank of the subject is defined by the count of references to it, weighed by the rank of the referrers and the outbound link count of referrers.
 Such techniques are used in text based information retrieval.[15]</p>
<p>One interesting application of entity rank and inference on IFPs and <code>owl:sameAs</code> is in locating URIs for reuse.
 We can easily list synonym URIs in order of popularity as well as locate URIs based on associated text.
 This can serve in application such as the Entity Name Server[14].</p>
<p>Entity ranking is one of the few operations where we take a precomputing approach.
 Since a rank is calculated based on a possibly long chain of references, there is little choice but to precompute.
 The precomputation itself is straightforward enough: First all outbound references are counted for all subjects.
 Next all ranks of subjects are incremented by 1 over the referrer&#39;s outbound link count.
 On successive iterations, the increment is based on the rank increment the referrer received in the previous round.</p>
<p>The operation is easily partitioned, since each partition increments the ranks of subjects it holds.
 The referrers are spread throughout the cluster, though.
 When rank is calculated, each partition accesses every other partition.
 This is done with relatively long messages, referee ranks are accessed in batches of several thousand at a time, thus absorbing network latency.</p>
<p>On the test system, this operation performs a single pass over the corpus of 2.2 billion triples and 356 million distinct subjects in about 30 minutes.
 The operation has 100% utilization of all 16 cores.
 Adding hardware would speed it up, as would implementing it in C instead of the SQL procedures it is written in at present.</p>
<p>The main query in rank calculation is</p>
<br><pre>SELECT O            , 
       P            , 
       iri_rank (S)
FROM rdf_quad TABLE 
OPTION (NO CLUSTER)
WHERE isiri_id(O) 
ORDER BY O
</pre><p> This is the SQL cursor iterated over by each partition.
The no cluster option means that only rows in this process&#39;s partition are retrieved.
 The <code>RDF_QUAD</code> table holds the RDF quads in the store, i.e., triple plus graph.
 The S, P, O columns are the subject, predicate, and object respectively.
The graph column is not used here.
 The iri_rank() is a partitioned SQL function.
 This works by using the S argument to determine which cluster node should run the function.
The specifics of the partitioning are declared elsewhere.
The calls are then batched for each intended recipient and sent when the batches are full.
 The SQL compiler automatically generates the relevant control structures.
 This is like an implicit map operation in the map-reduce terminology.</p>
<p>A SQL procedure performs the following tasks: loops over this cursor, adds up the rank per new O which is then persisted into a table.
 Then leveraging the fact that RDF  relations (predicates) have discernible fine-grained semantics, and are identified by IRIs, we can use the aforementioned relation semantics to determine link coefficients of relation  subjects or objects.
 With extraction of named entities from text content, we can further place a given entity into a referential context and use this as a weighting factor.
 This is to be explored in future work.
 The experience thus far shows that we greatly benefit from Virtuoso being a general purpose DBMS, as we can create application specific data structures and control flows where these are efficient.
 For example, it would make little sense to store entity ranks as triples due to space consumption and locality considerations.
 With these tools, the whole ranking functionality took under a week to develop.</p>
<p> </p>
<h3><a name="Query Evaluation Time Limits"></a> Query Evaluation Time Limits</h3>
<p>When scaling the Linked Data model, we have to take it as a given that the workload will be unexpected and that the query writers will often be unskilled in databases.
 Insofar possible, we wish to promote the forming of a culture of creative reuse of data.
 To this effect, even poorly formulated questions deserve an answer that is better than just timeout.</p>
<p>If a query produces a steady stream of results, interrupting it after a certain quota is simple.
 However, most interesting queries do not work in this way.
 They contain aggregation, sorting, maybe transitivity.</p>
<p>When evaluating a query with a time limit in a cluster setup, all nodes monitor the time left for the query.
 When dealing with a potentially partial query to begin with, there is little point in transactionality.
 Therefore the facet service uses read committed isolation.
 A read committed query will never block since it will see the before-image of any transactionally updated row.
 There will be no waiting for locks and timeouts can be managed locally by all servers in the cluster.</p>
<p>Thus, when having a partitioned count, for example, we expect all the partitions to time out around the same time and send a ready message with the timeout information to the cluster node coordinating the query.
 The condition raised by hitting a partial evaluation time limit differs from a run time error in that it leaves the query state intact on all participating nodes.
 This allows the timeout handling to come fetch any accumulated aggregates.</p>
<p>Let us consider the query for the top 10 classes of things with &quot;Shakespeare&quot; in some literal.
 This is typical of the workload generated by the faceted browsing web service:</p>
<br><pre>DEFINE  input:inference  &quot;yago&quot;
SELECT ?c 
       COUNT (*) 
WHERE 
  {
    ?s  a             ?c             ; 
        ?p            ?o             .
    ?o  bif:contains  &quot;Shakespeare&quot;
  } 
GROUP BY ?c 
ORDER BY DESC 2 
LIMIT 10
</pre><p> On the first execution with an entirely cold cache, this times out after 2 seconds and returns:</p>
<br><pre>?c                                       COUNT (*)
yago:class/yago/Entity100001740          566
yago:class/yago/PhysicalEntity100001930  452
yago:class/yago/Object100002684          452
yago:class/yago/Whole100003553           449
yago:class/yago/Organism100004475        375
yago:class/yago/LivingThing100004258     375
yago:class/yago/CausalAgent100007347     373
yago:class/yago/Person100007846          373
yago:class/yago/Abstraction100002137     150
yago:class/yago/Communicator109610660    125
</pre><p> The next repeat gets about double the counts, starting with 1291 entities.</p>
<p>With a warm cache, the query finishes in about 300 ms (4 core Xeon, Virtuoso 6 Cluster) and returns:</p>
<br><pre>?c                                       COUNT (*)
yago:class/yago/Entity100001740          13329
yago:class/yago/PhysicalEntity100001930  10423
yago:class/yago/Object100002684          10408
yago:class/yago/Whole100003553           10210
yago:class/yago/LivingThing100004258      8868
yago:class/yago/Organism100004475         8868
yago:class/yago/CausalAgent100007347      8853
yago:class/yago/Person100007846           8853
yago:class/yago/Abstraction100002137      3284
yago:class/yago/Entertainer109616922      2356
</pre><p> It is a well known fact that running from memory is thousands of times faster than from disk.</p>
<p>The query plan begins with the text search.
 The subjects with &quot;Shakespeare&quot; in some property get dispatched to the partition that holds their class.
 Since all partitions know the class hierarchy, the superclass inference runs in parallel, as does the aggregation of the group by.
 When all partitions have finished, the process coordinating the query fetches the partial aggregates, adds them up and sorts them by count.</p>
<p>If a timeout occurs, it will most likely occur where the classes of the text matches are being retrieved.
 When this happens, this part of the query is reset, but the aggregate states are left in place.
 The process coordinating the query then goes on as if the aggregates had completed.
 If there are many levels of nested aggregates, each timeout terminates the innermost aggregation that is still accumulating results, thus a query is guaranteed to return in no more than n timeouts, where n is the number of nested aggregations or subqueries.</p>
<h3><a name="Facets Web Service"></a>Facets Web Service</h3>
<p>The Virtuoso Facets web service is a general purpose RDF query facility for facet based browsing.
 It takes an XML description of the view desired and generates the reply as an XML tree containing the requested data.
 The user agent or a local web page can use XSLT for rendering this for the end user.
 The selection of facets and values is represented as an XML tree.
 The rationale for this is the fact that such a representation is easier to process in an application than the SPARQL source text or a parse tree of SPARQL and more compactly captures the specific subset of SPARQL needed for faceted browsing.
 All such queries internally generate SPARQL and the SPARQL generated is returned with the results.
 One can therefore use this is a starting point for hand crafted queries.</p>
<p>The query has the top level element <query>.
 The child elements of this represents conditions pertaining to a single subject.
 A join is expressed with the property or propertyof element.
 This has in turn children which state conditions on a property of the first subject.
 Property and propertyof elements can be nested to an arbitrary depth and many can occur inside one containing element.
 In this way, tree-shaped structures of joins can be expressed.</query></p>
<p>Expressing more complex relationships, such as intermediate grouping, subqueries, arithmetic or such requires writing the query in SPARQL.
 The XML format is for easy automatic composition of queries needed for showing facets, not a replacement for SPARQL.</p>
<p>Consider composing a map of locations involved with Napoleon.
 Below we list user actions and the resulting XML query descriptions.</p>
<p> </p>
<ul><li>Enter in the search form &quot;Napoleon&quot;: <br><pre><br>&lt;query inference=&quot;&quot; same-as=&quot;&quot; view3=&quot;&quot; s-term=&quot;e&quot; c-term=&quot;type&quot;&gt;
  &lt;text&gt;napoleon&lt;/text&gt;
  &lt;view type=&quot;text&quot; limit=&quot;20&quot; offset=&quot;&quot; /&gt;
&lt;/query&gt;
</pre><br></li>
<li>Select the &quot;types&quot; view: <br><pre><br>&lt;query inference=&quot;&quot; same-as=&quot;&quot; view3=&quot;&quot; s-term=&quot;e&quot; c-term=&quot;type&quot;&gt;
  &lt;text&gt;napoleon&lt;/text&gt;
  &lt;view type=&quot;classes&quot; limit=&quot;20&quot; offset=&quot;0&quot; location-prop=&quot;0&quot; /&gt;
&lt;/query&gt;
</pre><br></li>
<li>Choose &quot;MilitaryConflict<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/MilitaryConflict&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a>&quot; type: <br><pre><br>&lt;query inference=&quot;&quot; same-as=&quot;&quot; view3=&quot;&quot; s-term=&quot;e&quot; c-term=&quot;type&quot;&gt;
  &lt;text&gt;napoleon&lt;/text&gt;
  &lt;view type=&quot;classes&quot; limit=&quot;20&quot; offset=&quot;0&quot; location-prop=&quot;0&quot; /&gt;
  &lt;class iri=&quot;yago:ontology/MilitaryConflict&quot; /&gt;
&lt;/query&gt;
</pre><br></li>
<li>Choose &quot;NapoleonicWars<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/NapoleonicWars&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a>&quot;: <br><pre><br>&lt;query inference=&quot;&quot; same-as=&quot;&quot; view3=&quot;&quot; s-term=&quot;e&quot; c-term=&quot;type&quot;&gt;
  &lt;text&gt;napoleon&lt;/text&gt;
  &lt;view type=&quot;classes&quot; limit=&quot;20&quot; offset=&quot;0&quot; location-prop=&quot;0&quot; /&gt;
  &lt;class iri=&quot;yago:ontology/MilitaryConflict&quot; /&gt;
  &lt;class iri=&quot;yago:class/yago/NapoleonicWars&quot; /&gt;
&lt;/query&gt;
</pre><br></li>
<li>Select &quot;any location&quot; in the select list beside the &quot;map&quot; link; then hit &quot;map&quot; link: <br><pre><br>&lt;query inference=&quot;&quot; same-as=&quot;&quot; view3=&quot;&quot; s-term=&quot;e&quot; c-term=&quot;type&quot;&gt;
  &lt;text&gt;napoleon&lt;/text&gt;
  &lt;class iri=&quot;yago:ontology/MilitaryConflict&quot; /&gt;
  &lt;class iri=&quot;yago:class/yago/NapoleonicWars&quot; /&gt;
  &lt;view type=&quot;geo&quot; limit=&quot;20&quot; offset=&quot;0&quot; location-prop=&quot;any&quot; /&gt;
&lt;/query&gt;
</pre><br> This last XML fragment corresponds to the below text of SPARQL query:</li>
</ul><p> </p>
<br><pre>SELECT ?location AS ?c1 
       ?lat1     AS ?c2 
       ?lng1     AS ?c3
WHERE 
  {
    ?s1        ?s1textp  ?o1                              .
    FILTER 
      ( bif:contains (?o1, &#39;&quot;Napoleon&quot;&#39;) )  .
    ?s1        a         &lt;yago:ontology/MilitaryConflict&gt;  .
    ?s1        a         &lt;yago:class/yago/NapoleonicWars&gt;  .
    ?s1        ?anyloc   ?location                         .
    ?location  geo:lat   ?lat1                             ; 
               geo:long  ?lng1
  }
LIMIT 200 
OFFSET 0
</pre><p> The query takes all subjects with some literal property with &quot;Napoleon&quot; in it, then filters for military conflicts and Napoleonic wars, then takes all objects related to these where the related object has a location.
 The map has the objects and their locations.</p>
<p>Figure 1: The displayed result</p>
<h3><a name=""></a> VoID<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VoID&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> Discoverability</h3>
<p>A long awaited addition to the LOD cloud is the Vocabulary of Interlinked Data (<a href="http://www.w3.org/TR/void/" class="absuri">VoID</a>)[10].
 Virtuoso automatically generates VoID<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VoID&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> descriptions of data sets it hosts.
Virtuoso incorporates an SQL function <code>rdf_void_gen</code> which returns a Turtle representation of a given graph&#39;s VoID<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VoID&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> statistics.</p>
<p> </p>
<h3><a name="Test System and Data"></a>Test System and Data</h3>
<p>The test system consists of two 2x4 core Xeon 5345, 2.33 GHz servers with 16G RAM and 4 disks each.
 The machines are connected by two 1Gbit Ethernet connections.
The software is Virtuoso 6 Cluster.
 The Virtuoso server is split into 16 partitions, 8 for each machine.
 Each partition is managed by a separate server process.</p>
<p>The test database has the following data sets:</p>
<ul><li>DBpedia 3.2 </li>
<li>MusicBrainz<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/MusicBrainz&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> </li>
<li>Bio2RDF </li>
<li>NeuroCommons<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/NeuroCommons&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> </li>
<li>UniProt<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/UniProt&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> </li>
<li>Freebase (95M triples) </li>
<li>PingTheSemanticWeb<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/PingTheSemanticWeb&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> (1.6M miscellaneous files from <a href="http://www.pingthesemanticweb.com/)." class="absuri">http://www.pingthesemanticweb.com/).</a></li>
</ul><p>Ontologies:</p>
<ul><li>Yago </li>
<li>OpenCyc<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenCyc&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> </li>
<li>Umbel </li>
<li>DBpedia</li>
</ul><p>The database is 2.2 billion triples with 356 million distinct URIs.</p>
<h3><a name="Future Work"></a>Future Work</h3>
<p>All the functions discussed above are presently being productized for delivery with Virtuoso 6, so that single servers are open source and clusters commercial only.
 The most relevant future work is thus final debugging and tuning of existing functionality.</p>
<p>The technology will be first commercially used as a platform for an Amazon EC2 offering of the whole LOD cloud on a cluster of servers.
 This complements the existing line of data sets pre-packaged by <a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenLink" class="wikiword">OpenLink</a>[11].</p>
<p>For more sophisticated, also editable user facing functionality, <a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenLink" class="wikiword">OpenLink</a> is presently working with the developers of OntoWiki<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OntoWiki&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a>[12] on integrating the functionality discussed here into OntoWiki<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OntoWiki&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> as a new large-scale back-end.
 From this development, we expect to have the functional equivalent of Freebase[13], except with more data, working with open, standard data models, being more integrable and above all having a full range of deployment options.
 This means anything from the desktop to the data center with either software as service or installation at end user sites as options.</p>
<p>We presently rank search results on text match scores and link density around the URIs related to the text hits.
 We expect having semantics associated with links to open new possibilities in this domain.
 We plan to leverage link semantics for ranking but as of this writing have not extensively explored this.</p>
<h3><a name="Conclusions"></a>Conclusions</h3>
 We have presented a set of query processing techniques and a web service and user interface for interactive browsing of a large corpus of linked data.
 We have shown significant scalability on low cost server hardware, with open ended scale out capacity for larger data set sizes and more concurrent usage.<p>The service described is online and is also packaged with Virtuoso 6 open source distributions.</p>
<p>The technical experience derived from developing this service emphasizes the following:</p>
<ul><li>Central importance of a SPARQL/SQL cost model that is aware of hierarchies and is capable of sampling data as needed.
 Without the right execution plan, no amount of hardware will save the day.
</li>
<li>The importance of enforcing a cap on resource usage.
</li>
<li>The need for scale-out in order to have enough data in memory.
 Disk is a far greater bottleneck than processor or network speed.
 Scaling out in a shared nothing fashion is by far the most economical and scalable means of increasing total memory, disk bandwidth and processing power.
</li>
<li>Additional verification of our capacity to schedule parallel query processing on a distributed memory cluster without being killed by latency.
</li>
<li>Confirmation of the Virtuoso platform&#39;s flexibility for building additional data intensive services, such as entity ranking.</li>
</ul><p>Present work is therefore concentrated on refining and productizing the platform and its RDF applications.
 We believe this to be a significant infrastructure element enabling the take off of linked data.</p>
<p> </p>
<h3><a name="Tutorials"></a>Tutorials</h3>
<ul><li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoLODSampleTutorial" class="wikiword">Faceted Browsing Sample using LOD Cloud Cache data space</a>.</li>
</ul><h2><a name="Related"></a>Related</h2>
<ul><li>Facets Web Service: <ul><li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoFacetsWebService" class="wikiword">Virtuoso Facets Web Service</a> </li>
</ul></li>
<li>Facet Browser Installation and configuration: <ul><li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtFacetBrowserInstallConfig" class="wikiword">Virtuoso Facet Browser Installation and configuration</a> </li>
</ul></li>
<li>Facet APIs: <ul><li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtFacetBrowserAPIs" class="wikiword">Virtuoso APIs for FCT REST services</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtFacetBrowserAPIsFCTEXEC" class="wikiword"><code><nowiki>fct_exec</nowiki></code> API Example</a> </li>
</ul></li>
<li>Pivot Viewer and CXML: <ul><li><a href="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VirtSparqlCxmlFacetPivotBridge#AncSparqlCxmlFacetPivotBridge" class="absuri">Facet Pivot Bridge -  A bridge to PivotViewer from Virtuoso&#39;s Faceted query service for RDF</a> </li>
<li><a href="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VirtSparqlCxml#AncFacetTypeAutoDetection" class="absuri">Auto-Detection of Facet Type</a> </li>
</ul></li>
<li>Tutorials: <ul><li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoLODSampleTutorial" class="wikiword">Faceted Browsing Sample using LOD Cloud Cache data space</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoFacetsWebServiceSOAPExample" class="wikiword">SOAP Facets Example</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtFacetBrowserInstallConfigQueried" class="wikiword">Querying The Facet Browser Web Service endpoint</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtFCTFeatureQueries" class="wikiword">Virtuoso Facet Browser Featured Queries</a> </li>
<li><a href="http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/VirtVisualizeWithPivotViewer#GenFCT" class="absuri">Visualizing Your Data With PivotViewer Using The Facet Browser</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtTipsAndTricksCustomControlLabelsURI" class="wikiword">Custom Controlling Virtuoso Labels for URI functionality Example</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoFacetsWebServiceCustmExamples" class="wikiword">Facets Web Service: Examples for customizing different types</a> </li>
<li><a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/VirtuosoFacetsWebServiceChoiceExample" class="wikiword">Facets Web Service: Choice of Labels Example</a> </li>
</ul></li>
<li>Downloads: <ul><li><a href="http://shop.openlinksw.com/license_generator/virtuoso-download/" class="absuri">Latest Virtuoso</a> </li>
<li><a href="https://virtuoso.openlinksw.com/download/" class="absuri">Virtuoso Facet Browser VAD package</a></li>
</ul></li>
</ul><h2><a name="References"></a>References</h2>
<p>[1] Suchanek, F.M.; Kasneci, G.; Weikum, G.: YAGO: A Core of Semantic Knowledge Unifying WordNet<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/WordNet&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> and Wikipedia.
 WWW2007, ACM 978-1-59593-654-7/07/0005.</p>
<p>[2] Overview of OpenCyc<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenCyc&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a>.
 <a href="http://www.cyc.com/cyc/opencyc/overview" class="absuri">http://www.cyc.com/cyc/opencyc/overview</a></p>
<p>[3] UMBEL Ontology, Vol.
 1: Technical Documentation, TR 08-08-28-A1.
<a href="http://www.umbel.org/doc/UMBELOntology+vA1.pdf" class="absuri">http://www.umbel.org/doc/UMBELOntology+vA1.pdf</a></p>
<p>[4] Auer, S.; Bizer, C.; Lehmann, J.; Kobilarov, G.; Cyganiak, R.; Ives, Z.: DBpedia: A Nucleus for a Web of Open Data.
 In Aberer et al.
 (Eds.): The Semantic Web, 6th International Semantic Web Conference, 2nd Asian Semantic Web Conference, ISWC 2007 + ASWC 2007, Busan, Korea, November 11-15, 2007.
 LNCS 4825 Springer 2007, ISBN 9783-540762973.</p>
<p>[5] The National Center for Biomedical Ontology: Resources.
<a href="http://bioontology.org/repositories.html" class="absuri">http://bioontology.org/repositories.html</a></p>
<p>[6] <a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenLink" class="wikiword">OpenLink</a> Software, Inc.
 Virtuoso 6 FAQ.
<a href="http://virtuoso.openlinksw.com/Whitepapers/html/Virt6FAQ.html" class="absuri">http://virtuoso.openlinksw.com/Whitepapers/html/Virt6FAQ.html</a></p>
<p>[7] Brickley, D.; Miller, L.: FOAF Vocabulary Specification 0.91.
<a href="http://xmlns.com/foaf/spec/" class="absuri">http://xmlns.com/foaf/spec/</a></p>
<p>[8] Bojars, U.; Breslin, J.G.
 (eds.): SIOC Core Ontology Specification.
<a href="http://rdfs.org/sioc/spec/" class="absuri">http://rdfs.org/sioc/spec/</a></p>
<p>[9] Erling, O.: &quot;E Pluribus Unum&quot;, or &quot;Inversely Functional Identity&quot;, or &quot;Smooshing Without the Stickiness&quot;.
<a href="http://www.openlinksw.com/weblog/oerling/?id=1498" class="absuri">http://www.openlinksw.com/weblog/oerling/?id=1498</a></p>
<p>[10] Hausenblas, M.: Discovery and Usage of Linked Datasets on the Web of Data.
NodMag<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/NodMag&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> #4.
 Available at <a href="http://www.talis.com/nodalities/pdf/nodalities+issue4.pdf" class="absuri">http://www.talis.com/nodalities/pdf/nodalities+issue4.pdf</a></p>
<p>[11] <a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OpenLink" class="wikiword">OpenLink</a> Software, Inc.
 Virtuoso Universal Server (Cloud Edition) AMI for EC2.
<a href="http://virtuoso.openlinksw.com/wiki/main/Main/VirtuosoEC2AMI" class="absuri">http://virtuoso.openlinksw.com/wiki/main/Main/VirtuosoEC2AMI</a></p>
<p>[12] Auer, S.; Dietzold, S.; Riechert, T.: OntoWiki<a href="http://vos.openlinksw.com:80/dataspace/owiki/wiki/VOS/OntoWiki&parent=VirtuosoFacetsViewsLinkedData" class="wikiword">?</a> A Tool for Social, Semantic Collaboration.
 5th International Semantic Web Conference, Nov 5th?9th, Athens, GA, USA.
 In I.
 Cruz et al.
 (Eds.): ISWC 2006, LNCS 4273, pp.
 736-749, 2006.
Springer-Verlag Berlin Heidelberg 2006.</p>
<p>[13] Metaweb Technologies, Inc.: What is Freebase? <a href="http://www.freebase.com/view/en/what+is+freebase" class="absuri">http://www.freebase.com/view/en/what+is+freebase</a></p>
<p>[14] Stoermer, H.: Entity Name System: The Back-bone of an Open and Scalable Web of Data.
 In: Proceedings of the IEEE International Conference on Semantic Computing, ICSC 2008, number CSS-ICSC 2008-4-28-25.
 IEEE, August 2008.
 Available at <a href="http://www.okkam.org/publications/stoermer-EntityNameSystem.pdf" class="absuri">http://www.okkam.org/publications/stoermer-EntityNameSystem.pdf</a></p>
<p>[15] Brin, S., Page, L.: The Anatomy of a Large-Scale Hypertextual Web Search Engine.
In: Seventh International World-Wide Web Conference (WWW 1998), April 14-18, 1998, Brisbane, Australia.
 Available at <a href="http://ilpubs.stanford.edu:8090/361/" class="absuri">http://ilpubs.stanford.edu:8090/361/</a> </p>
</div></body></html>