# XML Support

# Rendering SQL Queries as XML (FOR XML Clause)

Virtuoso extends SQL-92 with the FOR XML clause that allows any SQL
result set to be turned into XML according to some simple rules. The
notation and functionality are similar to those offered by Microsoft SQL
Server and IIS.

The FOR XML clause has 3 variants:

**RAW.**

Make an XML entity from each row of the result set; do not attempt to
construct hierarchies. Each row's data is enclosed in a \<ROW/\> element
and each column is either an attribute or child element.

**AUTO.**

A hierarchy is constructed with one level for each table of the join for
which at least one column is selected. The table whose column is first
mentioned in the selection will be the topmost element, the next table
its child, etc. Each level of the tree will consist of one type of
element. A parent element will have multiple children if consecutive
rows do not differ in the column values coming from the parent element.
When a table's column values differ from the previous row, the element
and all children thereof are closed and a new element is started, with
children filled out from other columns of the result set.

**EXPLICIT.**

This mode gives more control on the resulting tree's structure while
requiring a more elaborate query structure. In this mode, the query will
be a UNION ALL of many joins and each row will specify exactly one
element. Which type of element this is and where in the tree it will be
placed are determined by the values of the first two columns, TAG and
PARENT.

In all modes, columns may either be attributes or sub-elements. The
*ELEMENT* keyword after the FOR XML clause forces all columns to be
rendered as sub-elements; attribute are the default.

In all modes except explicit, the names of elements are the unprefixed
table names and the names of attributes are the columns' names in the
result set. If tables have correlation names the correlation names are
used in the output instead of the table names. Expressions are allowed
in the selections but these should be named using AS. In AUTO mode
Virtuoso assumes expressions belong to the topmost element.

The FOR XML clause is generally allowed in SELECT statements in place of
the FOR UPDATE clause. However it only has an effect when the statement
is executed through the [`xml_auto()`](#fn_xml_auto) function.

> **Tip**
> 
> The [SQL-XML Statements](#sqlxmlstmts) page described in the Visual
> Server Administration Interface section provides a fast graphical way
> of supplying an SQL statement to Virtuoso and saving the view as a
> resource accessible from the WebDAV store.

## FOR XML EXPLICIT Mode

This mode gives the developer the most control over the generated result
tree but requires a verbose query formulation. Each row must begin with
two integer columns, the first identifying the element represented by
the row and the second the parent element type of this element.
Consider:

    select 1 as tag, null as parent,
           "CategoryID" as [category!1!cid],
           "CategoryName" as [category!1!name],
           NULL as [product!2!pid],
           NULL as [product!2!name!element]
    from "Demo".."Categories"
    union all
    select 2, 1, "category" ."CategoryID", NULL, "ProductID", "ProductName"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID"
    order by [category!1!cid], 5
    for xml explicit;

This query makes a two level tree where Categories have Product
children. The selection in the first UNION term specifies the element
types in the result set. The two first columns, TAG and PARENT are
required in all EXPLICIT queries. Subsequent columns have an extended AS
declaration that specifies which element they belong to, what that
element is called in XML and what the column will be called. A row where
TAG has a value of 1 will pick the columns which has \[xxx\!1\!yyy\] as
their alias; rows with a TAG of 2 will pick columns with an alias with
\[xxx\!2\!yyy\] and so on.

If consecutive rows have a different TAG but the same PARENT, these will
be siblings of different types. This possibility does not exist with the
other FOR XML modes.

If the PARENT is 0 or NULL, then any previously open elements in the
result are closed and the element of the row becomes a top-level
element. When PARENT refers to the TAG of a presently open element in
the set, all children of that element are closed and the row's element
is inserted as the next child of the last element with the TAG equal to
the new row's PARENT. All open tags are closed at the end of the result
set.

> **Note**
> 
> Since each level of the tree is generated by a different term in the
> UNION ALL, an ORDER BY will invariably be needed to group the children
> after their parents. If the parent rows have NULLs in place of the
> child row's key values, the parent gets sorted first because NULL
> collates first.

## Examples of FOR XML

This section gives one example of each mode of FOR XML combined with the
`xml_auto()` function to help us display the results simply. First we
create a procedure that enables us to supply SQL and return XML using
the `xml_auto()` function.

    create procedure xmla (in q varchar)
    {
      declare st any;
      st := string_output ();
      xml_auto (q, vector (), st);
      result_names (q);
      result (string_output_string (st));
    }

Now we can apply this to a couple of examples:

    xmla ('select "category"."CategoryID", "CategoryName",
        "ProductName", "ProductID"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID" FOR XML RAW');

    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Chai" ProductID="1">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Chang" ProductID="2">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Guaraná Fantástica" ProductID="24">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Sasquatch Ale" ProductID="34">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Steeleye Stout" ProductID="35">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Côte de Blaye" ProductID="38">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Chartreuse verte" ProductID="39">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Ipoh Coffee" ProductID="43">
    </ROW>
    <ROW CategoryID="1" CategoryName="Beverages" ProductName="Laughing Lumberjack Lager" ProductID="67">
    </ROW>
    .....

As we can see, RAW mode produces a simple row-by-row account of the data
encased within the \<ROW.../\> tags. This is the simplest mode.

    xmla ('select "category"."CategoryID", "CategoryName",
        "ProductName", "ProductID"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID" FOR XML AUTO ELEMENT');

    <category>
     <CategoryID>1</CategoryID> <CategoryName>Beverages</CategoryName><product>
     <ProductName>Chai</ProductName> <ProductID>1</ProductID></product>
    <product>
     <ProductName>Chang</ProductName> <ProductID>2</ProductID></product>
    <product>
     <ProductName>Guaraná Fantástica</ProductName> <ProductID>24</ProductID></product>
    <product>
     <ProductName>Sasquatch Ale</ProductName> <ProductID>34</ProductID></product>
    <product>
     <ProductName>Steeleye Stout</ProductName> <ProductID>35</ProductID></product>
    <product>
     <ProductName>Côte de Blaye</ProductName> <ProductID>38</ProductID></product>
    <product>
     <ProductName>Chartreuse verte</ProductName> <ProductID>39</ProductID></product>
    <product>
     <ProductName>Ipoh Coffee</ProductName> <ProductID>43</ProductID></product>
    <product>
     <ProductName>Laughing Lumberjack Lager</ProductName> <ProductID>67</ProductID></product>
    <product>
    .....

In contrast to RAW mode, AUTO produces results that are more tree-like.
Only one category element is used for each category, and that contains
all the children of the category.

    xmla ('
    select 1 as tag, null as parent,
           "CategoryID" as [category!1!cid],
           "CategoryName" as [category!1!name],
           NULL as [product!2!pid],
           NULL as [product!2!name!element]
    from "Demo".."Categories"
    union all
    select 2, 1, "category" ."CategoryID", NULL, "ProductID", "ProductName"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID"
    order by [category!1!cid], 5
    FOR XML EXPLICIT');

    <CATEGORY CID="1" NAME="Beverages">
    <PRODUCT PID="1">
     <NAME>Chai</NAME></PRODUCT>
    <PRODUCT PID="2">
     <NAME>Chang</NAME></PRODUCT>
    <PRODUCT PID="24">
     <NAME>Guaraná Fantástica</NAME></PRODUCT>
    <PRODUCT PID="34">
     <NAME>Sasquatch Ale</NAME></PRODUCT>
    <PRODUCT PID="35">
     <NAME>Steeleye Stout</NAME></PRODUCT>
    <PRODUCT PID="38">
     <NAME>Côte de Blaye</NAME></PRODUCT>
    <PRODUCT PID="39">
     <NAME>Chartreuse verte</NAME></PRODUCT>
    <PRODUCT PID="43">
     <NAME>Ipoh Coffee</NAME></PRODUCT>
    <PRODUCT PID="67">
     <NAME>Laughing Lumberjack Lager</NAME></PRODUCT>
    <PRODUCT PID="70">
     <NAME>Outback Lager</NAME></PRODUCT>
    <PRODUCT PID="75">
     <NAME>Rhönbräu Klosterbier</NAME></PRODUCT>
    <PRODUCT PID="76">
     <NAME>Lakkalikööri</NAME></PRODUCT>
    </CATEGORY>
    <CATEGORY CID="2" NAME="Condiments">
    <PRODUCT PID="3">
    .....

In this example, we specify precisely the tree structure we wish, and
construct the EXPLICIT query to produce that tree. Many times
programmers know what the resulting XML should look like but do not know
how to get exactly what they want. FOR XML EXPLICIT can be very useful
in these cases.

## Functions

[`xml_auto()`](#fn_xml_auto)

## FOR XML Syntax

    for__xml ::= FOR XML <mode> [ ELEMENT ]
    
    <mode> ::= RAW | AUTO | EXPLICIT
    
    <explicit column> ::=  scalar_exp AS '[' <element> '!' <tag no> '!'
                       <column name> [ '!' <option> ] ']'
    
    <tag no> ::= INTNUM
    
    <column name> ::= IDENTIFIER
    
    <element> ::= IDENTIFIER
    
    <option> ::= IDENTIFIER

The \<explicit column\> should be used in the selection list of the
first term of the UNION ALL construct in a FOR XML EXPLICIT query.
Virtuoso provides this functionality separately from any Web server
context, although these are principally expected to be used inside VSP
pages.

The text of \<option\> part of the \<explicit column\> is ignored but if
it is present then the value is placed into a sub-element of the element
for the row, not into an attribute.

# XML Composing Functions in SQL Statements (SQLX)

The preferred means of constructing XML data from SQL is to use the
standard SQLX SQL extension.

SQLX is a collection of functions added for creating XML entities from
standard relational queries. Basically, you write a SQL statement with
calls to SQLX functions in the selection and a piece of XML is created.

There are five XML composing functions:

XMLELEMENT()

creates a single XML element that can contain an arbitrary number of
attributes and sub-elements.

XMLATTRIBUTES()

lists XML attributes to be placed in the XML element created by an
enclosing call of

XMLELEMENT()

.

XMLCONCAT()

returns a forest of XML values by concatenating a list of XML values or
forests.

XMLAGG()

is an aggregate function that creates a forest of XML values by
concatenating the XML values that are returned from multiple rows.

XMLFOREST()

is similar to

XMLATTRIBUTES()

but returns a forest of elements instead of list of attributes.

These functions belong to the SQLX standard, an emerging SQL standard
for XML. All the functions take a variable number of arguments.

`XMLELEMENT` is used to construct XML elements from relational data. It
takes as parameters the element name, an optional collection of
attributes for the element (returned by `XMLATTRIBUTES` call), column
names, strings, `XMLELEMENT` , `XMLFOREST` , `XMLCONCAT` , and `XMLAGG`
calls, and an entity objects (returned by corresponding functions, e.g.
`xtree_doc` , `xpath_eval` , `xquery_eval` ) which will make up the
content of the element (an exception from this is an attribute entity
returned by `xquery_eval` - in this case it is joined to the list of the
element's attributes). Column names, strings and attribute entities
returned by `xpath_eval` will make up the text content of the element.
The others will make up the children of the element.

In the `XMLATTRIBUTES` clause, the value expressions are evaluated to
get the values for the attributes.

`XMLFOREST` produces a forest of XML elements from a given list of
arguments. It accepts a list of SQL value expressions as its arguments,
and produces an XML element from each value returned.

`XMLCONCAT` produces a forest of elements by concatenating a list of XML
values. XMLCONCAT accepts a list of XML value expressions as its
arguments, and produces a forest of elements by concatenating the XML
values that are returned from the same row to make one value. If an
argument of the `XMLCONCAT` is an entity object returned by
`xquery_eval` or `path_eval` , it must not be an attribute.

The following statements create the same result sets:

    select XMLELEMENT ('Person',
                            XMLELEMENT ('firstname', "FirstName"),
                            XMLELEMENT ('lastname', "LastName"),
                    xquery_eval('//country', xtree_doc('<a><country>USA</country></a>')))
    from "Demo"."demo"."Employees";
    
    select
          XMLELEMENT ('Person',
                            XMLFOREST ("FirstName"as "firstname", "LastName" as "lastname"),
                    xquery_eval('//country', xtree_doc('<a><country>USA</country></a>')))
    from "Demo"."demo"."Employees";
    
    select
          XMLELEMENT ('Person',
                                 XMLCONCAT (
                                            XMLELEMENT ('firstname', "FirstName"),
                                            XMLELEMENT ('lastname', "LastName"),
                                    xquery_eval('//country', xtree_doc('<a><country>USA</country></a>'))))
    from "Demo"."demo"."Employees";

> **Note**
> 
> The second statement is more effective than the others.

In order to return more than one row of values, you can use `XMLAGG` .
`XMLAGG` is an aggregate function that produces a forest of XML elements
from a collection of XML elements. It concatenates the values returned
from one column of multiple rows, unlike XMLCONCAT, which concatenates
the values returned from multiple columns in the same row.

The parameters that would be used as element names (in the `XMLELEMENT`
and in the 'AS clause ' of the `XMLFOREST` and `XMLATTRIBUTES` ) must be
valid XML names. If the 'AS clause ' is absent in a list of the
parameters of the `XMLFOREST` or `XMLATTRIBUTES` , Virtuoso uses the
partially escaped form of the column name as the element or attribute
name. The partially escaped form means that SQL \<identifier\>
characters that are valid characters in a XML NAME are not changed, SQL
\<identifier\> character that is not valid XML NAME character is
replaced with "\_xHHHH\_", where HHHH is character's upper case
hexadecimal code. For example, "first\_name" is replaced with
"first\_x005F\_name", "last name" is replaced with "last\_x0020\_name".

The following example creates an 'FullAddress' element with

  - four attributes, three of them ('PostalCode', 'Address', 'City') are
    produced by `XMLATTRIBUTES`, and the fourth attribute - 'country' is
    calculated by `xquery_eval
    `

  - 'Region' subelement, that is produced by `xtree_doc
    `

  - text content, that is produced by `xpath_eval
    `

  - 'emp' subelement with text content from the column "LastName", that
    is created by nested`XMLELEMENT`

<!-- end list -->

``` 
select XMLELEMENT ('FullAddress',
                        XMLATTRIBUTES ( "PostalCode", "Address", "City"),
                        xtree_doc ('<Region>WA</Region>'),
                        xquery_eval('//@country', xtree_doc('<a country="USA"/>')),
                        xpath_eval('//@Phone', xtree_doc('<a Phone="(206) 555-9857"/>')),
                        XMLELEMENT('emp', "LastName"))
from "Demo"."demo"."Employees"

----------------------------

   <FullAddress PostalCode="98122" Address="507 - 20th Ave. E. Apt. 2A" City="Seattle" country="USA">
        <Region>WA</Region>
        (206) 555-9857
        <emp>Davolio</emp>
    </FullAddress>
    <FullAddress PostalCode="98401" Address="908 W. Capital Way" City="Tacoma" country="USA">
        <Region>WA</Region>
        (206) 555-9857
        <emp>Fuller</emp>
    </FullAddress>
  . . .

 
```

> **Tip**
> 
> [XMLAGG()](#fn_xmlagg)
> 
> [XMLATTRIBUTE()](#fn_xmlattributes)
> 
> [XMLCONCAT()](#fn_xmlconcat)
> 
> [XMLELEMENT()](#fn_xmlelement)
> 
> [XMLFOREST()](#fn_xmlforest)

XML composing functions deal with arguments of arbitrary type, but the
result is always an XML entity that can contain only elements and
strings. Hence there is a set of type casting rules. These rules are
quite common for any XML DOM model, so they're similar to those listed
for [DOM function arguments](#xmldomtypecasting) :

If an instance of XMLType is passed then its internal XML entity is
used.

If an array representation of an XML tree entity is passed then it is
used exactly like XML entity.

If an argument is NULL then it is fully ignored, as if there is no such
argument at all.

If an argument is not of a type listed above and not a string then it is
cast to a string first.

A root node of some document (or of some generic XML entity) can not
appear in the middle of the resulting tree. So if a root node is passed
then all child nodes of the root (i.e. every top-level node of the
document) will be added.

SQL/XML standards introduce a special name "forest of XML elements" for
an ordered list of XML elements, like one returned by `XMLFOREST()` . In
Virtuoso, forest can contain XML nodes of any sort, not only XML
elements, so it can also contain strings, processing instructions and
comments. Virtuoso processes any non-empty "forest" as if it were the
root node of a "generic XML entity", and items of the forest were
top-level nodes of that entity. Hence, a forest can be passed to any
function that accepts an value of type "XML entity". The only potential
problem is that this entity is well-formed if and only if the forest is
non-empty. If an empty forest is serialized to an XML text then the
result is an empty string that is not an acceptable input for an XML
parser.

It is important to remember that the XML document can not contain two
neighbour text nodes and that the text node can not be an empty string.
If two consequent strings appear in the list of values of a forest or in
the list of children of an new element then they are replaced with a
single node that is a concatenation of these string. Similarly, if an
empty string appears in the list of values of a forest or in the list of
children of an new element then it is removed from the list.

# Virtuoso XML Services

## XPATH Implementation and SQL

Virtuoso offers XPATH as a query language for XML views. The statement
is there converted into SQL in the context of the mapping defined by the
\_\_view XPATH option, which is mandatory. An XPATH query string is a
valid top level SQL statement. This is interpreted as a single select or
union of selects with the result columns being specified by various
XPATH options.

The basic query string

    XPATH [__view "cat"]/category

will select any top level category elements from the cat XML view,
defined with CREATE XML VIEW. This has a single result column with the
serialization string of the selected entity as value. This string starts
with the category start tag and ends with the corresponding end tag. As
many result rows are generated as there are top level category nodes in
the view.

This basic behaviour can be modified by XPATH options enclosed in
brackets after the XPATH keyword. These options allow specifying the
output columns of the generated select statement.

## XPATH Query Options

    <xp option> ::=
        __* | __http | __key   | __view NAME | __tag NAME | __quiet | __base_uri STRING |
        xmlns:NAME '=' STRING | xmlns '=' STRING |
        __lang STRING | __enc STRING | KEYWORD '=' KEYWORD
    
    <option list> ::=  | <option list> '[' <option> [...] ']'

The option list may occur between the XPATH keyword and the start of the
path, e.g.

    XPATH [__key __view "cat"] /category

The effects of the options are as follows:

**\_\_http.**

Send the serialization of the result entities to the HTTP client. This
may only be used inside a VSP page context.

**\_\_key.**

Select the key of the selected entities instead of the serialization
text.

**\_\_\*.**

Select all columns of the selected entity instead of its serialization
text. This is only valid when \_\_view is specified and the result set
is homogeneous.

**\_\_view STRING.**

Specify that the query be interpreted in the context of the specified
CREATE XML VIEW, directly accessing the tables. This is mandatory since
the elements referenced can only be mapped to tables in the context of
an XML view.

**\_\_quiet.**

Specify that the query should not signal non-fatal errors. This option
is for cases when an incomplete result is anyway better than nothing.
Typical example is search in the collection of documents where not all
documents are valid.

**\_\_base\_uri STRING.**

Specify the base URI that can be used to resolve relative URIs in calls
of XPATH functions [`processXQuery()`](#xpf_processxquery) ,
[`processXSLT()`](#xpf_processxslt) and
[`processXSLT()`](#xpf_processxsql) . This is similar to the effect of
"declare base-uri" in XQuery.

**xmlns:NAME '=' STRING.**

This declares a pair of namespace prefix and namespace URI for use in
the query expression, e.g. xmlns:xs="http://www.w3.org/2001/XMLSchema"
or xmlns:ora="http://schemas.oracle.com/xpath/extension"

**xmlns '=' STRING.**

This declares the default namespace URI for use in the query expression,
e.g. xmlns="http://www.example.com/my-schema". This namespace will
become both default element namespace and default function namespace.

**\_\_lang STRING.**

This declares the language that is used for text search expressions.
This is for internationalization purposes only. See subsection ["Adding
New Languages And Encodings Into Virtuoso"](#langfuncapi) for more
details.

**\_\_enc STRING.**

This declares encoding of strings that are used for text search
expressions. This is for internationalization purposes only. See
subsections ["Encoding in XPath Expressions"](#encodingxpathexp) and
["Adding New Languages And Encodings Into Virtuoso"](#langfuncapi) for
more details.

**KEYWORD '=' KEYWORD.**

This is useful only if the expression uses XPATH functions like
[`document()`](#xpf_document) or [`doc()`](#xpf_document) or if the
XPATH expression is an argument of `xpath_contains` or similar special
SQL predicate. These are configuration options that XPATH processor
provides to the XML parser when the processor should read a document.
Section ["Configuration Options of the DTD Validator"](#dtd_config)
lists all supported options.

## XML Views - Representing SQL Data as Dynamic and Persistent XML

The XML view mechanism allows generating XML content from relational
data and to query relational data as if it were XML without first
converting it to XML.

### CREATE XML VIEW statement

    <xml view> ::=
         CREATE XML VIEW <name> as [ <namespaces_def> ] <element list> <opt_public>
    
    <xml view> ::=
         CREATE XML VIEW <name> as [ <namespaces_def> ] <query spec> [ELEMENT] <opt_public>
    
    <namespaces_def> ::= '[' <id_namespace> '='( name | <path string> ) [ ...]  ']'
    
    <element list> ::= <element> [, ...]*
    
    <element> ::=
         <table> <correlation name> AS [ <id_namespace> ':' ] <element> <columns>
         [ ON '('  <search condition> ')']
        [primary key '(' column_commalist ')' ]
        [ELEMENT]
         [ '{' <element list>'}' ]
    
    <opt_public> ::=  PUBLIC <path string> OWNER <DAV owner name> [PERSISTENT] [INTERVAL <minutes>]
    
    <columns> ::= '(' <column> [, ...] ')'
    
    <column> ::=   <column name> | <column name> AS [ <id_namespace> ':' ] <attribute name>
    
    <id_namespace> :: = identifier

The XML view declaration establishes a 'virtual document' a context
within which XML hierarchy relationships can be translated into
arbitrary joins. The virtual document can be then materialized into an
actual set of persistent XML elements or used to generate SQL from
XPATH.

Each table in the declaration generates an element into the result
document. SQL views can be used as tables to accommodate for hidden
joins, sub-queries, ordering and aggregates. If a view is used, which by
nature has no primary key, the primary key clause should be used to
define a uniquely identifying set of view columns.

The only restriction on the XML view declaration is that each branch has
a fixed depth.

The structure of joins used to make the text can be specified in two
ways: As a SQL query specification, that is a SELECT from a list of
tables with a WHERE clause specifying the joins, or as a tree of join
elements. The first form is called automatic and the second is called
explicit. The automatic form allows generating a tree with as many
levels as there are tables in the join, with elements derived from the
rows at each level occupying each level of the hierarchy

With both forms the columns of the tables are mapped into either
attributes or child elements of the element representing each row. In
the explicit mode, the attribute / element choice can be made for each
table, in the automatic mode for the entire view. The explicit mode also
allows specifying a different element / attribute name whereas the
automatic mode takes the name from the column name. Even if the columns
are presented as child elements in the output text, they should be
referenced as attributes in XPATH queries evaluated in the context of
the view.

An XML namespaces can be used in XML view with two restrictions - all
namespace names must be different and the first three letters of
namespace name must not be 'xml', except for default namespace with name
'xmlns'.

### Explicit XML Views

In the explicit form each level of the hierarchy is declared as a list
of child elements. Each such element maps one table or view into an
entity according to a join condition. The join conditions can reference
columns from the associated table and columns from tables in parent
elements. The join condition can also have scalar filtering conditions.
A top element's join condition may only specify scalar conditions.

Each set of sibling child nodes is delimited by braces {}. The top level
of the view typically consists of one element in the outermost braces.
This element has itself a child list delimited by braces. Each such list
can have more than one different element.

Each element specifies:

  - SQL table

  - Correlation name for use in subsequent joins for this table

  - XML element name to use for delimiting a row of this table

  - List of columns, with optional XML element or attribute names

  - join condition - will relate rows of this table to rows of the table
    in the enclosing element. If this element is at the top level, this
    can only consist of scalar conditions

  - Optional PRIMARY KEY clause, needed if the table in this element is
    a view, does not have a primary key or if a non-primary key unique
    identity is desired

  - Optional ELEMENT flag

  - Optional list of child elements, delimited by braces

> **Note**
> 
> A correlation name is mandatory for all the tables.

The column list can mention a single column or a single column renamed
into an XML attribute of a different name. If a column of a table is
referenced in a subsequent join condition it must appear in the output
columns list. Expressions are not directly allowed but a view with
expression columns can be used.

The opt\_public clause, when present, offers a shorthand for calling
xml\_view\_publish at the same time as making the definition. This makes
a DAV resource reflecting the contents of the view. The contents may
either be generated on demand or persisted as a DAV accessible XML
document. In the latter case the document may be regenerated at a fixed
interval. The interval is expressed in minutes.

The path is expressed as an absolute path from the root collection of
the DAV server.

> **Note**
> 
> This root collection may be mapped into various places in the web
> server's URL space.

    create xml view xx ... public '/xx.xml' owner 'dav' persistent interval 1;

is equivalent to:

    create xml view xx ...;
    xml_view_publish (xx, /xx.xml', 'dav', 1, 1);

A DAV resource created in this manner can be deleted as any DAV
resource. The XML view itself is not affected but a possibly existing
refresh job will be automatically deleted.

One XML view can be published several times with different names and
owners. There may also exist persistent and non-persistent publications
of the same view.

The CREATE XML VIEW statement defines stored procedures for generating
an XML text fragment corresponding to each element declared in the view.

The names of the procedures are composed as follows:

    create procedure http_view_<view name>
        (inout output_mode)

    create procedure http_<view name>_<element name>_<correlation name>
        (in pk1 any, ..., in output_mode integer)

An http output procedure is created for each \<element\> in the create
xml view declaration. It takes the primary key columns of the table in
question in key order plus a mode flag. It then outputs the
serialization of the specified element and any child elements. For an
output mode of 0 the result goes directly to an HTTP client. For an
output\_mode of 1 the procedure returns the serialization as a string.
Note that for this to work the tables in question must be real tables
and the join conditions must only reference the next higher table in the
create xml view tree. Further, the primary key columns of each table
should be mentioned in the columns list for that table along with any
foreign keys referenced in subsequent join conditions.

    create xml view "cat" as
    {
      "Demo"."demo"."Categories" "C" as "category"
        ("CategoryID", "Description" as "description")
        {
          "Demo"."demo"."Products" "P" as "product"  ("ProductName")
        on ("P"."CategoryID" = "C"."CategoryID")
        }
    }

This declares a two level hierarchy with a category node for each
category and a product child node for each product in the category.

    create xml view "cats_e" as
      select "category"."CategoryID", "CategoryName",
        "ProductName", "ProductID"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID" element;

Here is a similar example, this time using the element option.

The procedures are

    xmlg_cat
    http_cat_category_C (in categoryid any, in _out integer);
    http_cat_product_P (in productid any, in _out integer);

In the following example the function returns the selected items as an
XML fragment. Consecutive elements are separated by new-lines for
readability.

    SQL> call "http_cat_category_C" (1, 1);
    
    1 sets? Done. -- 5 msec.
    RESULT=
    <category CategoryID="1" description="Soft drinks, coffees, teas, beers, and ales" >
    <product ProductName="Chai" ></product>
    <product ProductName="Chang" ></product>
    <product ProductName="Guarana Fantastica" ></product>
    <product ProductName="Sasquatch Ale" ></product>
    <product ProductName="Steeleye Stout" ></product>
    <product ProductName="Côte de Blaye" ></product>
    <product ProductName="Chartreuse verte" ></product>
    <product ProductName="Ipoh Coffee" ></product>
    <product ProductName="Laughing Lumberjack Lager" ></product>
    <product ProductName="Outback Lager" ></product>
    <product ProductName="Rhönbrooou Klosterbier" ></product>
    <product ProductName="Lakkalikööri" ></product>
    </category>

The below example shows how to use a SQL view for hiding a join. The
below view generates for each table a set of column children and a set
of index children, which in turn have column children.

    create view KEY_COLS as select KP_KEY_ID, KP_NTH, C.*
        from SYS_KEY_PARTS, SYS_COLS C where COL_ID = KP_COL;
    
    create xml view "schema" as
    {
      DB.DBA.SYS_KEYS k as "table" ("KEY_TABLE" as "name",
        KEY_ID as "key_id", KEY_TABLE as "table")
        on (k.KEY_IS_MAIN = 1 and k.KEY_MIGRATE_TO is null)
        { DB.DBA.KEY_COLS  c as "column" (COLUMN as name)
            on (k.KEY_ID = c.KP_KEY_ID)
            primary key (COL_ID),
        DB.DBA.SYS_KEYS i as "index" (KEY_NAME
          as "name", KEY_ID as "key_id", KEY_N_SIGNIFICANT as "n_parts")
          on (i.KEY_TABLE = k.KEY_TABLE and i.KEY_IS_MAIN = 0 and i.KEY_MIGRATE_TO is null)
          {
            DB.DBA.KEY_COLS ic as "column" (COLUMN as "name")
              on (ic.KP_NTH < i.KEY_N_SIGNIFICANT and ic.KP_KEY_ID = i.KEY_ID)
              primary key (COL_ID)
              }
        }
    };

The following query will return the subtree describing the Customers
table in the demo database:

    XPATH [__view 'schema']
        /table[@name = 'Demo.demo.Customers'];
    
    <table name="0" key_id="1011" table="Demo.demo.Customers" >
    <column name="CustomerID" ></column>
    <column name="CompanyName" ></column>
    <column name="ContactName" ></column>
    <column name="ContactTitle" ></column>
    <column name="Address" ></column>
    <column name="City" ></column>
    <column name="Region" ></column>
    <column name="PostalCode" ></column>
    <column name="Country" ></column>
    <column name="Phone" ></column>
    <column name="Fax" ></column>
    <index name="City" key_id="1012" n_parts="2" >
    <column name="City" ></column>
    <column name="CustomerID" ></column>
    </index>
    <index name="CompanyName2" key_id="1013" n_parts="2" >
    <column name="CompanyName" ></column>
    <column name="CustomerID" ></column>
    </index>
    <index name="PostalCode2" key_id="1014" n_parts="2" >
    <column name="PostalCode" ></column>
    <column name="CustomerID" ></column>
    </index>
    <index name="Region" key_id="1015" n_parts="2" >
    <column name="Region" ></column>
    <column name="CustomerID" ></column>
    </index>
    </table>

### Automatic XML Views - Creating XML Views from SELECT Statements

The automatic form of CREATE XML VIEW will take a select statement and
infer a hierarchy from it, based on the order of tables in the from
clause. The parent table should be to the left of its children. This is
practical if the tables form a hierarchy in application terms, like
orders and order lines or departments and employees. This notation
allows arbitrary depth but all siblings at the same level will be of the
same type. Elements of child rows will be child elements of the element
of their parent row, where the join condition identifies the child rows
for one parent row.

The columns in the selection will appear as attributes or child elements
of the rows selected. The names of the attributes will be the names of
the columns. The names of the siblings will be the names of the tables
in the from clause, without qualifiers or owners. Expressions should not
appear in the selection. If the use of expressions is required then you
may create a SQL view first to facilitate this.

The ELEMENT keyword may be present at the end of the select, before the
publishing keywords. This will cause all columns to be represented as
child elements of the element corresponding to the row. Note that even
if the element switch is present, the values will appear like attributes
in an XPATH query inside the view.

> **Note**
> 
> SQL views or derived tables may not appear directly in the select. The
> reason for this is that a procedure is generated for each level of the
> generated XML tree and that this must take unique identifying column
> values for the element in question. If one desires to use a view, the
> explicit form should be used, with the primary key option specified
> where appropriate.

#### Add to text for explicit XML views

Each set of sibling child nodes is delimited by braces {}. The top level
of the view typically consists of one element in the outermost braces.
This element has itself a child list delimited by braces. Each such list
can have more than one different element.

Each element specifies:

  - SQL table

  - Correlation name for use in subsequent joins for this table

  - XML element name to use for delimiting a row of this table

  - List of columns, with optional XML element or attribute names

  - join condition - will relate rows of this table to rows of the table
    in the enclosing element. If this element is at the top level, this
    can only consist of scalar conditions

  - Optional PRIMARY KEY clause, needed if the table in this element is
    a view, does not have a primary key or if a non-primary key unique
    identity is desired

  - Optional ELEMENT flag

  - Optional list of child elements, delimited by braces

<!-- end list -->

    create xml view "cats_e" as
      select "category"."CategoryID", "CategoryName",
        "ProductName", "ProductID"
        from "Demo".."Categories" "category", "Demo".."Products" as "product"
        where "product"."CategoryID" = "category"."CategoryID" element;
    
    Add to text: after 'free text and xml'

### xml\_view\_publish

    DB.DBA.xml_view_publish (in view_name varchar, in dav_path varchar,
        in dav_owner varchar, in is_persistent integer, in refresh_interval integer)

This presents an XML view as a DAV resource. The view name is the name
in the create xml view statement, note that this is case sensitive and
is never converted since it is a string, not an identifier. The path
must be absolute and is interpreted as relative from the DAV root
collection. The DAV user is the owner of the resource. If is\_persistent
is non-zero the resource will be materialized from the view's
description. The refresh interval is only applicable if the resource is
materialized. If so, this is an interval in minutes. A value of 0 means
no automatic refresh.

The reverse operation of xml\_view\_publish is deleting the DAV
resource. xml\_view\_publish may be called several times to alter the
owner or refresh interval.

## External Entity References in Stored XML

When an XML document is stored as either text, long xml, xmltype or in
the persistent XML format it can contain references to external parsed
entities with the \<\!entity ...\> declaration and the \&xx; syntax.
These are stored as references and not expanded at storage time if the
entity is external.

Such references are transparently followed by XPATH and XSLT. A run time
error occurs if the referenced resource cannot be accessed when needed.
The reference is only followed if the actual subtree is selected by
XPATH or XSLT. The resource is retrieved at most once for each XPATH or
XSLT operation referencing it, regardless of the number of times the
link is traversed. This is transparent, so that the document node of the
referenced entity appears as if it were in the place of the reference.

External entity references have an associated URI, which is either
absolute with protocol identifier and full path or relative. Relative
references must be resolved with respect to the base URI of the
referencing document. If the document is stored as a column value in a
table it does not have a natural base URI, hence the application must
supply one if relative references are to be supported. This is done by
specifying an extra column of the same table to contain a path, in the
form of collections delimited by slashes, just as the path of a DAV
resource or a Unix file system path.

This base URI is associated with an XML column with the IDENTIFIED BY
declaration:

    create table XML_TEXT (
        XT_ID integer,
        XT_FILE varchar,
        XT_TEXT long varchar identified by xt_file,
            primary key (XT_ID)
        );
    
    create index XT_FILE on XML_TEXT (XT_FILE);

Thus, each time the value of xt\_text is retrieved for XML processing by
XPATH\_CONTAINS or XCONTAINS the base URI is taken from xt\_file.

The complete URI for the xt\_text of a column of the sample table will
be:

    virt://<qualified table name>.<uri column>.<text column>:<uri column value>

An example would be:

    "virt://DB.DBA.XML_TEXT.XT_FILE.XT_TEXT:sqlreference.xml"

The .. and . in relative paths are treated as with file names when
combining relative references to base URI's. A relative reference
without a path just replaces the last part of the path in the base URI.

> **Tip**
> 
> [xml\_uri\_get and xml\_uri\_merge](#fn_xml_uri_get) for more details.

## Using XPATH in SQL Queries and Procedures

An XPATH expression can appear as a SQL query expression, that is, as a
derived table or subquery predicate or scalar subquery. This means that
the XPATH expression is expanded compile time to the corresponding SQL.
The mapping of the XPATH hierarchy to tables and joins is given by the
\_\_view XPATH option, which is mandatory.

The XPATH keyword introduces an embedded XPATH expression. The XPATH
text is presented as a string literal. Note that the tokenization rules
are different for XPATH and SQL, so having XPATH as a string makes it
clear which rules apply to parsing which part of the composite query.

    select * from (XPATH '[__* __view "cat"]
        //product') P order by "P."ProductName"";

will evaluate the //product query in the context of the cat XML view and
produce a result set consisting of all the attributes of the product
entity as defined in the view.

> **Note**
> 
> The \_\_key and \_\_\* XPATH options are central here in defining the
> result columns of the XPATH. The default result column of an XPATH
> expression is the serialization of the selected entity or scalar,
> which is most of the time impractical in a SQL context.

### Parameters in XPATH

The '$' sign introduces a parameter in XPATH. The identifier following
the dollar sign should reference a SQL column or variable defined in the
surrounding context. The name of the parameter can contain a dot for
referencing a column with a correlation name.

For instance, to make a VSP page that outputs the category tree which
contains a specific product, one may write:

    <HTML>
    <?vsp
          declare N varchar;
          N := {?'name'};
          for (XPATH '[__http __view ''cat'']
            /category[product/@ProductName = $N]' do ; ?>
    </HTML>

This will iterate over the categories containing a product with
ProductName equal to the URL parameter 'name'. Note the \_\_http option
that causes the text of the selected entities to go directly to the HTTP
client. Note the double '' escape for the XML view name inside the SQL
string literal forming the name.

Also note that the N parameter is in upper case to work in all case
modes. In some modes SQL identifiers will be converted automatically to
upper case but this conversion does not apply inside XPATH.

    select * from "Demo".."Categories" C
        where exists (XPATH '[__view "ord"]
        //products[@CategoryID = $C.CategoryID]');

This example selects the categories of products that have been mentioned
in the ord XML view.

> **Note**
> 
> The main difference of SQL and XPATH is that the '-' is not a breaking
> character in XPATH and that XPATH is case sensitive without any
> implicit identifier case conversion.

## XQUERY and XML view

Similarly to XPATH, XQUERY may also be used as a query language for XML
views. Virtuoso offers a special case of FLWR expression for this
purpose. It is possible to use the [`xmlview()`](#xpf_xmlview) function
in FOR clause expressions for querying XML views. This function is
similar to document () in the sense that it sets the source of the path
to be the logical root of the referenced XML view. The XML view must be
a constant known at compile time. A SQL query against the appropriate
tables of the XML view is internally constructed and evaluated at run
time, producing XML fragments from the selected rows. At no point will
non-selected parts of the evaluation of the XML view be physically
created. The path expression following from [`xmlview()`](#xpf_xmlview)
may contain filters involving XQuery variables bound in the scope of the
path expression, thus allowing joining SQL data to XQuery variable
values.

The XQUERY string

    for $cat in xmlview("cat")/category return {$cat}

in the query

    select xquery_eval(' {for $cat in xmlview("cat")/category return <q>{$cat}</q>}',
                         xtree_doc('<dummy_tag/>'));

is equivalent to the XPATH query string

    XPATH [__view "cat"]/category

described above.

The expression xmlview("viewname")/path is not a valid top level SQL
statement, but may be used by xquery\_eval() function. The path
statement is translated into SQL query in the context of the "viewname"
(i.e. the necessary table names are taken from "viewname" XML view), so
that only the desired relational data will be queried. Functionality of
this kind of SQL queries is similar to functionality of the SQL fetch
statement, i.e. such a query provides iteration over the result set of a
cursor. The query is executed once for each row in the query
expression's result set. Thus using the CREATE XML VIEW statement and a
XQUERY FOR clause expression with [`xmlview()`](#xpf_xmlview) function
allows you to query the database and to return the results in the form
of an XML document and to avoid redundant data access. This kind of
queries also allows computing joins between two or more documents and
restructuring data.

> **Note**
> 
> The \<dummy\_tag/\> tag is not used and it is necessary only as an
> arbitrary argument for xtree\_doc() functions.

    create xml view "product" as
    {
      "Demo"."demo"."Products" p as "product"
          ("ProductID", "ProductName" as "product_name","UnitPrice" as "price",
          "SupplierID","CategoryID")
        {
          "Demo"."demo"."Suppliers" s as "supplier" ("SupplierID","CompanyName")
        on (s."SupplierID" = p."SupplierID")
           ,
          "Demo"."demo"."Categories" c as "category" ("Description")
        on (c."CategoryID" = p."CategoryID")
    
        }
    }

This declares a two level hierarchy with a product node for each product
and a supplier child node and a category child node of the product.

The following query will return the XML document in which each category
node will contain all suppliers supplying products of the given
category.

    select xquery_eval('
      <document>
        {
          for $cat in xmlview("cat")/category
          return (
            <category description={$cat/@description}>
              {
                distinct (
                  for $prod in xmlview("product")/product
                  where $cat/@CategoryID=$prod/category/@CategoryID
                  return $prod/supplier )
              }
            </category> )
        }
      </document>
      ',
      xtree_doc('<dummy_tag/>')
      );

returns the XML document in which each category node contains all
suppliers supplying products of the given category.

Let a document named suppliers.xml contains supplier elements; each
supplier element in turn contains supplier\_id and supplier\_name
subelements. The following query

    select xquery_eval('
      <supplier_product>
        {
          for $supp in document("suppliers.xml")/supplier
          return (
            <supplier>{$supp/supplier_name }
              <product_name>
                {
                  for $prod in xmlview("product")/product
                  where string($supp/supplier_id)=$prod/supplier/@SupplierID
                  return string($prod/@product_name)
                }
              </product_name>
            </supplier>)
        }
      </supplier_product>',
      xtree_doc('<dummy_tag/>')
      );

returns the XML document that contains supplier elements; each supplier
element in turn contains supplier\_name and product\_name elements.

The previous query and the following one show that it is possible to use
variables in a XPATH expression following [`xmlview()`](#xpf_xmlview)
functions.

The query

    select xquery_eval('
      <document>
        {
          distinct(
            let $ex:= "Ex%"
            for $prod in xmlview("product")//supplier[@CompanyName like $ex]
            return <supp_id>{$prod/@SupplierID}</supp_id>)
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

is equivalent to

    select xquery_eval('
      <document>
        {
          distinct(
            for $prod in xmlview("product")//supplier [@CompanyName like "Ex%"]
            return <supp_id>{$prod/@SupplierID}</supp_id>)
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

and selects all suppliers having attribute "CompanyName" starting with
"Ex".

### Optimization in the queries with xmlview() function

At least two methods may be used to accelerate the execution of queries
with xmlview() function. The first method assumes that a path statement
following xmlview() function should contain maximum conditions to reduce
the result set. For example, the query

    select xquery_eval('<w>
      {
        for $prod in xmlview("product")/product[@ProductID="1"]
        return <q>{$prod}</q>
      }</w>',
      xtree_doc('<dummy_tag/>'));

will be executed faster than

    select xquery_eval('<w>
      {
        for $prod in xmlview("product")/product where $prod[@ProductID="1"]
        return <q>{$prod}</q>
      }</w>',
      xtree_doc('<dummy_tag/>'));

due to the SQL query produced from the path expression
'product\[@ProductID="1"\]' reduces the result set in comparison with
the SQL query produced from the path expression 'product' in the second
query.

If we execute a join of two (or more) XML views (or XML document and XML
view), i.e. the query consists of the nested loops, the second method
proposes to carry out a piece of query of the nested loop which is
independent of the outer loop outside the outer loop and uses LET clause
for it. For example, the query

    select xquery_eval('<document>
      {
        let $prod_set:=(for $prod in xmlview("product")/product return $prod)
        for $cat in xmlview("cat")/category
        return (<category description={$cat/@description}$gt;
          {distinct(for $prod in $prod_set
                    where $cat/@CategoryID=$prod/category/@CategoryID
                    return $prod/supplier)}</category>)}</document>',
       xtree_doc('<dummy_tag/>'));

is equivalent to the query in the example 1, but it is about 5 times
faster than original one. This method is especially useful for full
joins. In this case we do not have a full join and this query may be
optimized without the use of temporary result sets if the 'where' clause
is replaced with proper filter:

    select xquery_eval('<document>
      {
        for $cat in xmlview("cat")/category
        let $catID := $cat/@CategoryID
        return (<category description={$cat/@description}$gt;
          {distinct(
            for $supp in xmlview("product")/product[category/@CategoryID=$catID]/supplier
            return $supp)
          }</category>)
      }
      </document<',
      xtree_doc('<dummy_tag/>'));

This variant requires no memory for storing $prod\_set and it never
fetches redundant fields from "Demo"."demo"."Products" table but it
heavily needs index for "Demo"."demo"."Products" on "CategoryID" field.
If such index is built the last variant is about 10 times faster than
the query in example 1. Similarly, the query in example 2 may be
optimized as follows:

    select xquery_eval('
      <supplier_product>
       {
         for $supp in document("suppliers.xml")/supplier
         let $supp_id:=string($supp/@supplier_id)
         return (
          <supplier>{$supp/supplier_name}
            <product_name>
              {
                for $prod in xmlview("product")/product[supplier/@SupplierID=$supp_id]
                return string($prod/@product_name)
              }
            </product_name>
          </supplier>)
       }
      </supplier_product>',
      xtree_doc('<dummy_tag/>')
      );

and it speeds up the operation by more than 15 times.

### Restrictions in XPATH expressions following the xmlview() function

Virtuoso does not support certain kinds of XPATH expressions applied to
the xmlview() function.

1\. A path expression must not contain any functions, because it is
impossible to translate most of the functions to SQL queries.

2\. A path expression must not contain numeric XQUERY variables in the
arithmetic expressions. Let a document named products.xml contains
product elements; each product element has numeric attribute
ProductPrice. A run time error occurs if the following query would be
used

    select xquery_eval('
      <document>
       {
         for $prod_doc in document("products.xml")/products/product/@ProductPrice
           for $prod_view in xmlview("product")/product[@price>$prod_doc+1]
         return <q>{$prod_doc, $prod_view/@product_name}</q>
       }
       </document>',
       xtree_doc('<dummy_tag/>'));

because the type of $prod\_doc is considered as string. As it is
mentioned in the previous restriction the using a function in a path
expression (e.g.
xmlview("product")/product\[@price\>number($prod\_doc)+1\]) is not
allowed. The correct query is as follows:

    select xquery_eval('
      <document>
        {
          for $prod_doc in document("products.xml")/products/product/@ProductPrice
            let $prod_doc2:=number($prod_doc)
            for $prod_view in xmlview("product")/product[@price>$prod_doc2+1]
          return <q>{$prod_doc, $prod_view/@product_name}</q>
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

3\. A path expression must not contain XQUERY variables with the
following paths. The following query will not be executed

    select xquery_eval('
      <document>
        {
          for $cat in xmlview("cat")/category,
              $prod in xmlview("product")/product[@CategoryID=$cat/@CategoryID]
          return <q>{$prod/supplier}</q>
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

The correct query may be given as

    select xquery_eval('
      <document>
        {
          for $cat in xmlview("cat")/category
          let $cat_id:=$cat/@CategoryID
          for $prod in xmlview("product")/product[@CategoryID=$cat_id]
          return <q>{$prod/supplier}</q>
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

4\. Virtuoso does not support a selection of n-th element in a path
expression. The following query will not be executed

    select xquery_eval('
      <document>
        {
          for $cat in xmlview("cat")//product[1] return <q>{$cat}</q>
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

5\. Virtuoso does not support a dereference (=\>) in a path expression.

6\. It is not recommended to use the long varchar, long varbinary and
long nvarchar data types with the logical and boolean operations in a
filter of the path expression. For example, the execution of the
following query

    select xquery_eval('
      <document>
        {
          for $prod in
            xmlview("product")/product[@SupplierID<5]/category[@Description like "Sw%"]
          return <q>{$prod}</q>
        }
      </document>',
      xtree_doc('<dummy_tag/>'));

may return an error, because the field "Description" has LONG VARCHAR
type in the table "demo"."Categories".

## Mapping Schemas as XML Views

Virtuoso supports creating XML views by using annotated XSD schemas
referred to as mapping schemas. A file containing a mapping schema may
be loaded by calling the
[`xml_load_mapping_schema_decl()`](#fn_xml_load_mapping_schema_decl)
function. A name (without extension .xsd) of the file containing a
mapping schema is considered to be the name of the xml view, defined by
the given mapping schema.

A loaded mapping schema may be queried in the same way as one would
query XML views defined using the CREATE XML VIEW statement with XPATH:

    XPATH [__view "xml_view_name"]/xpath_query

The XML view "Catmp" from the file "Catmp.xsd" may be loaded using the
following statement:

``` 
   select  xml_load_mapping_schema_decl (
      'http://localhost.localdomain/xmlrepository/',
      'Catmp.xsd',
      'UTF-8',
      'x-any' ) ) );
```

where the contents of "Catmp.xsd" is

``` 
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:sql="urn:schemas-microsoft-com:mapping-schema">
<xsd:annotation>
  <xsd:appinfo>
    <sql:relationship name="CategoryProduct"
          parent="Demo.demo.Categories"
          parent-key="CategoryID"
          child="Demo.demo.Products"
          child-key="CategoryID" />
  </xsd:appinfo>
</xsd:annotation>

  <xsd:element name="category" sql:relation="Demo.demo.Categories" type="CategoryType" />
   <xsd:complexType name="CategoryType" >
     <xsd:sequence>
        <xsd:element name="product"
                     sql:relation="Demo.demo.Products"
                     sql:relationship="CategoryProduct" >
           <xsd:complexType>
              <xsd:attribute name="ProductName" type="xsd:string" />
           </xsd:complexType>
        </xsd:element>
     </xsd:sequence>
        <xsd:attribute name="CategoryID"  type="xsd:integer" />
        <xsd:attribute name="description"  sql:field="Description"  type="xsd:string" />
    </xsd:complexType>
</xsd:schema>
            
```

The XML view "Catmp" loaded from the file "Catmp.xsd" is similar to XML
view "cat" defined by CREATE XML VIEW in the section [Explicit Xml
Views](#explicitxmlviews) .

The query

``` 
XPATH [__view 'Catmp'] /category[@* = 1];
            
```

will now return the following result:

    <category CategoryID="1" description="Soft drinks, coffees, teas, beers, and ales" >
      <product ProductName="Chai" ></product>
      <product ProductName="Chang" ></product>
      <product ProductName="Guarana Fantastica" ></product>
      <product ProductName="Sasquatch Ale" ></product>
      <product ProductName="Steeleye Stout" ></product>
      <product ProductName="Cote de Blaye" ></product>
      <product ProductName="Chartreuse verte" ></product>
      <product ProductName="Ipoh Coffee" ></product>
      <product ProductName="Laughing Lumberjack Lager" ></product>
      <product ProductName="Outback Lager" ></product>
      <product ProductName="Rhonbrau Klosterbier" ></product>
      <product ProductName="Lakkalikoori" ></product>
    </category>

Mapping schemas provide more flexibility than XML views defined by the
`CREATE XML VIEW` statement. In the following mapping schema a constant
element, "CustomerOrders", an element that does not map to any database
table or column but may appear in the resulting XML as a container
element of other subelements, is specified by the `sql:is-constant`
annotation.

    <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:sql="urn:schemas-microsoft-com:mapping-schema">
    <xsd:annotation>
      <xsd:appinfo>
        <sql:relationship name="CustOrders"
            parent="Demo.demo.Customers"
            parent-key="CustomerID"
            child="Demo.demo.Orders"
            child-key="CustomerID" />
      </xsd:appinfo>
    </xsd:annotation>
    
      <xsd:element name="Customer" sql:relation="Demo.demo.Customers" >
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="CustomerOrders" sql:is-constant="1" >
              <xsd:complexType>
                <xsd:sequence>
                  <xsd:element name="Order" sql:relation="Demo.demo.Orders"
                               sql:relationship="CustOrders"
                               maxOccurs="unbounded" >
                    <xsd:complexType>
                       <xsd:attribute name="OrderID" type="xsd:integer" />
                       <xsd:attribute name="OrderDate" type="xsd:date" />
                       <xsd:attribute name="CustomerID" type="xsd:string" />
                    </xsd:complexType>
                  </xsd:element>
                </xsd:sequence>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
              <xsd:attribute name="CustomerID" type="xsd:string" />
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>

After loading the "Cust\_constant.xsd" file containing the given mapping
schema, the xpath query:

``` 
XPATH [__view 'Cust_constant'] /category[@* = 1];
            
```

will return the following result:

    <Customer CustomerID="ALFKI" >
      <CustomerOrders >
        <Order CustomerID="ALFKI" OrderDate="1995-09-25 00:00:00.000000" OrderID="10643" ></Order>
        <Order CustomerID="ALFKI" OrderDate="1995-11-03 00:00:00.000000" OrderID="10692" ></Order>
        <Order CustomerID="ALFKI" OrderDate="1995-11-13 00:00:00.000000" OrderID="10702" ></Order>
        <Order CustomerID="ALFKI" OrderDate="1996-02-15 00:00:00.000000" OrderID="10835" ></Order>
        <Order CustomerID="ALFKI" OrderDate="1996-04-15 00:00:00.000000" OrderID="10952" ></Order>
        <Order CustomerID="ALFKI" OrderDate="1996-05-09 00:00:00.000000" OrderID="11011" ></Order>
      </CustomerOrders>
    </Customer>
        . . .

Virtuoso does not support all mapping schema annotations at this time.
The following are currently unsupported:

sql:encode

sql:use-cdata

sql:overflow-field

sql:inverse

sql:hide

sql:guid

sql:max-depth

Also, there are some restrictions to the structure of mapping schemas:

Attributes can not contain sql:relationship annotation.

Subelement having no sql:is-constant annotation and not mapped to any
table can not contain subelements and attributes.

Recursive relationships is not supported.

> **Note**
> 
> The XML views, defined by mapping schemas may not be queried using
> XQUERY. They can however be referenced with the xmlview XPATH
> functions in path expressions inside an XQuery query.

> **Tip**
> 
> SQLXML 3.0 documentation: [Creating XML Views by Using Annotated XSD
> Schemas.](#)

## Differences Between SQLX, FOR XML and XML Views

A SQLX or FOR XML query has no effect on the database schema. It is a
transient event and does not generate procedures or other schema
elements.

These define an ad hoc mapping of a result set to XML. There is no
possibility of using XPATH to specify a search without first
constructing the whole tree. An XML view on the other hand provides a
mapping context in which one can make XQUERY or XPATH queries that are
mapped into SQL and the XML is only generated after applying the
conditions.

XML views will usually be more efficient in complex cases and the
notation there may be simpler than the EXPLICIT notation in FOR XML. For
simple cases SQLX or FOR XML is the more convenient of the two. SQLX or
FOR XML does not restrict the SQL being used and will allow free use of
subqueries, expressions, derived tables, qualified joins etc.

# Querying Stored XML Data

## XPATH\_CONTAINS SQL Predicate

XPath expressions can be used in SQL statements to decompose and match
XML data stored in columns. The `xpath_contains` SQL predicate can be
used either to test for an XML value matching a path expression or to
extract one or more entities from the XML value. These values can then
be used later in the query as contexts for other XPath expressions.

    xpath_contains (xml_column, xp_expression[, query_variable]);

The first argument, `xml_column` is the name of the column on which to
perform the XPath search. The second argument, `xp_expression` , takes
an XPath expression.

The third argument is an optional query variable that gets bound to each
result entity value of the xpath expression. If this variable is omitted
the xpath\_contains predicate will qualify the query by returning true
for matches. In this case the result will only return one row per match.
If the variable is present, the result set could contain multiple rows
per result set row of the base table, one row for each match.

Consider the example:

    select xt_file, t from xml_text
      where xpath_contains (xt_text, '//chapter/title[position () = 1]', t);

This SQL statement will select the first title child of any chapter
entities in the XML documents in the xt\_text column of the table
`xml_text` . There can be several matching entities per row of
xml\_text. The result set will contain a row for each matching entity.

In XPath terms the path expression of `xpath_contains` is evaluated with
the context node set to the root node of the XML tree represented by the
value of the column that is the first argument of xpath\_contains. This
node is the only element of the context node set.

> **Note**
> 
> The 't' variable in the above example gets bound to XML entities, not
> to their string values or other representations. One can thus use
> these values as context nodes for other expressions.

The XPATH expression can have a list of options in the beginning. The
list of options is surrounded by square brackets. Options in the list
are delimited by spaces. The most popular option is `__quiet` that
allows to process a set of rows if not all stored documents are valid
XMLs; if an error is signalled by the XML parser when it prepares a
content document for the XPATH in question and the XPATH contains
`__quiet` then the error is suppressed and the row is silently ignored
as if XPATH found nothing. One can configure the DTD validator of the
parser by placing its [configuration parameters](#dtd_config) in the
list of XPATH options.

The following example is almost identical to the previous one but it
works even if not all values of `xt_text` are valid XMLs, and the
resulting values of the 't' variable are standalone entities even if
source documents in xt\_text contain external generic entities.

    select xt_file, t from xml_text
      where xpath_contains (xt_text, '[__quiet BuildStandalone=ENABLE]//chapter/title[position () = 1]', t);

## Using xpath\_eval()

The `xpath_eval()` function is used to filter out parts of an XML
fragment that match a given XPATH expression. It can be used to retrieve
multiple-node answers to queries, as it is often the case that more than
one node-set matches. Consider the following statements that create a
table with XML stored inside.

    CREATE TABLE t_articles (
        article_id int NOT NULL,
        article_title varchar(255) NOT NULL,
        article_xml long varchar
        );
    
    insert into t_articles (article_id, article_title) values (1, 'a');
    insert into t_articles (article_id, article_title) values (2, 'b');
    
    UPDATE t_articles SET article_xml = '
    <beatles id = "b1">
    <beatle instrument = "guitar" alive = "no">john lennon</beatle>
    <beatle instrument = "guitar" alive = "no">george harrison</beatle>
    </beatles>'
    WHERE article_id = 1;
    
    UPDATE t_articles SET article_xml = '
    <beatles id = "b2">
    <beatle instrument = "bass" alive = "yes">paul mccartney</beatle>
    <beatle instrument = "drums" alive = "yes">ringo starr</beatle>
    </beatles>'
    WHERE article_id = 2;

Now we make a query that will return a vector of results, each vector
element corresponding to a node-set of the result.

    SELECT xpath_eval('//beatle/@instrument', xml_tree_doc (article_xml), 0)
        AS beatle_instrument FROM t_articles WHERE article_id = 2;

The repeating nodes are returned as part of a vector, the third argument
to `xpath_eval()` is set to 0, which means that it is to return all
nodes.

Otherwise, we can select the first node-set by supplying 1 as the third
parameter to `xpath_eval()` :

    SELECT xpath_eval('//beatle/@instrument', xml_tree_doc (article_xml), 1)
        AS beatle_instrument FROM t_articles WHERE article_id = 2;

> **Tip**
> 
> [`xpath_eval()`](#fn_xpath_eval)
> 
> [`xquery_eval()`](#fn_xquery_eval)
> 
> [`xmlupdate()`](#fn_xmlupdate)

## External Entity References in Stored XML

When an XML document is stored as either text or in persistent XML
format it can contain references to external parsed entities with the
\<\!entity ...\> declaration and the \&xx; syntax. These are stored as
references and not expanded at storage time if the entity is external.
Such references are transparently followed by XPath and XSLT. A run-time
error occurs if the referenced resource cannot be accessed when needed.
The reference is only followed if the actual subtree is selected by
XPath or XSLT. The resource is retrieved at most once for each XPath or
XSLT operation referencing it, regardless of the number of times the
link is traversed. This is transparent, so that the document node of the
referenced entity appears as if it were in the place of the reference.

External entity references have an associated URI, which is either
absolute, with protocol identifier and full path, or relative. Virtuoso
resolves relative references with respect to the base URI of the
referencing document. If the document is stored as a column value in a
table it does not have a natural base URI; therefore, the application
must supply one if relative references are to be supported. This is done
by specifying an extra column of the same table to contain a path, in
the form of collections delimited by slashes, like the path of a DAV
resource or a Unix file system path. This base URI is associated with an
XML column with the IDENTIFIED BY declaration:

    create table XML_TEXT (
        XT_ID integer,
        XT_FILE varchar,
        XT_TEXT long varchar identified by xt_file,
            primary key (XT_ID)
        );
    
    create index XT_FILE on XML_TEXT (XT_FILE);

Thus, each time the value of `xt_text` is retrieved for XML processing
by `xpath_contains()` or `xcontains()` the base URI is taken from
`xt_file` . The complete URI for the `xt_text` of a column of the sample
table would be:

    virt://<qualified table name>.<uri column>.<text column>:<uri column value>

An example would be:

    "virt://DB.DBA.XML_TEXT.XT_FILE.XT_TEXT:sqlreference.xml"

The '..' and '.' in relative paths are treated like file names when
combining relative references to base URIs. A relative reference without
a path just replaces the last part of the path in the base URI.

> **Tip**
> 
> [`xml_uri_get()` and `xml_uri_merge()`](#fn_xml_uri_get) for more
> details.

## XML Schema & DTD Functions

The following functions can be used to generate XML Schema or DTD
information about a given SQL query:

xml\_auto\_schema()

xml\_auto\_dtd()

This example shows trivial use of the two functions `xml_auto_schema()`
and `xml_auto_dtd()` .

    SQL> select xml_auto_schema('select u_name from sys_users', 'root');
    callret
    VARCHAR
    _______________________________________________________________________________
    
    <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    
     <xsd:annotation>
      <xsd:documentation>
       Schema for output of the following SQL statement:
    
       <![CDATA[select u_name from sys_users]]>
    
      </xsd:documentation>
     </xsd:annotation>
    
     <xsd:element name="root" type="root__Type"/>
    
     <xsd:complexType name="root__Type">
      <xsd:sequence>
       <xsd:element name="SYS_USERS" type="SYS_USERS_Type" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
     </xsd:complexType>
    
     <xsd:complexType name="SYS_USERS_Type">
      <xsd:attribute name="U_NAME" type="xsd:string"/>
     </xsd:complexType>
    
    </xsd:schema>
    
    1 Rows. -- 1843 msec.
    SQL> select xml_auto_dtd('select u_name from sys_users', 'root');
    callret
    VARCHAR
    _______________________________________________________________________________
    
    <!-- dtd for output of the following SQL statement:
    select u_name from sys_users
    -->
    
    <!ELEMENT root (#PCDATA | SYS_USERS)* >
    <!ELEMENT SYS_USERS (#PCDATA)* >
    <!ATTLIST SYS_USERS
            U_NAME  CDATA   #IMPLIED        >
    
    1 Rows. -- 411 msec.

## Using XML and Free Text

Virtuoso integrates classic free text retrieval and XML semi-structured
query features to offer a smart, scalable XML repository. When a column
is declared as indexed XML with the CREATE TEXT XML INDEX statement the
text is checked for well-formedness at time of storage. The specific XML
structure of the text is also considered when making the free text index
entries. This XML-aware free text index is used for processing XPath
queries in the `xcontains` SQL predicate. This predicate is only
applicable to columns for which there is an XML free text index.

Arbitrary free text criteria can appear inside the XPath expression of
`xcontains` . These are introduced by the XPath extension function
`text-contains()` , which may only be used within `xcontains` as it
relies on the underlying free text index.

> **Note**
> 
> `xpath_contains()` does not require the existence of a free text index
> and can thus apply to any well-formed XML content.

## XCONTAINS predicate

This predicate is used in a SQL statement, it returns "true" if a free
text indexed column with XML content matches an XPATH expression.
Optionally produces the matching node set as a result set.

Syntax

    xcontains_pred:
        xcontains (column, expr [, result_var [, opt_or_value ...]])
    
    opt_or_value:
          DESCENDING
          | START_ID ',' scalar_exp
          | END_ID ',' scalar_exp
          | SCORE_LIMIT ',' scalar_exp
          | OFFBAND column
    
    result_var:
          IDENTIFIER
          | NULL

The *column* must refer to a column for which there exists a free text
index.

The *expr* must be a narrow or wide string expression whose syntax
matches the rules in 'XPATH Query Syntax'.

The *result\_var* variable is a query variable which, if present, will
be successively bound to each element of the node set selected by the
XPATH expression. if the value is not a node set and is true, the
variable will be once bound to this value. The scope of the variable is
the containing select and its value is a scalar or an XML entity. The
*result\_var* can be not an identifier but a NULL keyword to explicitly
indicate that no query variable is required.

The *START\_ID* is the first allowed document ID to be selected by the
expression in its traversal order, e.g. least or equal for ascending and
greatest or equal for descending.

*END\_ID* is the last allowed id in the traversal order. For descending
order the START\_ID must be \>= END\_ID for hits to be able to exist.
For ascending order the START\_ID must be \<= END\_ID for hits to be
able to exist.

*DESCENDING* specifies that the search will produce the hit with the
greatest ID first, as defined by integer or composite collation. This
has nothing to do with a possible ORDER BY of the enclosing statement.
Even if there is an ORDER BY in the enclosing statement the DESCENDING
keyword of xcontains has an effect in the interpretation of the STRT\_ID
and END\_ID xcontains options.

*RANGES* specifies that the query variable following the RANGES keyword
will be bound to the word position ranges of the hits of the expression
inside the document. The variable is in scope inside the enclosing
SELECT statement.

*SCORE\_LIMIT* specifies a minimum score that hits must have or exceed
to be considered matches of the predicate.

*OFFBAND* specifies that the following column will be retrieved from the
free text index instead of the actual table. For this to be possible the
column must have been declared as offband with the CLUSTERED WITH option
of the [CREATE TEXT INDEX](#createtxtidxstmt) statement.

If the select statement containing the xcontains predicate does not
specify an exact match of the primary key of the table having the
xcontains predicate, then the contains predicate will be the 'driving'
condition, meaning that rows come in ascending or descending order of
the free text document ID. If there is a full equality match of the
primary key of the table, this will be the driving predicate and
xcontains will only be used to check if the text expression matches the
single row identified by the full match of the primary key.

The xcontains predicate may not appear outside of a select statement and
may only reference a column for which a free text index has been
declared. The first argument must be a column for which there is such an
index. The text expression may be variable and computed, although it
must be constant during the evaluation of the select statement
containing it.

The xcontains predicate must be a part of the top level AND of the WHERE
clause of the containing select. It may not for example be a term of an
OR predicate in the select but can be AND'ed with an OR expression.

    select xt_file from xml_text2 where
     xcontains (xt_text, '//title = "Key"');

The query retrieves the `xt_file` for rows whose `xt_text` is an XML
document containing 'Key' as the text value of a title element.

If not all values in `xt_text` are valid XMLs then '\_\_quiet' option
can be useful to disable error signalling. It is unusual to get an
incorrect XML stored in a column that has free text XML index because
both on insert and on update the text is parsed by an free text indexing
routine, but the error is possible if e.g. a non-standalone document is
stored and an important external entity was available at indexing time
but disappeared later. Thus a modified example might be better for a
column with non-standalone documents;

    select xt_file from xml_text2 where
     xcontains (xt_text, '[__quiet] //title = "Key"');

**Selecting Title Element that Contains a Specified Text**

    select n from xml_text2 where
     xcontains(xt_text,
     '//title[. = "AS Declaration - Column Aliasing"]',0,n);

The query retrieves each title element from each row of `xml_text2`
where the `xt_text` contains title elements with the text value "AS
Declaration - Column Aliasing."

> **Note**
> 
> The equality test is case- and whitespace-sensitive, as normal in
> XPath. The free text index is used for the search but the final test
> is done according to XPath rules.

> **Tip**
> 
> The [CONTAINS](#containspredicate) Predicate.

## text-contains XPath Predicate

    text-contains (node-set, text-expression)

This XPath predicate is true if any of the nodes in `node-set` have text
values matching the `text-expression` . The `text-expression` should be
a constant string whose syntax corresponds to the top production of the
free text syntax for patterns in `contains()` . The string also may not
consist exclusively of spaces or noise words.

> **Tip**
> 
> "Noise Words" in the [Free Text Search chapter](#freetext) .

    select n from xml_text2 where
      xcontains (xt_text,
      '//title[text-contains (., "Aliasing")]', 0, n);

This selects all title elements that contain the word "Aliasing" using
free text match rules: case insensitive and whole word.

    select n from xml_text2 where
      xcontains (xt_text,
      '//*[text-contains (., ''"sql reference"'')]',
      0, n);

This selects all elements whose text value contains the phrase "sql
reference". Free text matching rules apply. This produces all nodes in
document order for all documents which contains the phrase, starting
with the document node and following downward including all paths to the
innermost element(s) whose text contains the phrase.

## XML Free Text Indexing Rules

XML documents are inserted into the free text index as follows:

The process works on the parsed XML tree; therefore character and local
entity references are expanded.

Whole words of text content, bounded by delimiters used for free text,
are each assigned an ordinal number. Noise words defined in the
noise.txt file used by free text indexing are not counted.

Attribute names and values are not indexed.

Element start and end tags are indexed using the expanded names - that
is, prefixed with the namespace URI + ':'.

An element start tag's ordinal number is one less than the ordinal
number of the first whole word in the text value.

A close tag's ordinal number is one greater than that of the last word
in the text value.

From these rules follows that:

    <html>
      <body>
       <title>Title of Document</title>
       <p>Some <b>bold</b> text </p>
      </body>
    </html>

will be indexed as follows:

    <html>        0
    <body>        0
    <title>       0
    Title       1
    of      - no number, noise word
    Document        2
    </title>      3
       <p>        3
    Some        4
     <b>      4
    bold        5
    </b>      6
     text       6
    </p>      6
      </body>     6
    </html>       6

As a result, the phrase "some bold text" is the string value of the
\<p\> tag and will match the free text expression "some bold text" even
though there is mark-up in it. Conversely, the phrase "Document some
bold" does not match. Words will not considered adjacent if there is a
mix of opening and closing tags. They will only be considered adjacent
if there are solely one or more either opening or closing tags between
them. This can be circumvented by using the `NEAR` connective instead of
the phrase construct.

A free text condition will only be true of an element if all the words
needed to satisfy the condition are part of the element's string value.
This string value includes text children of descendants.

## XML Processing & Free Text Encoding Issues

XML document may be written in a variety of encodings, and it may cause
errors if an incorrect encoding is used for reading a document. Most
common errors can easily be eliminated by writing proper XML prologs in
documents, but this is not always possible, e.g. if documents are
composed by third-party applications. Virtuoso provides various tools to
support different types of encodings and to specify encodings to use if
a given document has no XML prolog.

### Encodings: The Difference Between Encodings & Character Sets

Not all documents may be converted to Unicode by using simple character
sets. Some of them are stored in so-called "multibyte" encodings. It
means that every letter (or ideograph) is represented as a sequence of
one or more bytes, not by exactly one byte. The conversion from such
representation to Unicode and back is usually significantly slower than
simple transformation via character sets, so these representations are
supported by data import operations only, but not by internal RDBMS
routines.

The Virtuoso Server "knows" some number of built-in encodings, such as
UTF-8, UTF-16BE and UTF-16LE. It can load additional encoding
descriptions from a "UCM" file, and can automatically create a new
encoding from a known charset with the same name. See the [UCM
Encodings](#ucmencodings) section for more details.

An encoding may be used in the following places:

The XML/HTML parser to convert source text to Unicode.

The free-text indexing engine to convert plain-text or XML documents to
Unicode during the indexing.

It may be used by the compiler of free-text search expressions to
convert string constants of the expression to Unicode.

It may be used to convert string constants of XPath/XQuery expressions.

You can only use character sets, not encodings as an ODBC connection
character set, as a character set attribute of a column of a database
table, as an output encoding of the built-in XSLT processor (it is for
future versions). UTF-8 is an exception, it is supported in many places
where other encodings are not.

> **Tip**
> 
> Two strings converted to Unicode may be identical, but this does not
> guarantee that their source strings were equal byte-by-byte due to the
> nature of some encodings. For this reason you should avoid processing
> authorization data that are neither in Unicode nor in one of the
> standard character sets (single-byte encodings). Multibyte encodings
> and user-defined character sets may be unsafe for such purposes.

#### UCM Encodings

The description of a multibyte encodings is much longer than the
description of a character set. It is inconvenient to keep such amounts
of data inside the executable. Virtuoso can load descriptions of
required encodings from external files in UCM format. Every UCM file
describes one encoding.

Virtuoso loads UCM files at system initialization. The list of UCM files
is kept in the [Virtuoso INI file](#virtini) under a section called
\[Ucms\]. This section should contain a UcmPath parameter and one or
more parameters with names Ucm1, Ucm2, Ucm3 and so on (up to Ucm99).

The UcmPath parameter specifies the directory where UCM files are
located, and every UcmNN parameter specifies the name of a UCM file to
load and a list of names that the encoding can be identified by the
\<?xml ... encoding="..." ?\> XML preamble. A vertical bar character is
used to delimit names in the list.

    [Ucms]
    UcmPath = /usr/local/javalib/ucm
    Ucm1 = java-Cp933-1.3-P.ucm,Cp933
    Ucm2 = java-Cp949-1.3-P.ucm,Cp949|Korean

This section describes two UCM files located in /usr/local/javalib/ucm
directory: data from java-Cp933-1.3-P.ucm will be used for documents in
the 'Cp933' encoding; data from java-Cp949-1.3-P.ucm will be used for
documents in the 'Cp949' encoding and for documents in the 'Korean'
encoding (because these two names refers to the same encoding).

> **Note**
> 
> The encoding name specified inside the UCM file itself is not used.

The Virtuoso server will log the results of processing each UCM file
specified in the Virtuoso INI file. If a UCM file specified is not found
or contains syntax errors, the error is logged, otherwise only the type
and name(s) of the encoding are logged.

> **Note**
> 
> If the virtuoso.ini contains a misspelled name of a parameter or
> section, the parameter (or a whole section) is ignored without being
> reported as an error. It is always wise to verify that the log
> contains a record about the encoding(s) you load.

> **Tip**
> 
> UCM files can be found freely from various sites concerning the
> "International Components for Unicode" project, such as: [IBM ICU
> Homepage](#) or the [IBM UCM files directory](#) .
> 
> The [C Interface](#cinterface) chapter contains further information
> regarding user customizable support for new encodings and languages.
> For almost all tasks, it is enough to define a new charset or to load
> an additional UCM file, but some special tasks may require writing
> additional C code.

### The `Encoding` Attribute

If an XML document contains the `encoding` parameter in its

    <?xml ... ?>

prolog declaration, it will be properly decoded and converted into
UTF-8, so the application code is free from encoding problems. If the
value of this attribute is the name of a pre-set or user-defined
character set, that character set will be used. Virtuoso will recognize
names such as `UTF-8` and `UTF8` as multi-character or special
encodings. Virtuoso recognizes both official names and aliases.

If an encoding is not specified in an XML prolog, or if the document
contains no prolog, the default encoding will be used to read the
document. If a built-in SQL function invokes the XML parser, it will
have an optional argument `parser_mode` to specify whether source text
should be parsed as strict XML or as HTML. If the source text is 8-bit,
then UTF-8 will be used as the default encoding for "XML mode", and
ISO-8859-1 (Latin-1) will be the default for "HTML mode". If the source
text is of some wide-character type, Unicode is the default. To make
another encoding the default, you may specify its official or alias name
as the `content_encoding` argument of a built-in function you call.

### Encoding in XPath Expressions

Sometimes applications should perform XPath queries using the encoding
specified by a client. For example, a search engine may ask a user to
specify a pattern to search and use the browser's current encoding as a
hint to parse the pattern properly. In such cases you may wish to use
the `__enc` XPath option to specify the encoding used for the rest of
XPath string:

Create a sample table and store an XML with non-Latin-1 characters

``` 
create table ENC_XML_SAMPLE (
  ID integer,
  XPER long varchar,
  primary key (ID)
);

insert into ENC_XML_SAMPLE (ID, XPER)


values (
  1,
  xml_persistent ('<?xml version="1.0" encoding="WINDOWS-1251" ?>
    <book><cit>Îí äîáàâèë
      êàðòîøêè,
    ïîñîëèë è
    ïîñòàâèë
    àêâàðèóì íà
    îãîíü
    (Ì.Æâàíåöêèé
    )</cit></book>'
  )
);
...
  
```

Find the IDs of all XML documents whose texts contain a specified
phrase. Note that there are pairs of single quotes (not double quotes)
around `KOI8-R` . The encoding name should be in single quotes, but
because it is inside a string constant the quotes must be duplicated.

``` 
select ID from ENC_XML_SAMPLE where
  xcontains (XPER, '[__enc ''KOI8-R''] //cit[text-contains(.,
  "''ÐÏÓÔÁ×ÉÌ
    ÁË×ÁÒÉÕÍ
    ÎÁ ÏÇÏÎØ''")]');



```

### Encoding in Free Text Search Indexes & Patterns

Like XML applications, free text searching may have encoding problems,
and Virtuoso offers a similar solution for them.

Both the CREATE TEXT INDEX statement and vt\_create\_text\_index()
Virtuoso/PL procedure have an optional argument to specify the encoding
of the indexed data. The specified encoding will be applied to all
source text documents (if the TEXT INDEX was created), or to all XML
documents that have no encoding attribute of the sort \<?xml ...
encoding="..." ?\> (if the TEXT XML INDEX was created).

The option `__enc` may be specified at the beginning of free text search
pattern, even if the pattern is inside an XPath statement:

Create a sample table and store a sample of text with non-Latin-1
characters (assuming that client encoding is Windows-1251)

    create table ENC_TEXT_SAMPLE (
      ID integer,
      TEXT long nvarchar,
      primary key (ID)
    );
    
    insert into ENC_TEXT_SAMPLE (ID, XPER)
    
    
    values (
      1,
      '<?xml version="1.0" encoding="WINDOWS-1251" ?>
    Îí äîáàâèë
        êàðòîøêè,
        ïîñîëèë è
        ïîñòàâèë
        àêâàðèóì
        íà îãîíü
        (Ì.Æâàíåöêèé')
    );
    ...

Find the IDs of all text documents whose texts contain a specified
phrase.

    select ID from ENC_SAMPLE where
      contains (TEXT, '[__enc ''KOI8-R'']
        "ÐÏÓÔÁ×ÉÌ
        ÁË×ÁÒÉÕÍ
        ÎÁ ÏÇÏÎØ"'
      );

Encoding may be applied locally to an argument of the text-search
predicate. It may be used if the document contains citations in
different encodings or if the XML document contains non-ASCII characters
in names of tags or attributes, or if the encoding affects character
codes of ASCII symbols such as '/' or '\['.

    select ID from ENC_XML_SAMPLE where
      xcontains (XPER, '//cit[text-contains(., "[__enc ''KOI8-R'']
        ''ÐÏÓÔÁ×ÉÌ
        ÁË×ÁÒÉÕÍ ÎÁ
        ÏÇÏÎØ''")]'
      );

> **Note**
> 
> You may have free-text a expression written as a literal constant:
> e.g. if the argument of text-contains XPath function is a literal
> constant. Be careful to not declare the \_\_enc twice, once in the
> beginning of the whole XPath expression and then again in the
> beginning of the free-text expression constant, because words of the
> text expression will thus be converted twice.

# Using UpdateGrams to Modify Data

Updategrams allow database updates to be defined as XML. This is
ultimately achieved by mapping the XML nodes against corresponding
database columns. Updategrams can be used to replace existing data
access components in a middle tier. A typical application will include a
middle tier consisting of business logic and data access code. The data
access code will interact with the database using disconnected
recordsets and command objects calling stored procedures. Most of the
data access section of the middle tier can be replaced with updategrams.

Most data access tiers (both middle tier code and stored procedures)
will deal individually with specific database tables or groups of
related tables. This can inhibit performance and often several round
trips to the database are required to complete a transaction.
Updategrams solve this problem by including all the data in an XML
document that is then mapped to database tables and columns. The entire
database update can then be accomplished at once. This update can
include inserting, updating and deleting data.

The `xmlsql_update()` function supports XML-based insert, update, and
delete operations performed on an existing table in the database.
[`xmlsql_update()`](#fn_xmlsql_update)

## Updategrams Basics

The general format of an updategram is:

    <sql:sync xmlns:sql="xml-sql">
     <sql:before>
        <TABLENAME [sql:id="value"] col="value" col="value"?../>
     </sql:before>
     <sql:after>
        <TABLENAME [sql:id="value"] [sql:at-identity="value"]
          col="value" col="value"?../>
     </sql:after>
    </sql:sync>

or

    <sql:sync xmlns:sql="xml-sql">
            <sql:before>
                    <TABLENAME [sql:id="value"]>
               <col>"value"</col>
               <col>"value"</col>
               ...
            </TABLENAME>
            ...
            </sql:before>
            <sql:after>
                    <TABLENAME [sql:id="value"] [sql:at-identity="value"]>
               <col>"value"</col>
               <col>"value"</col>
               ...
            </TABLENAME>
            ...
            </sql:after>
    </sql:sync>

## Elements Description

The `<sync>` tag of the updategram signifies the beginning of an
operation(s) The rows specified in the `<before>` refer to existing
records in the database. The rows specified in the `<after>` block refer
to what the user wants in the database. `<TABLENAME.../>` identifies
target table.

The `sql:at-identity` attribute stores the last identity value added by
the system (if possible). This identity value can then be used in
subsequent operations.

The `sql:id` attribute is used to mark rows. This forces an association
between the record specified in the `<before>` and `<after>` block in
the update gram. When there are multiple instances specified, it is
recommended that `sql:id` attribute be used for all the instances.

Each `<TABLENAME.../>` refers to a single table. Multiple
`<TABLENAME.../>` entries are allowed in the same `<before>` or
`<after>` tags, or in both `<before>` and `<after>` tags; however,
nesting is not allowed. The `<before>` and `<after>` tags are optional.
A missing tag is the same as having a tag with no content.

## Determining Actions

If only the `<after>` block is specified, the rows specified in the
`<after>` block are inserted in the table(s). If both the `<before>` and
`<after>` blocks are specified, then rows specified in the `<after>`
block for which there are no corresponding rows in the `<before>` block
are inserted in the table(s).

In an update operation, the rows specified in the `<before>` block refer
to existing rows in the database. The corresponding rows in the
`<after>` block reflect what the user wants in the database. A row
update operation is performed if there is a row in both the `<before>`
and `<after>` sections with the same set of values for the attributes
that uniquely identify a row in a table. Rows specified in the
`<before>` block must be valid in the database for the updategram to
successfully update the rows.

In a delete operation, if only the `<before>` block is specified in the
update gram, the rows specified in the `<before>` block are deleted from
the table(s). If both the `<before>` and `<after>` blocks are specified,
the rows for which there are no corresponding rows in the `<after>`
block are deleted from the table(s).

## Using Input Parameters

Parameters declarations should be described in the \<header\> section of
the updategram. There should be one `<param>` row for each parameter.

General syntax:

    <sql:header xmlns:sql="xml-sql">
      <sql:param name="PARAM_NAME" [default="DEFAULT_VALUE"]/>
      ...
    </sql:header>

Where `PARAM_NAME` is the name of the parameter and `DEFAULT_VALUE` is
optional default of parameter Parameters in updategram should have
`$PARAM_NAME` instead of a value. On processing, Virtuoso replaces
`$PARAM_NAME` with the corresponding value from the `<input_parameters>`
given to the function `xmlsql_update()` .

## Examples

Given the following tables:

    CREATE TABLE Orders (
        OrderID int identity,
        CustomerID varchar(10),
        EmpID int,
        PRIMARY KEY (OrderID));
    
    CREATE TABLE OrderDetails (
        OrderID int,
        ProductID int,
        Quantity int);

A. Update Gram to Insert a Record

    xmlsql_update (xml_tree_doc (xml_tree (
    '<ROOT xmlns:sql="urn:schemas-microsoft-com:xml-sql">
    <sql:sync>
      <sql:after>
        <Orders CustomerID="TEST" EmpID="99"/>
      </sql:after>
    </sql:sync>
    </ROOT>')));

B. Updategram with an `at-identity` Attribute

    xmlsql_update (xml_tree_doc (xml_tree (
    '<ROOT xmlns:sql="urn:schemas-microsoft-com:xml-sql">
    <sql:sync>
      <sql:after>
        <Orders sql:at-identity="x" CustomerID="VINET" EmpID="10"/>
          <OrderDetails OrderID="x" ProductID="1" Quantity="50"/>
          <OrderDetails OrderID="x" ProductID="2" Quantity="20"/>
        <Orders sql:at-identity="x" CustomerID="HANAR" EmpID="11"/>
          <OrderDetails OrderID="x" ProductID="1" Quantity="30"/>
          <OrderDetails OrderID="x" ProductID="4" Quantity="25"/>
      </sql:after>
    </sql:sync>
    </ROOT>')));

C. Updategram to Delete a Record

    xmlsql_update (xml_tree_doc (xml_tree (
    '<ROOT xmlns:sql="urn:schemas-microsoft-com:xml-sql">
    <sql:sync>
      <sql:before>
        <Orders CustomerID="HANAR" EmpID="11"/>
      </sql:before>
    </sql:sync>
    </ROOT>')));

D. Updategram to Update a Record

    xmlsql_update (xml_tree_doc (xml_tree (
    '<ROOT xmlns:sql="urn:schemas-microsoft-com:xml-sql">
    <sql:sync>
      <sql:before>
        <Orders sql:id="1" CustomerID="VINET" EmpID="10"/>
      </sql:before>
      <sql:after>
        <Orders sql:id="1" CustomerID="VINET_NEW" EmpID="11"/>
      </sql:after>
    </sql:sync>
    </ROOT>')));

E: Using a different syntax for updategrams - entities in place of
attributes - example D can be transformed to:

    xmlsql_update (xml_tree_doc (xml_tree (
    '<ROOT xmlns:sql="urn:schemas-microsoft-com:xml-sql">
    <sql:sync>
      <sql:before>
        <Orders sql:id="1">
          <CustomerID>VINET</CustomerID>
          <EmpID>10</EmpID>
        </Orders>
      </sql:before>
      <sql:after>
        <Orders sql:id="1">
          <CustomerID>VINET_NEW</CustomerID>
          <EmpID>11</EmpID>
        </Orders>
      </sql:after>
    </sql:sync>
    </ROOT>')));

Note that two syntaxes cannot be mixed in one document.

F: Using input parameters

Assume the following table:

    CREATE TABLE Shippers(
      ShipperID INTEGER,
      CompanyName VARCHAR(40),
      Phone VARCHAR(24),
      PRIMARY KEY (ShipperID));
    
    xmlsql_update (xml_tree_doc (xml_tree (
    '<DocumentElement xmlns:sql="urn:schemas-microsoft-com:xml-sql">
        <sql:header>
          <sql:param name="ShipperID" default="2"/>
          <sql:param name="CompanyName" default="United Package New"/>
          <sql:param name="Phone" default="(503) 555-3199 (new)"/>
        </sql:header>
        <sql:sync>
            <sql:before>
            </sql:before>
            <sql:after>
                <Shippers sql:id="1" ShipperID="\$ShipperID"
            CompanyName="\$CompanyName" Phone="\$Phone"/>
            </sql:after>
        </sql:sync>
    </DocumentElement>')),
        vector ('ShipperID','10','CompanyName','DHL','Phone','+359 32 144'));
            -- <- this is a array with input parameters

This will add one record to the Shippers table with the data in the
array. Note that the slash/dollar sign pair '\\$' transforms to dollar
sign '$' only

# XML Templates

Virtuoso XML templates allow execution of queries over HTTP in order to
achieve any combination of the following:

Execution of SQL queries returned in an XML formatted resultset.

Execution of XQuery and XPath queries against XML and SQL-XML documents
in the Virtuoso WebDAV repository.

Use an XML notation (Updategrams) to insert/update/delete SQL data.

An XML template is an XML file containing a query, optional parameters
with default values for the query, a place to specify an XSL stylesheet,
and a section for specifying updatagram based synchronization metrics.
They are meant to be executed as an XML described short-cut to an query
result, an XML document. The XML document returned from calling an XML
template can be served raw, or transformed using XSLT.

XML templates can be executed from within Virtuoso procedure language
using the [`xml_template()`](#fn_xml_template) function, or published as
SOAP compliant XML Web Services, which makes them accessible to any SOAP
and WSDL aware environment.

XML templates provide quick easy access to results from a SQL query as
usual, but now this can be saved to a file. The results are not saved,
just the query definition. You can use this feature to rapidly produce
dynamic reports that can potentially be rendered in different ways by
providing an alternate stylesheet. The report can be refined on the fly
by providing parameters for the query. The output is reachable via HTTP
directly by providing the URL to the template.

When XML templates are executed via HTTP, the XSLT transformation will
be performed automatically if the "sql:xsl" attribute is specified in
the templates root element. This means that the default XSLT
transformation cannot be avoided if the template is executed over HTTP.
However, you have the option whether to apply the transformation or not
when using the `xml_template()` function. XML templates containing
\<sql:query\> elements return either results or messages regarding the
queries. An XSLT transformation can be made on the result from
`xml_template()` using the returned XSLT sheet URL. Hence it is
conditional in PL programming. The application developers can choose to
either use the style sheet specified in the template, use another style
sheet, or skip XSLT transformation entirely. This feature provides full
flexibility for the procedure developer.

XML templates are intended for execution over HTTP. The template file
can be stored either on the file system, WebDAV repository or stored on
another HTTP server being referenced by a URL parameter. Specifying a
template as a URL parameter naturally introduces a new potential
security risk associated with the template owners web server.

![Conceptual View of XML Templates](xmltemplatediagram.jpg)

Queries and updategrams can be parameterized. The parameters must be
defined in the header element, which consists of zero or more param
elements. The default value of the parameter is enclosed within the
param element whose values are typically replaced during the execution
phases. When XML templates are executed from the `xml_template()`
function the parameters are specified in a vector as an input parameter.
When XML templates are executed via HTTP the parameters are contained in
the URL.

> **Important**
> 
> All \<sql:param\> parameter definitions in the template for SQL
> queries need to be named parameters, and the names must be preceded by
> a colon i.e. :ParamName (note colon at the front)

. The colon is not required for updategrams.

If an error occurs as a result of executing a SQL query or updategram,
the comment will be included in the result detailing the error. The
subsequent queries and updategrams will still be executed.

> **Tip**
> 
> The [Exposing Persistent Stored Modules as Web
> Services](#expwsmodules) section as this also describes how XML
> Templates can be published to web services as a SOAP messages using a
> PL Wrapper. This is achieved using the Administrative Interface.
> 
> [`xml_template()`](#fn_xml_template)

## Syntax

The format of an XML template is shown below, illustrating how SQL
queries and updategrams are specified:

    <root xmlns:sql="urn:schemas-openlink-com:xml-sql" sql:xsl='xslt url' >
      <sql:header>
        <sql:param name=":...">..</sql:param>
        <sql:param name=":...">..</sql:param>...
      </sql:header>
      <sql:query>
        select ... for xml ..
      </sql:query>
      <sql:sync>
        Update gramm
      </sql:sync>
    </root>

The root element can contain two attributes. The first is the required
namespace declaration of xmlns:sql="urn:schemas-openlink-com:xml-sql",
required to identify the XML as an XML template. The second attribute
allows the specification of an optional XSLT stylesheet to be applied to
the resulting XML document, if applicable. The XSLT stylesheet file can
be specified as either a relative or absolute URL.

The following elements can be defined in the "sql" namespace for an XML
Template:

  - The
    
    *"root"*
    
    tag can be any name, its purpose is to provide the top-level element
    required for any well-formed XML, and provides the root element for
    the resulting XML document, if any.

  - *\<sql:header\>*
    
    This tag is used to hold the parameters for templates execution such
    as \<sql:param\> elements. The \<sql:header\> element allow us to
    define multiple parameters.

  - *\<sql:param\>*
    
    This element is used to define a named parameter that is passed to
    the query and/or updategram inside the template. Each \<xsl:param\>
    element defines one parameter. Multiple \<xsl:param\> elements can
    be specified within the \<sql:header\> element.

  - *\<sql:query\>*
    
    This element is used to specify SQL/XML queries. It is possible to
    specify multiple \<sql:query\> elements within a single template.

  - *\<sql:sync\>*
    
    This element is used to contain updategrams.

\<sql:query\> and \<sql:sync\> entries are executed sequentially in the
order they appear as separate transactions. Therefore, if you have
multiple \<sql:query\> or \<sql:sync\> elements in the template, if one
fails, the others will proceed.

XML templates can be executed directly from Virtuoso PL using the
[`xml_template()`](#fn_xml_template) function.

To allow XML template execution from a Virtuoso virtual directory and
it's descendants the special option: 'xml\_templates' must be used in
the virtual directory definition. This option can be set from the
[Conductor / Web Application Server / Virtual Domains &
Directories](#httpvirtualdirs) or from SQL (or ISQL) using the
[`vhost_define(.... , opts=>vector('xml_templates',
'yes'));`](#fn_vhost_define) function. In the usual way, the SQL user
specified for VSP execution within the virtual directory definition will
be used for executing the templates within such web directories. If your
XML Templates are to run from a DAV directory then you must allow
suitable execute permissions for the file and directory.

When a virtual directory is configured to allow execution of XML
templates be aware that this also means that descendant directories
inherit this property. Also be aware that this also allows execution of
VSP files in the normal way. WebDAV also has another layer of security
attributes that will need to be set to enable files to be executable. By
default files in DAV do not have execute privileges.

Explicitly specifying "contenttype=text/html" as a URL parameter will
instruct the Virtuoso HTTP server to return the HTML output.

> **Tip**
> 
> Functions: [`xml_template()`](#fn_xml_template) ,
> [`xmlsql_update()`](#fn_xmlsql_update) , [`xml_auto()`](#fn_xml_auto)
> .
> 
> [UpdateGrams](#updategrams) .
> 
> The [FOR XML clause](#forxmlforsql) .

## Saving SQL Queries to XML Template

Using the Conductor Administration Interface, we are going to make and
save a query to an XML template in WebDav, and then demonstration its
use from a browser.

First we will make a new WebDAV directory. From Web Application Server
-\> Content Management -\> Repository click the "New folder" icon and in
the shown form enter for "Folder Name": xmlt. Choose for "Owner" dav and
click the "Create" button.

![Creating a new directory (collection) in WebDAV](xmltemplate001.png)

Next we need to configure a virtual directory mapping to this so that
XML Templates can be executed later. Go to Web Application Server /
Virtual Domains & Directories and for your {Default Web Site} click the
link "New Directory". In the shown form click "Next".

![Configuring a Virtual Directory to respond to XML Template requests
from our Dav](xmltemplate004.png)

The programmatic equivalent for creating a virtual directory is the
command in iSQL:

    SQL>vhost_define(lpath=>'/DAV/xmlt',
                     ppath=>'/DAV/xmlt/',
                     is_dav=>1,
                     vsp_user=>'demo',
                     opts=>vector('xml_templates', 'yes'));

Now we go to Database/Interactive SQL and will use a simple query. Here
we are assuming that the Demo database is being used, so we will query
the Customers table:

![A SQL Query](xmltemplate002.png)

![Results](xmltemplate002a.png)

Now go to XML -\> SQL-XML and enter in the query area the sql statement
from above. Here we can supply some "FOR XML" clause, "FOR XML AUTO"
being the simplest. Enter in the field "WebDAV resource path for the
result" the directory we created earlier, i.e. it should be /DAV/xmlt
and add the name of the xmltemplate to which the result will be saved,
for example: sql-template.xml So finally the value should be
`/DAV/xmlt/sql-template.xml` .

![The Save XML Template page and settings](xmltemplate005.png)

Once the template has been saved we can test it. Point your browser at
you newly created file, a URL similar to:
`http://host:port/DAV/xmlt/sql-template.xml` :

![The test results:
http://host:port/DAV/xmlt/sql-template.xml](xmltemplate006.png)

> **Tip**
> 
> Exposing XML Templates as Web Services .

## Saving XQUERY Queries to XML Template

Using the Conductor Administration Interface, we are going to make and
save a query to an XML template in WebDav, and then demonstration its
use from a browser.

First we will make a new WebDAV directory. From Web Application Server
-\> Content Management -\> Repository click the "New folder" icon and in
the shown form enter for "Folder Name": xmlt. Choose for "Owner" dav and
click the "Create" button.

![Creating a new directory (collection) in WebDAV](xmltemplate001.png)

Next we need to configure a virtual directory mapping to this so that
XML Templates can be executed later. Go to Web Application Server /
Virtual Domains & Directories and for your {Default Web Site} click the
link "New Directory". In the shown form click "Next".

![Configuring a Virtual Directory to respond to XML Template requests
from our Dav](xmltemplate004.png)

The programmatic equivalent for creating a virtual directory is the
command in iSQL:

    SQL>vhost_define(lpath=>'/DAV/xmlt',
                     ppath=>'/DAV/xmlt/',
                     is_dav=>1,
                     vsp_user=>'demo',
                     opts=>vector('xml_templates', 'yes'));

Now we go to XML -\> XQuery -\> XQuery Advanced.

We will start by testing the following query against the Demo database

    <bib>
       {
       for $b in document("bib.xml")/bib/book
       where $b/publisher = "Addison-Wesley" and $b/@year > 1991
       return
          <book year = {$b/@year}>
             {$b/title}
          </book>
       }
    </bib>

![XQUERY query against the Demo database](xmltemplate007.png)

Now we will save this as an XML template by pressing the Save button.
The query we used will be copied to the save XML template page. We will
ensure that the name of the file is `/DAV/xmlt/xquery-template.xml` :

![Saving the XML template for the Xquery query](xmltemplate008.png)

> **Tip**
> 
> Exposing XML Templates as Web Services .

## Saving XPATH Queries to XML Template

Using the Conductor Administration Interface, we are going to make and
save a query to an XML template in WebDav, and then demonstration its
use from a browser.

First we will make a new WebDAV directory. From Web Application Server
-\> Content Management -\> Repository click the "New folder" icon and in
the shown form enter for "Folder Name": xmlt. Choose for "Owner" dav and
click the "Create" button.

![Creating a new directory (collection) in WebDAV](xmltemplate001.png)

Next we need to configure a virtual directory mapping to this so that
XML Templates can be executed later. Go to Web Application Server -\>
Virtual Domains & Directories and for your {Default Web Site} click the
link "New Directory". In the shown form click "Next":

![Configuring a Virtual Directory to respond to XML Template requests
from our Dav](xmltemplate004.png)

The programmatic equivalent for creating a virtual directory is the
command in iSQL:

    SQL>vhost_define(lpath=>'/DAV/xmlt',
                     ppath=>'/DAV/xmlt/',
                     is_dav=>1,
                     vsp_user=>'demo',
                     opts=>vector('xml_templates', 'yes'));

Now we set our sights on the XML files in WebDAV. We will perform a very
simple XPATH query on an XML source file from this documentation. We
will search for the existence of `<title>` tags in
`http://host:port/DAV/docsrc/adminui.xml` :

![XPATH query on a file in WebDAV](xmltemplate009.png)

Make a quick mental note of the trivial result. Now we will save our
query as an XML template to be executed over HTTP. Pressing the Save
button takes us to the save XML Template page. We ensure that the file
to save is set to `/DAV/xmlt/xpath-template.xml` :

![](xmltemplate010.png)

Once our query has been saved in an XML template we can test it by
pointing a web browser at the URL for the file as we configured our
virtual directory for, which will be similar to:
`http://example.com/DAV/xmlt/xpath-template.xml` :

![](xmltemplate011.png)

> **Tip**
> 
> Exposing XML Templates as Web Services .

## Programmatic Examples

First step is to setup the /xmlt directory on file system. The function
[`vhost_define()`](#fn_vhost_define) will be used to enable execution of
XML templates. DBA privileges are required to use this function:

    SQL> vhost_define (lpath=>'/xmlt', ppath=>'/xmlt/',
      vsp_user=>'demo', opts=>vector('xml_templates', 'yes'));

Now the following files must be stored as: \<www-root\>/xmlt/file1.xml

    <?xml version ='1.0' encoding='UTF-8'?>
     <root xmlns:sql='urn:schemas-openlink-com:xml-sql' sql:xsl='shippers.xsl'>
       <!-- XML template example -->
    
       <!-- parameters declaration -->
    
        <sql:header>
          <sql:param name=":ShipperID">2</sql:param>
          <sql:param name=":CompanyName">United Package (you should see me)</sql:param>
          <sql:param name=":Phone">(503) 555-3199</sql:param>
        </sql:header>
       <!-- XML updategram , this will update the second record -->
    
        <sql:sync>
            <sql:before>
                <Shippers sql:id="1" ShipperID=":ShipperID"/>
            </sql:before>
            <sql:after>
                <Shippers sql:id="1" ShipperID=":ShipperID" CompanyName=":CompanyName" Phone=":Phone"/>
            </sql:after>
        </sql:sync>
       <!-- make a parametrized query -->
    
       <sql:query>
          SELECT ShipperID, CompanyName,Phone FROM Shippers where ShipperID = :ShipperID FOR XML AUTO
       </sql:query>
       <!-- make an error to see what happens -->
    
       <sql:query>
          select * from NotExist for xml auto
       </sql:query>
    </root>

Now we want an XSL stylesheet stored as: \<www-root\>/xmlt/shippers.xslt
containing the following:

    <?xml version="1.0"?>
    
    <xsl:stylesheet
        version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:output method="html" indent="yes" />
    
      <xsl:template match="/">
        <html>
            <head>
            <title>Shippers list</title>
            </head>
            <body>
            <xsl:apply-templates/>
            </body>
        </html>
        </xsl:template>
    
      <xsl:template match="root">
        <table>
            <tr><td>ID</td><td>Name</td><td>Phone</td></tr>
            <xsl:apply-templates/>
        </table>
        </xsl:template>
    
      <xsl:template match="Shippers">
        <tr>
            <td><xsl:value-of select="@ShipperID"/></td>
            <td><xsl:value-of select="@CompanyName"/></td>
            <td><xsl:value-of select="@Phone"/></td>
        </tr>
        </xsl:template>
    </xsl:stylesheet>

Point your web browser to:

    http://[host:port]/xmlt/file1.xml

and then at:

    http://[host:port]/xmlt/file1.xml?:ShipperID=3

for the results.

The first step is to create a new DAV collection and configure it to
allow XML template execution. DBA privileges are required for these
operations. To create a DAV collection the function
[`dav_col_create()`](#fn_dav_api_add) can be used, followed by the
[`vhost_define()`](#fn_vhost_define) function to allow XML template
execution:

    SQL> dav_col_create ('/DAV/xmlt/', '110100100', 'dav', 'dav', 'dav', 'dav');

    SQL> vhost_define (lpath=>'/DAV/xmlt', ppath=>'/DAV/xmlt/',
      is_dav=>1, vsp_user=>'demo', opts=>vector('xml_templates', 'yes'));

Now, the file can be uploaded. The same file as in the previous example
will be used, copied from the file system location to the DAV location:
\<www-root\>/DAV/xmlt/file1.xml

    SQL> dav_res_upload ('/DAV/xmlt/file1.xml',
      file_to_string (concat (http_root(), '/xmlt/file1.xml')), 'text/xml',
      '111101101N', 'dav', 'dav', 'dav', 'dav');

Likewise the XSLT stylesheet from the previous example will also be used
in the same way, placing into the DAV location:
\<www-root\>/DAV/xmlt/shippers.xslt

    SQL> dav_res_upload ('/DAV/xmlt/shippers.xsl',
      file_to_string (concat (http_root(), '/xmlt/shippers.xsl')),
      'text/xsl', '110100100N', 'dav', 'dav', 'dav', 'dav');

This example can now be demonstrated by trying the following URLs in
your web browser:

    http://[host:port]/DAV/xmlt/file1.xml

and

    http://[host:port]/DAV/xmlt/file1.xml?:ShipperID=3

# XML DTD and XML Schemas

## XML Document Type Definition (DTD)

It is always useful to store a description of an XML document inside the
document itself. XML DTD is a set of directives to describe the
structure of the document and references to other XML documents.

The XML parser of the Virtuoso Server can recognize and use most DTD
directives.

If DTD describes the structure of the document (i.e. the allowed content
of elements with particular names) then the XML parser can validate the
source document in order to check if it matches to the rules written in
the DTD.

If a DTD describes references to external XML entities then the parser
can build either "standalone" or "non-standalone" internal
representation. To build a "standalone" representation, the XML parser
will retrieve all external resources and then it will replace every
occurrence of every reference with a copy of the whole content of the
resource. To build a "non-standalone" representation, XML parser
remembers only referencing information but it tends to not retrieve
external documents; they can be retrieved on demand later.

A DTD may describe some attributes as "unique identifiers" and as
"references to unique identifiers". If requested, the XML parser can
check that identifiers are really unique or that there are no "dangling"
references to missing identifiers.

In an ideal world, source documents match the XML standard perfectly and
all declared URIs are valid and can be accessed. The real application,
however, should read inaccurate data and ignore some minor errors. To
let the XML parser signal only errors that really can affect the
application, it is possible to precisely configure the reaction of the
parser on every sort of problem. In addition, the application can get a
detailed human-readable log of diagnostic messages by calling
[`xml_validate_dtd()`](#fn_xml_validate_dtd) to let user fix the
document in question.

If an XML document contains a DTD then DTD is placed before any data
nodes (if parts of DTD can be placed in separate documents then they
will be retrieved before parsing data nodes). Thus XML parser has enough
data to perform "DTD validation" of the source document right during the
reading. It lets the parser provide detailed diagnostics with precise
location of detected errors.

## Configuration Options of the DTD Validator

If some built-in Virtuoso/PL or XPATH function can invoke XML parser
then it is probably have a special argument to pass configuration
options to the XML parser. The most typical value of such an argument is
"configuration string" that is a sequence of pairs parameter=value,
delimited by spaces. Instead of single string, it can be passed as a
vector of strings of even length of sort

    vector (parameter1, value1, parameter2, value2 ...)

. It can be NULL indicating that the parser can use default values. No
errors are reported if a parameter is specified twice, in which case the
last specified value will be used. The only exception is the
'Validation' parameter which sets typical values for all parameters; if
it is specified then it should be the first parameter in the list. Both
parameter names and values are case-insensitive.

Many parameters are used to specify the importance of a particular
error. For a particular application some validity constraints may be
much more important than others. Because less than perfectly valid XML
is common in practice it is important to configure the validator to
report only those errors which are relevant to the application. Using
configuration parameters, one may specify "importance levels" for every
group of problems. There are 5 "importance levels":

| Error Level | Description                                                                                                                                                                                                                          |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| FATAL       | violations must be reported and further processing of XML source must be terminated right after the term where the violation was detected, without checking for errors in the rest of the document                                   |
| ERROR       | violations must be reported and validation should continue to find further errors, but no XML document will be built if validation is invoked from such function as [`xtree_doc()
`](#fn_xtree_doc) or [`xper_doc()
`](#fn_xper_doc) |
| WARNING     | violations must be reported but XML processing will continue                                                                                                                                                                         |
| IGNORE      | validator must try to locate violations of given sort but only severe (possibly fatal) violations must be reported                                                                                                                   |
| DISABLE     | the specified check must be turned off fully, saving time and maybe memory                                                                                                                                                           |

Error Catch Levels

Some parameters are just switches, with only two values available:
'ENABLE' and 'DISABLE'.

**AttrCompletion (ENABLE/DISABLE, default is DISABLE).**

This is useful when DTD validator is invoked from XML parser. When
enabled, the XML document built will contain default values of 'IMPLIED'
attributes as if they present in source text. It may be useful if
application should perform free-text search on all attribute values
including defaults or if XML should be converted in form suitable for
external non-validating XML processor or if given XML data should be
stored later as part of composite document and composite document will
have another DTD with other default values.

**AttrMisFormat (FATAL/ERROR/WARNING/IGNORE/DISABLE, default is
DISABLE).**

This describes how to report errors in syntax of values of attributes.

**AttrUnknown (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report attributes whose names are not listed in
the DTD.

**BadRecursion (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report circular references, when replacement text
of an entity contains reference to this entity again, either directly
(e.g. '\<\!ENTITY bad "some \&bad; replacement"\>) or through other
entities (e.g. '\<\!ENTITY a "\&b;"\> '\<\!ENTITY b "\&a;"\>).

**BuildStandalone (ENABLE/DISABLE, default is DISABLE).**

When set to ENABLE, replacement texts of external entities will be
inserted instead of references to these entities, thus all data from a
composite document will be gathered together into one large XML. This is
useful for checking the element content model of the whole document
without breaks on references or if parsed XML will be passed to external
application as a standalone document.

**Fsa (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report violations of specified element-content
model. Virtuoso's DTD validator contains a finite state automaton which
can detect the first error in the content of some element, but remaining
errors in the same element become "obscured" by the first one and will
not be reported. Moreover, if element-content model is not
SGML-compatible, some errors may remain undiscovered: it is possible to
write a complex rule, so ambiguous that full check of all its
interpretations will take prohibitively much time and memory. The
validator will simplify such rules to make check faster, thus some
errors will not be reported.

**FsaBadWs (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report the most frequent violation of
element-content model specified by DTD: the use of whitespace characters
in positions where only elements are allowed, not PCDATA. It usually
happens when XML is indented for readability. You may wish to specify
'FsaBadWs=IGNORE' to eliminate redundant messages about this violation.
Note that if you will specify 'FsaBadWs=DISABLE' then you will disable
the check of illegal PCDATA tokens for this particular case, so common
rule for 'Fsa' violations will be applied and you will see messages.

**FsaSgml (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report violations of SGML compatibility in
element-content model. Some complex DTD rules for elements are not
supported by SGML processors and the validator may report the use of
such rules.

**GeRedef (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report redundant definitions of generic entities.
There redefinitions are errors in SGML but they may be ignored in XML
processing. The first definition will be used and others will be
ignored.

**IdDuplicates (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report non-unique values of ID attributes. It is a
data integrity error, because IDs are usually parts of some primary
keys, and are expected to be unique.

**IdrefIntegrity (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report "dangling references". Any value of IDREF
attribute and any name from value of IDREFS attribute should appear in
the same XML document as value of some ID attribute. You can think that
an ID attribute specifies a hyperlink anchor and IDREF is a hyperlink,
so it's a data integrity error if a hyperlink points to unknown
location.

**Include (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This configures reading of external sub-documents into "main" document
you validate (and maybe load in database). If 'DISABLE', no additional
documents will be read, otherwise external parameter-entities, external
generic-entities and external DTD will be located, using their SYSTEM
names. External documents may reside in file system, in database or in
the Web. Absolute SYSTEM names (of form 'protocol://server/resource')
will be used without any modifications, relative SYSTEM names should be
"resolved", i.e. converted to absolute by adding a prefix from the
`base_uri` argument of SQL function.

**MaxErrors (a string that represents an integer from 1 to 10000,
default is '25').**

This specifies how many errors may be logged before the "Too many error
messages" fatal error will be reported.

**MaxWarnings (a string that represents an integer from 0 to 10000,
default is '100').**

This specifies how many warnings may be logged before the "Too many
warning messages" event will stop their logging.

**NamesUnknown (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report if the document contains element names
which are not the declared in DTD. They may be typos in element names or
signal that DTD is incomplete or obsolete. In addition, unknown names
may be reported as element-content model violations.

**NamesUnordered (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report element names not declared before use in
DTD. Proper order ("declare element name before use it") is important
solely for compatibility with SGML standard.

**NamesUnresolved (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report if an element name used in the DTD is not
declared at all. This may occur if DTD is incomplete or if some
declaration in it are ignored conditional sections. Unresolved names
cause no data integrity errors while remain unused in data section of
the XML document, NamesUnknown parameter defines what happens if they're
actually used.

**PeRedef (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report redundant definitions of parameter
entities. Similarly to redefinitions of generic entities, there
redefinitions are errors in SGML but they may be ignored in XML
processing. The first definition will be used and others will be
ignored.

**Sgml (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report violations of SGML compatibility. In fact,
not all such violations are detected by the Virtuoso Server, because
known SGML readers are insensitive to some sorts of violations.

**TooManyWarns (FATAL/ERROR/WARNING/IGNORE/DISABLE).**

This describes how to report "Too many warning messages" event. While
"Too many errors" is fatal error and terminates XML processing, "Too
many warning messages" may have arbitrary "importance levels".

**TraceLoading (ENABLE/DISABLE, default is DISABLE).**

If set to 'ENABLE', the validator will log every reading of any
resource, for easier tracking of URI resolving problems. It's possible
that some readings of sub-documents will not be reported: there's a
limit for number of records in the log returned by the validator. In
addition, sub-documents may be cached inside validator, so only first
references to some sub-document will require reading procedure.

**Validation (SGML/RIGOROUS/QUICK/DISABLE, default is DISABLE).**

This loads one of four "preset configurations". It must be the first
parameter in configuration string, if used. DISABLE means "do not check
for any type of error", QUICK is to check only for violation of "local"
validity constraints, with disabled FsaBadWs, IdDuplicates and
IdrefIntegrity, RIGOROUS enables these three groups, too, SGML enables
all checks including all checks for SGML compatibility.

**VcData (ENABLE/DISABLE, default is DISABLE).**

This describes how to report violations of generic validity constraints
in data section of XML document. If constraint is not configured by
other parameters listed here, it will be configured by this parameter
(or by VcDtd if relates to the text of DTD section).

**VcDtd (ENABLE/DISABLE, default is DISABLE).**

This describes how to report violations of generic validity constraints
in DTD section of XML document. If constraint is not configured by other
parameters listed here, it will be configured by this parameter (or by
VcData if relates to the text of data section).

## XML Schema Definition Language

The W3C XML Schema Definition Language is a way of describing and
constraining the content of XML documents.

The XML Schema specification consists of three parts. One part defines a
set of simple datatypes, which can be associated with XML element types
and attributes; this allows XML software to do a better job of managing
dates, numbers, and other special forms of information. The second part
of the specification proposes methods for describing the structure and
constraining the contents of XML documents, and defines the rules
governing schema validation of documents. The third part is a primer
that explains what schemas are, how they differ from DTDs, and how one
builds a schema.

XML Schema introduces new levels of flexibility that may accelerate the
adoption of XML for significant industrial use. For example, a schema
author can build a schema that borrows from a previous schema, but
overrides it where new unique features are needed. XML Schema allows the
author to determine which parts of a document may be validated, or
identify parts of a document where a schema may apply. XML Schema also
provides a way for users of e-commerce systems to choose which XML
Schema they use to validate elements in a given namespace, thus
providing better assurance in e-commerce transactions and greater
security against unauthorized changes to validation rules. Further, as
XML Schema are XML documents themselves, they may be managed by XML
authoring tools, or through XSLT. The implementation of XML Schema in
Virtuoso is based on [the W3C XML Schema Specification](#) .

> **Tip**
> 
> [XML Schema Part-0: Primer](#)
> 
> [XML Schema Part-1: Structures](#)
> 
> [XML Schema Part-2: Datatypes](#)

For parsing the schema definitions the DTD definition of XML Schema is
used. This definition was taken from [XML Schema Part-1: Structures](#)
.

## XML Schema Functions

The Virtuoso interface to XML Schema is represented primarily by two
functions:

xml\_validate\_schema()

xml\_load\_schema\_decl()

The signature of the function
[`xml_validate_schema()`](#fn_xml_validate_schema) is the same as the
function [`xml_validate_dtd()`](#fn_xml_validate_dtd) . It parses and
validates an XML document. The root element of the document must contain
the `"schemaLocation"` attribute with the value of the document's URI.

As described above, the XML Schema Processor implemented within Virtuoso
relies on the XML Schema DTD, which is composed of two files:
"XMLSchema.dtd" and "datatypes.dtd." These files must be placed in the
system directory (see [`xml_add_system_path()`](#fn_xml_add_system_path)
).

The following XML Schema items are not fully implemented: facets support
is primitive;, you may only derive by restriction from the "anyType"
type;, enumerations are not supported;, the "all" particle is not
supported;, elements may not be defined within an element model group
declaration;, unions are not supported;, "appinfo," "documentation,"
"list," and "notation" tags are ignored.

Virtuoso does not cache XML Schema documents; they are completely
reprocessed every time the document is loaded.

## XML Schema & SOAP

The XML Schema defines primitive types, such as "integer","string" and
"float". Users may extend or restrict the primitive types to build their
own type system. For example, a type "monthCode" could be an enumerated
list of three character strings corresponding to JAN, FEB, etc... SOAP
types can use any of these types: native, primitive XML Schema types or
complex types which should be fully described using XML Schema.

SOAP messages that use XML Schema types or complex types contain a
fragment of XML Schema or a reference to a schema file so that the data
types can be determined and messages validated.

The Virtuoso tutorials contain many examples from the SOAP Interop test
suite. Each tutorial displays both the request message and response
message from the server when the tests are executed. Below is a sample
message exchange of the echoStruct tutorial (SO-S-20) which uses a
trivial complex struct composed of an integer, float and a string:

Struct parameter inputs:

``` 
 varString = hello
 varInt = 42
 varFloat = 99.004997253418
```

Return value:

``` 
 varString = hello
 varInt = 42
 varFloat = 99.004997253418
```

Request message:

    <?xml version='1.0' ?>
    <SOAP:Envelope
        SOAP:encodingType='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:xsd='http://www.w3.org/2001/XMLSchema'
        xmlns:SOAP='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"  xmlns:dt='urn:schemas-microsoft-com:datatypes'>
      <SOAP:Body>
        <cli:echoStruct SOAP:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
            xmlns:cli='http://soapinterop/' >
          <inputStruct>
            <varInt xsi:type="xsd:int" dt:dt="int">42</varInt>
            <varFloat xsi:type="xsd:float" dt:dt="float">99.004997</varFloat>
            <varString xsi:type="xsd:string" dt:dt="string">hello</varString>
          </inputStruct>
        </cli:echoStruct>
      </SOAP:Body>
    </SOAP:Envelope>

Response message:

    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <SOAP-ENV:Envelope
        xmlns:SOAPSDK1="http://www.w3.org/2001/XMLSchema"
        xmlns:SOAPSDK2="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:SOAPSDK3="http://schemas.xmlsoap.org/soap/encoding/"
        xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
      <SOAP-ENV:Body SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
        <SOAPSDK4:echoStructResponse
            xmlns:SOAPSDK4="http://soapinterop/">
          <Result href="#id1"/>
        </SOAPSDK4:echoStructResponse>
        <SOAPSDK5:SOAPStruct
            xmlns:SOAPSDK5="http://soapinterop.org/xsd"
    
    xml:id="id1" SOAPSDK3:root="0"
            SOAPSDK2:type="SOAPSDK5:SOAPStruct">
          <varString>hello</varString>
          <varInt>42</varInt>
          <varFloat>99.004997253418</varFloat>
        </SOAPSDK5:SOAPStruct>
      </SOAP-ENV:Body>
    </SOAP-ENV:Envelope>

> **Tip**
> 
> [Extending SOAP Types](#dtschsoaps)
> 
> [SOAP Literal Encodings](#soapdoclitenc1)

# XQuery 1.0 Support

The Virtuoso Server provides support for the [XQuery 1.0 XML Query
Language](#) specification. This specification is currently in the
working draft stage at the W3C XML Query Working Group working in
collaboration with the W3C XSL Working Group. Both the syntax and
semantics of XQuery will probably vary from version to version.

In addition to the XQuery 1.0 standard, which describes the language,
the [XQuery 1.0 and XPath 2.0 Functions and Operators Version 1.0](#)
specification describes a set of built-in functions. As with all W3C
in-progress efforts, there is a list of open issues detailing problems
and unresolved areas; where these affect Virtuoso's implementation, they
are noted below.

This chapter is not an XQuery textbook and does not replace
XQuery-related specifications of W3C. Only Virtuoso-specific extensions
and differences are described here.

The most important deviation from the standard is that Virtuoso does not
provide full type information about data values. As a consequence,
"typeswitch" and automatic type conversions are not implemented.

## Types of XQuery Expressions

The current draft of XQuery lists 10 groups of XQuery expressions:

  - Primary expressions, including literals, variable references and
    function calls.

  - Path expressions, including all XPATH 1.0 expressions and a "pointer
    operator".

  - Sequence expressions.

  - Arithmetic, comparison and logical operators.

  - Element constructors, which allow you to create new element nodes
    with specified names, lists of attributes and lists of children.

  - FLWR (FOR-LET-WHERE-RETURN) expressions, which allow you to create
    variables for intermediate results and to transform sequences of
    items on a per-item basis.

  - Ordered and unordered expressions to force some sorting of
    intermediate results or to prevent the XQuery processor from making
    redundant sorting.

  - Control expressions, such as IF.

  - Quantified expressions: SOME and EVERY.

  - Expressions that test or modify data types.

Not all groups of expressions are implemented. In some groups, not all
kinds of clauses are implemented.

In addition to the standard, Virtuoso supports special cases of FLWR
expressions to deal with XML views:

  - [FOR Clause expressions with xmlview()
    function.](#xq_supported_xmlview)

### Primary Expressions

XQuery processor uses 32-bit integers on 32-bit platforms and 64-bit
integers on 64-bit platforms. Similarly, the scale and precision of
floating-point operations may vary from platform to platform.

Note that string literals are handled differently in XPath 1.0 and
XQuery. "Ben "amp; Jerry"apos;s" denotes the string "Ben " Jerry's" in
XQuery and the string "Ben "amp; Jerry"apos;s" in XPath.

### Path Expressions

Any XPath 1.0 expression is a valid XQuery 1.0 path expression, which
the Virtuoso XQuery processor supports. When invoked from the XQuery
context, the XPath Processor works in accordance with XSLT rules. There
are two major differences between standalone and XQuery/XSLT path
expressions. First, the meaning of non-qualified name used as NameTest
criterion, as described below. Second, the data type used for attributes
varies. In XPath or XQuery mode, if a value is calculated by an
`attribute::` axis, it is of type `attribute
entity` ; in standalone XPath, the string value of the attribute is used
instead.

As specified in the XQuery 1.0 standard, a node-set returned by an XPath
expression may be used as a sequence of items, where every node of that
node-set becomes an item of the sequence. The opposite is not true,
however. Not every sequence may be converted into a node-set, even if it
is a sequence of nodes. If XPath starts from a function which returns a
sequence, an error message "Context node is not an entity" is returned.
Fortunately, a variable of type

    sequence

may be used as a node-set if all items of the sequence are nodes.

Obsolete drafts of W3C specification contains description of "pointer
operator". Virtuoso continues to support this operator to provide
backward compatibility. XQuery processor needs DTD data associated with
the XML document in question to distinguish ID attributes from other
sorts of attributes and to bookmark elements that have ID locations. For
more details, see the description of [`id()`](#xpf_id) XPATH function.
This function uses same DTD data for same purposes, so for any given
document, either both `id()` and "pointer operator" are applicable or
both does not work.

Sometimes the "Context node is not an entity" error is signalled if the
beginning of the XPath expression is surrounded by parenthesis, even if
the expression works fine without these parenthesis. This happens
because "(...)" is an "append" operator in XQuery, not just a way to
group subexpressions. "append" converts a node-set into a sequence even
when it is called with a single argument - that is, without commas
inside "(...)". This sequence cannot be used as input for the rest of
the XPath expression.

As an syntax extension, special notation of QNames is added and can be
used, e.g., in NameTest. An expanded name can be surrounded by
delimiters (\! and \!), like (\!http://www.example.com:MyTag\!) and this
syntax allows names that contain otherwise prohibited characters. This
syntax is also useful when the text of the query is generated by
software.

Note that the NameTest that consists of an unqualified name has
different meanings in Virtuoso XPath and in XQuery. In XPath, NameTest
"sample-tag" means "any element whose local-name is equal to
sample-tag". In XQuery, the same test means "any element without
namespace-uri whose local-name is equal to sample-tag".

### Sequence Expressions

XQuery sequences are supported not only in XQuery but can also be
handled in XPath and XSLT. When the XQuery processor is invoked from SQL
and a sequence is returned to the caller, the sequence is automatically
converted into a vector of its elements.

Virtuoso supports all sequence operations listed in current W3C paper
plus deprecated operations BEFORE and AFTER.

The `sequence concatenation` operator is available in XPath and XSLT as
the [`append()`](#xpf_append) function. In addition, the
[`tuple()`](#xpf_tuple) function is available to get the first items of
every given argument sequence and return the sequence of these items.

XQuery operators UNION, INTERSECT, EXCEPT are available in XPath and
XSLT as functions [`union()`](#xpf_union) ,
[`intersect()`](#xpf_intersect) and [`except()`](#xpf_except) .

### Arithmetic, Comparison and Logical operations

Virtuoso shares the implementation of basic arithmetic and comparison
operations between XPath, XQuery, XSLT, SQL and Virtuoso/PL processors,
so type casting, scale and precision of calculated values are identical
across the system. All operators are available in XQuery, in addition,
\<\< and \>\> operators are available in XPath and XSLT as
[`is_before()`](#xpf_is_before) and [`is_after()`](#xpf_is_after)
built-in functions.

### Element Constructors

Virtuoso XQuery supports all XQuery 1.0 direct constructors. Previous
versions of W3C draft contained the syntax for placing calculated
content into the opening tag of direct element constructor, such as

    <{concat("calculated-", "element-name")} {concat("calculated-", "attribute-name")}={concat("calculated-", "attribute-value")}>...</>

. Thus name of element or attribute, or a value of an attribute can be
calculated dynamically. This syntax is still supported. The
[`create-element()`](#xpf_create_element) XPath function is implemented
to make this functionality available in XPath. Additionally, a special
function [`create-attribute()`](#xpf_create_attribute) may be used to
create a new dynamic attribute entity with value and name calculated,
this works similarly to xsl:attribute XSLT instruction.

Similarly, [`create-comment()`](#xpf_create_comment) ,
[`create-element()`](#xpf_create_element) and
[`create-pi()`](#xpf_create_pi) mimics other XQuery direct constructors
in XPath and XSLT.

The XQuery specification states that when sequence of atomic values is
converted into content of an element constructor, whitespace character
is inserted between adjacent values.

Unlike previous versions of Virtuoso, current XQuery syntax allows you
to use "pure XML notation" inside element constructors. Thus there is no
strict need to write 'constant' expression

    <emp empid="12345"><name>John Smith</name><job>Bubble sorter</job></emp>

as it is dynamically calculated text, like

    <emp empid="12345"><name>{'John Smith'}</name><job>{'Bubble sorter'}</job></emp>

It is still may be useful to write 'constant' expression in the old way.
This artificial restriction simplifies finding syntax errors, because
there are syntactically wrong expressions that are still correct "pure
XML notation." Alternatively, CDATA sections also may be used to make it
obvious that the string is a constant, not an expression with forgotten
braces around it:

    <emp empid="12345"><name><![CDATA[John Smith]]></name><job><![CDATA[Bubble sorter]]></job></emp>

The current version of Virtuoso does not support the new XQuery syntax
for dynamic constructors.

### FLWR Expressions

FLWR expressions are fully supported by Virtuoso XQuery. Moreover,
[`for()
`](#xpf_for) and [`let()
`](#xpf_let) XPath functions are implemented to make this functionality
available in XPath and XSLT. In addition, [`assign()
`](#xpf_assign) and [`progn()
`](#xpf_progn) functions are available to deal with extension functions,
especially when extension functions are called for their side effects.

A special [xmlview()](#xpf_xmlview) function allows very efficient
access to SQL data from XML views.

Previous XQuery specifications used "sort by" instead of "order by". The
difference is that "sort by" was applicable to the final results of the
FLWR statement made by RETURN clause whereas "order by" reorders input
data for RETURN. Thus, "order by" can sort outputs using data that do
not appear in the final result. E.g., an expression can collect items,
"order" them by category and title but output only title and price. This
was much harder in previous versions of XQuery because it was necessary
to prepare an intermediate result that contained title and price and
category, then do "sort" by category and title then use one more FLWR
expression to form a result that is free from redundant data about
category.

Nevertheless, Virtuoso supports both "sort by" and "order by", to keep
backward compatibility. Moreover, "sort by" operator can be freely used
with no relation to any FLWR subexpression. Typical use of such a
simplified notation is

    <hit-list>{//track[@rating] sort by (@rating descending)}</hit-list>

instead of portable

    <hit-list>{for $t in //track[@rating] order by $t/@rating descending return $t}</hit-list>

### Ordered and Unordered Expressions

The current version of Virtuoso does not use ordered/unordered hints.
Everything is calculated ordered. This will change in the future but it
is not advisable to place "unordered" hints for future use because
there's no way to validate these hints. It is better to place
appropriate comments but not hints.

### Control Expressions

The [`if()`](#xpf_if) special function mimics the XQuery operator for
use in XPath and XSLT. Functions [`and()
`](#xpf_and) and [`or()
`](#xpf_or) are also control expressions because they calculate
arguments in strict left-to-right order and may omit the calculation of
some results.

### Quantified Expressions

Both the `SOME` and `EVERY` operators are implemented. The
[`some()`](#xpf_some) and [`every()`](#xpf_every) XPath functions are
implemented to make this functionality available in XPath and XSLT.

### Expressions That Test or Modify Data types

The operators `IS` , `CASTABLE` , `CAST` , `TREAT` , `TYPESWITCH` and
`VALIDATE` are not implemented.

### FOR Clause Expressions With xmlview() Function

XML views can be queried using FOR Clause from FLWR expressions. The
[`xmlview()`](#xpf_xmlview) function allows XML views to be accessed as
if they were XML documents. XPath expressions beginning with the
`xmlview()` function will be translated into SQL statements to avoid
redundant data access and to avoid creating a whole XML tree.

## Details of XQuery Syntax

Virtuoso XQuery uses some syntax extensions. Most visible is an
additional notation for qualified names as described above (name is
surrounded by "(\!...\!)" delimiters. An earlier implementation allowed
single-line comments started with "\#" or "--" continuing to the end of
line, this syntax is now obsolete.

The "default namespace declaration" clause is not currently supported,
to make the text of XQuery unambiguous. If used, default namespaces must
extend element names but not attribute names. Extension function names
must be extended as they have non-default namespace prefixes but the
names of basic functions should not be extended by the default
namespace. Finally, Virtuoso will not preserve any information about
used namespace prefixes, so default namespaces will be converted into
non-default when the resulting XML entity is printed.

## Pre-compilation of XPath and XQuery Expressions

Virtuoso compiles XPath and XQuery expressions as early as it is
possible. E.g. if the first argument of
[`xquery_eval()`](#fn_xquery_eval) is a string constant then the SQL
compiler will invoke the XQuery compiler to avoid on-demand
compilation(s) of this text.

This feature significantly enhances performance of XQuery expressions
embedded in SQL. For a simple search on XML document of average size the
compilation time can be three times greater than execution time. In
addition, the use of [`sql:column()`](#xpf__sql__column) special XQuery
function is possible only when pre-compilation can be done by SQL
compiler.

Pre-compilation is impossible if the text of the expression is not a
constant. The typical case is passing an XQuery expression as parameter
to a function. In this case the expression is compiled during the call
of xquery\_eval() and stored for future use. If the same string is
passed again to the same invocation of xquery\_eval() then a stored
compiled expression is used.

Only partial pre-compilation is possible if XQuery expression refers to
not-yet defined extension functions or to external resources. Partial
pre-compilation gives little gain in speed, but it allows the use of
[`sql:column()`](#xpf__sql__column)

The most important fact about pre-compilation is that passing parameters
into XQuery statement is much more efficient than printing then into the
text of the query. This is similar to SQL queries.

*GOOD* The expression is compiled once when SQL query is compiled:

    select xquery_eval('count(//abstract)', SOURCE_XML) from LIB..ARTICLES;

*GOOD* The expression is compiled once when SQL query is compiled:

    select xquery_eval('count(//article[@id=$main_id]/abstract)', SOURCE_XML, 1, vector('main_id', MAIN_ID))
      from LIB..ARTICLES;

*POOR* The expression is compiled once per data row. In addition, a
hard-to-find error will occur if a value of MAIN\_ID may contain double
quote or a backslash character.

    select xquery_eval(sprintf('count(//article[@id="%s"]/abstract)', MAIN_ID), SOURCE_XML)
      from LIB..ARTICLES;

*GOOD* The XQuery expression is compiled once per execution of the SQL
query. The SQL compiler pays special attention to queries that import
external resources, because the content and availability of these
resources may differ from call to call. In addition, importing an
external resource is usually not possible during SQL compilation due to
deadlock danger, so the compilation is postponed until run time, but
this is not too bad anyway. Even in this sophisticated case, XQuery can
contain calls of [`sql:column()`](#xpf__sql__column) .

    select xquery_eval('
        namespace tools="http://www.example.com/lib/tools/"
        import define "http://www.example.com/lib/tools/common.xqr"
        tools:extract-keywords(//abstract)',
      SOURCE_XML)
    from LIB..ARTICLES;

*GOOD* Two XQuery expressions are compiled during SQL compilation.

    select
      case
        when SOURCE_IS_DOCBOOK then xquery_eval ('//formalpara[title="See Also"]/para', SOURCE_XML)
        else xquery_eval ('//p[@style="seealso"]', SOURCE_XML)
      end
    from LIB..ARTICLES;

*POOR* Virtuoso can not pre-compile XQquery expressions. Moreover, only
one precompiled expression is cached per occurrence of xquery\_eval() in
the SQL statement so it is possible that an XQuery compiler will start
once per data row.

    select
      xquery_eval (
        case
          when SOURCE_IS_DOCBOOK then '//formalpara[title="See Also"]/para'
          else '//p[@style="seealso"]'
        end,
      SOURCE_XML)
    from LIB..ARTICLES;

# XSLT Transformation

Virtuoso implements XSLT 1.0 transformations as SQL callable functions.
In general, Virtuoso's XSLT processor follows the XSLT 1.0 standard as
far as possible without loss of database-related functionality. The most
important difference is in error handling. While XSLT rules assume that
almost any error must be recovered, Virtuoso will stop the
transformation in case of data access error or in case of serious
arithmetic error, such as divide by zero. This is due to the greater
complexity of the Virtuoso XSLT processor's environment. Standalone
processors generally accept a set of files as input parameters, the only
output is the resulting transformation as a file, and all configuration
parameters are listed on the command line. Virtuoso's XSLT processor may
retrieve both data and stylesheets from local filesystems, local tables,
remote datasources, or the Web. Parameters of the stylesheet
transformation may be prepared by complicated Virtuoso PL procedures and
so on. Plain XSLT processors may continue producing "dirty" output;
Virtuoso's processor will stop upon encountering serious in order to
produce helpful error diagnostics.

Another important difference is that Virtuoso has one processor for
XSLT, XPath and XQuery. The user will find this convenient because an
application may use XSLT-specific functions in XPath expressions, XQuery
functions in XSLT, and so on. If extension functions are defined for the
XSLT processor, they may also be used in XPath and XQuery expressions
without any additional operations. One caveat is that this may
invalidate some rules related to the document order of nodes in
node-sets. Both the XPath 1.0 and XSLT 1.0 standards say that some
functions must process the node that is first in document order from a
given node-set. In such cases Virtuoso's processor will process the
first node found in the node-set, regardless of whether it is actually
the first in document order or not. This is done because the old XPath
rule is nonsensical if nodes of the node-set are retrieved from more
than one document or are created in the query. The processor follows the
old rule for 99% of real expressions. Specifically, it fully matches the
standards' rules for all XPath expressions that are free of
reverse-order axes and non-standard functions.

## Namespaces

In the following the

    xsl:

namespace prefix is used to mean "http://www.w3.org/XSL/Transform/1.0".
In fact all namespace URI's beginning with
"http://www.w3.org/XSL/Transform" are considered as the XSLT namespace.
The namespaces "http://www.w3.org/1999/XSL/Transform" and
"http://www.w3.org/TR/WD-xsl" are recognized as synonymous. No other
namespace URI's have special significance.

## The `<xsl:output>` Tag

The Virtuoso XSLT processor recognizes and verifies the `<xsl:output>`
tag. The only `<xsl:output>` attributes that are used are the `method` ,
`encoding` , `omit-xml-declaration` , `media-type` , `doctype-public`
`doctype-system` and `indent` . The processor output is created in the
character set that is in effect for the client or the one specified by
encoding.

The SQL function
[`xml_tree_doc_media_type()`](#fn_xml_tree_doc_media_type) returns the
media type in effect for the result of the [`xslt()`](#fn_xslt) function
based on the xsl:output `media-type` and `method` attributes of the
stylesheet applied. This method is also used for producing FOR XML AUTO
WebDAV resources for HTTP reply generation.

## External Parameters in XSLT Stylesheets

The XSLT 1.0 standard specifies that parameters may be passed to the
XSLT processor from its environment in order to control data
transformation, but the details are implementation-specific. Virtuoso's
XSLT Processor will accept default values for global parameters from the
optional third argument of the [xslt()](#fn_xslt) Virtuoso PL function.
This argument, if specified, must be a vector of parameter names and
values of the form

    vector(name1, value1,... nameN,
    valueN)

, where `name1 ... nameN` must be of type `varchar` , and `value1
... valueN` may be of any Virtuoso datatype, but may not be null. If a
parameter has a null value specified, it is removed from the vector
without any further processing. After removal of null values, duplicate
names are eliminated. If a name occurs more than once in the vector,
only the last one will be retained.

When the XSLT Processor begins the transformation of the document, it
creates two stacks of variables, one for global variables and one for
local variables. Initially the stacks are empty. Then it prepares
temporary indexes for all `<xsl:key>` elements; all future calls of
[`key()`](#xpf_key) function will return without any searches through
the source document. Only after the processing of all keys of the
stylesheet, the XSLT Processor pushes all parameters from the third
argument of the [`xslt()`](#fn_xslt) function into the stack of local
variables. Then, as described in the XSLT specification, it initializes
top-level variables and parameters. For every `<xsl:variable>` or
`<xsl:param>` element found at the top-level of the main stylesheet or
at the top level of some imported stylesheet, the processor calculates
the value and pushes the created variable into the stack of local
variables. The `<xsl:param>` element is ignored if the specified name is
already declared in the vector of parameters or in some stylesheet
imported before. When all top-level variables and parameters are
initialized, the content of the stack of local variables is moved into
the stack of global variables, and the stack of local variables is made
empty. During the rest of the XSLT transformation, these variables will
be used as global variables. They may be temporarily shadowed by inner
declarations of local variables - though not by declarations of local
parameters - but they cannot be changed. Note that expressions for
values of variables and parameters may contain calls of
[`key()`](#xpf_key) function, because temporary indexes are ready to use
before the first such expression is calculated. Expressions of
`<xsl:key>` elements may not refer to any parameters or variables, due
to the same reason.

## Functions

The [`xslt()`](#fn_xslt) Virtuoso/PL function applies a given stylesheet
to a given source XML document and returns the transformed document.
There is no restriction to what a VSP page can output, this is usually
HTML but can be XML. The function [`http_xslt()`](#fn_http_xslt) allows
a stylesheet to be applied to a whole output of an VSP page before it is
sent to the user agent. Functions [`xslt_sheet()`](#fn_xslt_sheet) and
[`xslt_stale()`](#fn_xslt_stale) allow you to create and destroy a
stylesheet dynamically. Function [`xmlupdate()`](#fn_xmlupdate) is
convenient for very simple "search-and replace" transformations.

## XSLT Examples

This section covers some examples of applying XSLT to various stored
data.

    create procedure xml_view_string (in _view varchar)
    {
      declare _body any;
      declare _pf varchar;
      _body := string_output ();
      http ('<document>', _body);
      _pf := concat ('DB.DBA.http_view_', _view);
      call (_pf) (_body);
      http ('</document>', _body);
    
      return (string_output_string (_body));
    }

    create procedure xslt_view (in v varchar, in xst varchar)
    {
    
      declare str, r varchar;
      xslt_sheet (xst, xtree_doc (file_to_string (xst)));
      str := xml_view_string (v);
      r := xslt (xst, xtree_doc (str));
      declare str_out any;
      str_out := string_output ();
      http_value (r, 0, str_out);
      string_to_file ('xslt.out', string_output_string (str_out), 0);
    }

These functions will take the serialized text of an XML view created
with CREATE XML VIEW, transform it with a stylesheet and store the
result into a file.

The first function returns a string containing the text generated as the
value of the XML view specified as argument. It calls the serialization
function, which is

    DB.DBA.http_view_ +
    view name

. This function writes the text into the string output stream passed to
it. Note that the function wraps the text inside a `<document>` element
in order to make it well-formed, since the view serialization function
will emit multiple top-level elements, one for each selected row in the
root table in the XML view.

The `xslt_view()` function first defines the style sheet, which it takes
from a file in this case. The `xslt_sheet()` function is called with the
name and root element of the parsed file.

The function next gets the string to process, parses it as XML, and
converts the parse tree into an entity object. This is then passed to
the `xslt()` function. The result is another entity object. This is
finally serialized as XML text and written into the file `xslt.out` .

These examples show how to parse and serialize XML using varchars,
string output streams and the entity data type.

The central points are:

1.  The XML entity object is a reference to a particular element of a
    parsed XML document, The underlying document is only visible through
    this reference. A string is converted into such a document and a
    reference to the document's root is returned by the
    
        xtree_doc (string)
    
    function. In previous versions of Virtuoso, the combination
    
        xml_tree_doc (xml_tree (string))
    
    was used for this purpose; this combination still works to maintain
    backwards compatibility, but using xtree\_doc() is preferable.

2.  A string output is used to capture the serialization of data by the
    `http_value()` function. If the string output were not specified the
    data would be sent to the HTTP client directly, if we were running
    in an HTTP request context.

## XPath Function Extensions for XSLT

Virtuoso provides a way to extend the abilities of the XSLT processor by
creating user defined XPath functions. The functions
[`xpf_extension()`](#fn_xpf_extension) and
[`xpf_extension_remove()`](#fn_xpf_extension_remove) allow addition and
removal of XPath extension functions.

## Status Of XSLT And XPath Implementation

Items marked with (\*) are currently not implemented.

### XPath Axes

ancestor::

ancestor-or-self::

attribute::

child::

descendant::

descendant-or-self::

following::

following-sibling::

namespace:: (\*)

parent::

preceding::

preceding-sibling::

self::

### Node Functions

number

position

()

number

count

(node-set)

string

local-name

(node-set?)

string

namespace-uri

(node-set?)

string

name

(node-set?)

boolean

lang

(string)

### Node Set Functions

node-set

document

(string, string?, integer?, name?, name?, string?)

node-set

document-literal

(string, string?, integer?, name?, name?, string?)

node-set

id

(object)

node-set

append

(object, object, ..., object)

### String Functions

string

string

(object?)

string

serialize

(object?)

string

format-number

(number, string, string?)

string

concat

(object, object, ..., object)

number

string-length

(string?)

boolean

contains

(string, string)

boolean

text-contains

(string, string)

boolean

starts-with

(string, string)

boolean

ends-with

(string, string)

string

substring

(string, number, number?)

string

substring-before

(string, string)

string

substring-after

(string, string)

string

normalize-space

(string?)

string

translate

(string, string, string)

string

replace

(string, string, string)

### Boolean Functions

boolean

boolean

(object)

boolean

true

()

boolean

false

()

boolean

not

(boolean)

boolean

and

(boolean, boolean, ..., boolean)

boolean

or

(boolean, boolean, ..., boolean)

boolean

some

(name, boolean, node-set)

boolean

every

(name, boolean, node-set)

boolean

function\_available

(name)

### Number Functions

number

number

(object?)

number

floor

(number)

number

ceiling

(number)

number

round

(number)

number

sum

(number)

number

avg

(number)

number

max

(number)

number

min

(number)

### XSLT-specific Functions

current

()

function-available

(string)

unparsed-entity-uri

(string)

system-property

(string)

### XSLT 1.0 Elements and Attributes

xsl:apply-imports

xsl:apply-templates

xsl:attribute

xsl:attribute-set (\*)

xsl:call-template

xsl:choose

xsl:comment

xsl:copy

xsl:copy-of

xsl:decimal-format

xsl:element

xsl:fallback (\*)

xsl:for-each

xsl:if

xsl:import

xsl:include

xsl:key

xsl:message

xsl:namespace-alias

xsl:number NOTE: formatting and level="any" is not implemented

xsl:otherwise

xsl:output

xsl:param

xsl:preserve-space (\*)

xsl:processing-instruction

xsl:sort

xsl:strip-space

xsl:stylesheet

xsl:template

xsl:text

xsl:transform (\*) NOTE: use xsl:stylesheet instead

xsl:value-of

xsl:variable

xsl:when

xsl:with-param

# XMLType

XMLType is a predefined type for representing XML entities as UDT
objects. This is compatible with Oracle9i and later. You can get better
performance and flexibility by using use plain built-in functions that
directly operate with XML entities. All predefined member functions of
XMLType for extracting fragments from an XMLType are actually wrappers
for [`xpath_eval()`](#fn_xpath_eval) built-in function. You can declare
a column of XMLType but the actual type of the created column will be
"LONG XML". Thus any XML-related feature that can be used for "LONG XML"
column will work with XMLType. E.g. [WITH SCHEMA
constraint](#sqlrefcreattablewithschema) allows you to force stored
values to match a particular schema; [XML free text
index](#usingxmlfreetext) can accelerate search for documents by content
etc.

XMLType behaves like any user-defined type, with the only difference in
type conversion rules. If an XML entity is passed as an argument instead
of an instance of XMLType, a new instance of XMLType is created by a
constructor that takes the entity as an argument. Similarly, functions
that accept XML entities as arguments can also accept an instance of
XMLType as an actual value of argument.

The following example creates a table with an XMLType column, put two
records there and performs a simple search:

    CREATE TABLE Xml_tab ( xmlval XMLType);
    
    INSERT INTO Xml_tab VALUES (
       xmltype('<?xml version="1.0"?>
                   <EMP>
                      <EMPNO>221</EMPNO>
                      <ENAME>John</ENAME>
                   </EMP>'));
    
    INSERT INTO Xml_tab VALUES (
       xmltype('<?xml version="1.0"?>
                   <PO>
                      <PONO>331</PONO>
                      <PONAME>PO_1</PONAME>
                   </PO>'));
    
    -- now extract the numerical values for the employee numbers
    
    SELECT e.xmlval.extract('//EMPNO/text()').getNumVal() as empno
       FROM Xml_tab
       WHERE e.xmlval.existsnode('/EMP/EMPNO')  = 1;

To create a new instance of XMLType, the constructor
[`XMLType()`](#fn_xmltype.xmltype) or a function
[`createXML()`](#fn_createxml) is used.

Virtuoso can perform XPATH search in XMLType instances:
[`extract()`](#fn_xmltype.extract) and
[`existsNode()`](#fn_xmltype.existsnode) member functions are convenient
for simple searches and any built-in XPATH functions like
[`xpath_eval()`](#fn_xpath_eval) or [`xquery_eval()`](#fn_xquery_eval)
can handle XMLType parameters instead of XML entity parameters. An
application can use [`getStringVal()`](#fn_xmltype.getstringval) ,
[`getNumVal()`](#fn_xmltype.getnumval) and
[`getColbVal()`](#fn_xmltype.getclobval) member functions to convert
found node to strings, numbers or an XML source text of the node.

Instances of the type can store the URL of the XML schema to which they
should conform. This URL can be specified when an instance is
constructed; Once an instance is created, its schema URL cannot be
changed but a modified copy can be created by
[`createSchemaBasedXML()`](#fn_xmltype.createschemabasedxml) and
[`createNonSchemaBasedXML()`](#fn_xmltype.createnonschemabasedxml)
member functions; [`isSchemaBased()`](#fn_xmltype.isschemabased) and
[`getSchemaURL()`](#fn_xmltype.getschemaurl) member functions check
whether the given instance is schema based or not and what particular
schema is used.

An schema based XMLType instance can be validated against its schema; If
it has been validated against its schema once with no errors detected
then a special "VALIDATED" flag is set in the instance indicating that
there is no need to validate it again.
[`schemaValidate()`](#fn_xmltype.schemavalidate) member function
performs the validation,
[`isSchemaValidated()`](#fn_xmltype.isschemavalidated) queries the
"VALIDATED" flag and
[`setSchemaValidated()`](#fn_xmltype.setschemavalidated) changes the
"VALIDATED" flag if application needs optimization tricks.

In addition, any instance can be validated against an arbitrary schema
via member function [`isSchemaValid()`](#fn_xmltype.isschemavalid) .
Built-in function `xml_validate_schema()` may accept instance of XMLType
as its first argument, providing even more validation functionality.

# Changing XML entities in DOM style

An application may need to perform small irregular changes in an XML
document. It can be time-consuming to create a modified copy of a whole
document for making each small change. It can be also hard to express
condition for making the change in terms of XPath in order to use XSLT
or XQuery.

Virtuoso offers a way to modify an existing XML entity by local
operations like "insert a subtree before current node" or "replace one
subtree with a given one". These operations are called DOM operations
because they are similar to JavaScript operations with the Document
Object Model.

DOM operations are the only operations that change an existing XML
document instead of creating a new modified document. It is very
important to understand that one document can be shared between many XML
entities so changes made via one entity may affect data accessible via
other entities that share the same document. Every XML document has
special flags to "lock" its content and thus prevent the content from
being changed. E.g. XSLT and XQuery processors optimize access to the
source document in hope that every access to any entity will produce the
same result during the whole run of the processor. If an extension
function will modify the source document in the middle then the result
of the processing is probably corrupted and this error may be very hard
to detect and debug. To prevent this sort of problems, the XSLT
processor locks the source at start and unlock at end so any attempt to
modify the source during the run will signal an error. The document can
be locked in the following cases:

  - The document is the source of the XSLT processing that is in
    progress.

  - The document contains the context node that is passed to the XQuery
    processor at start.

  - The document is used as a external generic entity in some other
    document.

  - The document is created by the call of XPath function doc, document
    or document-literal during the processing of some other document and
    that document is still in use.

One additional issue of using DOM operations is that any DOM operation
invalidates DTD and schema validation information that was associated
with the document before the operation.

  - **Schema validation status ("is validated" flag).**
    
    E.g. if an schema based instance of XMLType is validated against its
    schema and thus it has set its "is validated" flag to 1 then the
    flag is to be reset to zero if the XML entity of this instance is
    modified by DOM operation, because there is no guarantee that the
    modified document is still valid against the declared schema; if the
    application will repeat the validation and it is successful then the
    flag will be set to 1 again.

  - **DTD-based processing of ID attributes.**
    
    A validating XML parser can build special dictionaries of ID
    attributes when it reads a document. These dictionaries are used by
    [`id`](#xpf_id) XPATH function and "pointer operator" of XQuery to
    find a node labeled by a given ID value without searching the whole
    document. Any change in document tree invalidates data in these
    dictionaries so any access to them will signal an error.

## Composing Document Fragments From DOM Function Arguments

When a DOM modification function adds some nodes to the tree, the
content of these nodes comes from values of arguments of the function.
In the most common case, some generic entity is created from one or more
arguments and the function adds the content of the entity into the
appropriate place of the document. This process is regulated by a small
set of very intuitive rules.

All data to be inserted are calculated before any modification of the
document is started. For example it is safe to insert into the document
a fragment of this document, even if it contains the point of insertion;
such operation will never cause infinite loops.

If an instance of XMLType is passed then its internal XML entity is
used.

If an argument is neither an XML entity nor a string then it is cast to
the string first.

If an argument is NULL then it is fully ignored, as if there is no such
argument at all.

A root node of a document can not be added into the tree of other
document. Instead, every child node of the root (i.e. every top-level
node of the document) is added to the target document, the order of
child nodes will be preserved. An XML document usually contains only one
top-level element node, but it also can contain comment and processing
instruction nodes at top-level. Depending on the application, such
comments and instructions may be inappropriate in the middle of the
modified document. Thus it is worth to check what the application should
insert: the root node with everything inside or only a top-level element
node.

If some function accepts a list of arguments as list of values to be
inserted, these values will be concatenated into a single generic
entity. It is important to remember that the XML document can not
contain two neighbour text nodes. If two consecutive arguments are
strings then a single node that is a concatenation of these string is
added. If the value of one argument is a string and the value of the
next argument is a tree fragment that starts with a string then this
pair of strings will also be replaced with a concatenation of these
strings. When a function inserts a text after some existing text node of
the XML document, no new node is created and the existing text node is
replaced with the text node that is the concatenation of old and new
texts.

In general, you should not expect that adding N values into the document
will add N new nodes to the document. It can add a lesser number of
nodes due to ignoring NULLs and concatenating some texts. It can also
add a greater number of nodes if some values are root nodes with many
children.
